import React from 'react';
import afterFrame from 'afterframe';
import { select } from 'd3';
import debounce from 'lodash/debounce';
import { getRandomCKId, measurePerformance } from '../../../utils';
import { Chart } from './components';
import { validateData } from './validation';
const D3Widget = React.forwardRef(function D3Widget(props, forwardedRef) {
    const { data, onLoad, onRender, onChartLoad } = props;
    const validatedData = React.useRef();
    const ref = React.useRef(null);
    const debounced = React.useRef();
    const [dimensions, setDimensions] = React.useState();
    const performanceMeasure = React.useRef(measurePerformance());
    const handleResize = React.useCallback(() => {
        var _a;
        const parentElement = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.parentElement;
        if (parentElement) {
            const { width, height } = parentElement.getBoundingClientRect();
            setDimensions({ width, height });
        }
    }, []);
    const debuncedHandleResize = React.useMemo(() => {
        var _a;
        (_a = debounced.current) === null || _a === void 0 ? void 0 : _a.cancel();
        debounced.current = debounce(handleResize, 200);
        return debounced.current;
    }, [handleResize]);
    React.useImperativeHandle(forwardedRef, () => ({
        reflow() {
            debuncedHandleResize();
        },
    }), [debuncedHandleResize]);
    React.useEffect(() => {
        const selection = select(window);
        // https://github.com/d3/d3-selection/blob/main/README.md#handling-events
        const eventName = `resize.${getRandomCKId()}`;
        selection.on(eventName, debuncedHandleResize);
        return () => {
            // https://d3js.org/d3-selection/events#selection_on
            selection.on(eventName, null);
        };
    }, [debuncedHandleResize]);
    React.useEffect(() => {
        // dimensions initialize
        debuncedHandleResize();
    }, [debuncedHandleResize]);
    if (validatedData.current !== data) {
        validateData(data);
        validatedData.current = data;
    }
    React.useLayoutEffect(() => {
        if (onChartLoad) {
            onChartLoad({});
        }
    }, [onChartLoad]);
    React.useLayoutEffect(() => {
        if (dimensions === null || dimensions === void 0 ? void 0 : dimensions.width) {
            if (!performanceMeasure.current) {
                performanceMeasure.current = measurePerformance();
            }
            afterFrame(() => {
                var _a;
                const renderTime = (_a = performanceMeasure.current) === null || _a === void 0 ? void 0 : _a.end();
                onRender === null || onRender === void 0 ? void 0 : onRender({
                    renderTime,
                });
                onLoad === null || onLoad === void 0 ? void 0 : onLoad({
                    widgetRendering: renderTime,
                });
                performanceMeasure.current = null;
            });
        }
    }, [data, onRender, onLoad, dimensions]);
    return (React.createElement("div", { ref: ref, style: {
            width: (dimensions === null || dimensions === void 0 ? void 0 : dimensions.width) || '100%',
            height: (dimensions === null || dimensions === void 0 ? void 0 : dimensions.height) || '100%',
            position: 'relative',
        } }, (dimensions === null || dimensions === void 0 ? void 0 : dimensions.width) && (dimensions === null || dimensions === void 0 ? void 0 : dimensions.height) && (React.createElement(Chart, { width: dimensions.width, height: dimensions.height, data: data }))));
});
export default D3Widget;
