import React from 'react';
import { select } from 'd3';
import { block } from '../../../../utils/cn';
import { formatAxisTickLabel, getAxisTitleRows, getClosestPointsRange, getMaxTickCount, getScaleTicks, getTicksCount, handleOverflowingText, } from '../utils';
import { axisBottom } from '../utils/axis-generators';
const b = block('d3-axis');
function getLabelFormatter({ axis, scale }) {
    const ticks = getScaleTicks(scale);
    const tickStep = getClosestPointsRange(axis, ticks);
    return (value) => {
        if (!axis.labels.enabled) {
            return '';
        }
        return formatAxisTickLabel({
            axis,
            value,
            step: tickStep,
        });
    };
}
export function getTitlePosition(args) {
    const { axis, width, rowCount } = args;
    if (rowCount < 1) {
        return { x: 0, y: 0 };
    }
    let x;
    const y = axis.title.height / rowCount + axis.title.margin + axis.labels.height + axis.labels.margin;
    switch (axis.title.align) {
        case 'left': {
            x = axis.title.width / 2;
            break;
        }
        case 'right': {
            x = width - axis.title.width / 2;
            break;
        }
        case 'center': {
            x = width / 2;
            break;
        }
    }
    return { x, y };
}
export const AxisX = React.memo(function AxisX(props) {
    const { axis, width, height: totalHeight, scale, split } = props;
    const ref = React.useRef(null);
    React.useEffect(() => {
        if (!ref.current) {
            return;
        }
        let tickItems = [];
        if (axis.grid.enabled) {
            tickItems = new Array(split.plots.length || 1).fill(null).map((_, index) => {
                var _a, _b;
                const top = ((_a = split.plots[index]) === null || _a === void 0 ? void 0 : _a.top) || 0;
                const height = ((_b = split.plots[index]) === null || _b === void 0 ? void 0 : _b.height) || totalHeight;
                return [-top, -(top + height)];
            });
        }
        const xAxisGenerator = axisBottom({
            scale: scale,
            ticks: {
                items: tickItems,
                labelFormat: getLabelFormatter({ axis, scale }),
                labelsPaddings: axis.labels.padding,
                labelsMargin: axis.labels.margin,
                labelsStyle: axis.labels.style,
                labelsMaxWidth: axis.labels.maxWidth,
                labelsLineHeight: axis.labels.lineHeight,
                count: getTicksCount({ axis, range: width }),
                maxTickCount: getMaxTickCount({ axis, width }),
                rotation: axis.labels.rotation,
            },
            domain: {
                size: width,
                color: axis.lineColor,
            },
        });
        const svgElement = select(ref.current);
        svgElement.selectAll('*').remove();
        svgElement.call(xAxisGenerator).attr('class', b());
        // add an axis header if necessary
        if (axis.title.text) {
            const titleRows = getAxisTitleRows({ axis, textMaxWidth: width });
            svgElement
                .append('text')
                .attr('class', b('title'))
                .attr('transform', () => {
                const { x, y } = getTitlePosition({ axis, width, rowCount: titleRows.length });
                return `translate(${x}, ${y})`;
            })
                .attr('font-size', axis.title.style.fontSize)
                .attr('text-anchor', 'middle')
                .selectAll('tspan')
                .data(titleRows)
                .join('tspan')
                .attr('x', 0)
                .attr('y', (d) => d.y)
                .text((d) => d.text)
                .each((_d, index, nodes) => {
                if (index === axis.title.maxRowCount - 1) {
                    handleOverflowingText(nodes[index], width);
                }
            });
        }
    }, [axis, width, totalHeight, scale, split]);
    return React.createElement("g", { ref: ref });
});
