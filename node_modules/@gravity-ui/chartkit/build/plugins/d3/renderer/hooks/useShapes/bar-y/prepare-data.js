import { ascending, descending, max, sort } from 'd3';
import get from 'lodash/get';
import { getDataCategoryValue } from '../../../utils';
import { MIN_BAR_GAP, MIN_BAR_GROUP_GAP, MIN_BAR_WIDTH } from '../constants';
function groupByYValue(series, yAxis) {
    const data = {};
    series.forEach((s) => {
        s.data.forEach((d) => {
            const axisIndex = get(s, 'yAxis', 0);
            const seriesYAxis = yAxis[axisIndex];
            const categories = get(seriesYAxis, 'categories', []);
            const key = seriesYAxis.type === 'category'
                ? getDataCategoryValue({ axisDirection: 'y', categories, data: d })
                : d.y;
            if (key) {
                if (!data[key]) {
                    data[key] = {};
                }
                if (!data[key][s.stackId]) {
                    data[key][s.stackId] = [];
                }
                data[key][s.stackId].push({ data: d, series: s });
            }
        });
    });
    return data;
}
function getBandWidth(series, yAxis, yScale) {
    let bandWidth = Infinity;
    if (yAxis[0].type === 'category') {
        bandWidth = yScale.bandwidth();
    }
    else {
        const scale = yScale;
        const axisValues = series.reduce((acc, s) => {
            s.data.forEach((dataItem) => acc.push(Number(dataItem.y)));
            return acc;
        }, []);
        axisValues.sort().forEach((value, index) => {
            if (index > 0 && value !== axisValues[index - 1]) {
                const dist = scale(value) - scale(axisValues[index - 1]);
                if (dist < bandWidth) {
                    bandWidth = dist;
                }
            }
        });
    }
    return bandWidth;
}
export const prepareBarYData = (args) => {
    const { series, seriesOptions, yAxis, xScale, yScale: [yScale], } = args;
    const xLinearScale = xScale;
    const plotWidth = xLinearScale(xLinearScale.domain()[1]);
    const barMaxWidth = get(seriesOptions, 'bar-y.barMaxWidth');
    const barPadding = get(seriesOptions, 'bar-y.barPadding');
    const groupPadding = get(seriesOptions, 'bar-y.groupPadding');
    const sortingOptions = get(seriesOptions, 'bar-y.dataSorting');
    const comparator = (sortingOptions === null || sortingOptions === void 0 ? void 0 : sortingOptions.direction) === 'desc' ? descending : ascending;
    const sortKey = (() => {
        switch (sortingOptions === null || sortingOptions === void 0 ? void 0 : sortingOptions.key) {
            case 'x': {
                return 'data.x';
            }
            case 'name': {
                return 'series.name';
            }
            default: {
                return undefined;
            }
        }
    })();
    const groupedData = groupByYValue(series, yAxis);
    const bandWidth = getBandWidth(series, yAxis, yScale);
    const maxGroupSize = max(Object.values(groupedData), (d) => Object.values(d).length) || 1;
    const groupGap = Math.max(bandWidth * groupPadding, MIN_BAR_GROUP_GAP);
    const groupWidth = bandWidth - groupGap;
    const rectGap = Math.max(bandWidth * barPadding, MIN_BAR_GAP);
    const barHeight = Math.max(MIN_BAR_WIDTH, Math.min(groupWidth / maxGroupSize - rectGap, barMaxWidth));
    const result = [];
    Object.entries(groupedData).forEach(([yValue, val]) => {
        const stacks = Object.values(val);
        const currentBarHeight = barHeight * stacks.length + rectGap * (stacks.length - 1);
        stacks.forEach((measureValues, groupItemIndex) => {
            const base = xLinearScale(0);
            let stackSum = base;
            const stackItems = [];
            const sortedData = sortKey
                ? sort(measureValues, (a, b) => comparator(get(a, sortKey), get(b, sortKey)))
                : measureValues;
            sortedData.forEach(({ data, series: s }) => {
                let center;
                if (yAxis[0].type === 'category') {
                    const bandScale = yScale;
                    center = (bandScale(yValue) || 0) + bandWidth / 2;
                }
                else {
                    const scale = yScale;
                    center = scale(Number(yValue));
                }
                const y = center - currentBarHeight / 2 + (barHeight + rectGap) * groupItemIndex;
                const xValue = Number(data.x);
                const width = xValue > 0 ? xLinearScale(xValue) - base : base - xLinearScale(xValue);
                stackItems.push({
                    x: xValue > 0 ? stackSum : stackSum - width,
                    y,
                    width,
                    height: barHeight,
                    color: data.color || s.color,
                    opacity: get(data, 'opacity', null),
                    data,
                    series: s,
                });
                stackSum += width + 1;
            });
            if (series.some((s) => s.stacking === 'percent')) {
                let acc = 0;
                const ratio = plotWidth / (stackSum - stackItems.length);
                stackItems.forEach((item) => {
                    item.width = item.width * ratio;
                    item.x = acc;
                    acc += item.width;
                });
            }
            result.push(...stackItems);
        });
    });
    return result;
};
