import { group, sort } from 'd3';
import { getDataCategoryValue, getLabelsSize, getLeftPosition } from '../../../utils';
import { getXValue, getYValue } from '../utils';
function getLabelData(point, series, xMax) {
    const text = String(point.data.label || point.data.y);
    const style = series.dataLabels.style;
    const size = getLabelsSize({ labels: [text], style });
    const labelData = {
        text,
        x: point.x,
        y: point.y - series.dataLabels.padding,
        style,
        size: { width: size.maxWidth, height: size.maxHeight },
        textAnchor: 'middle',
        series: series,
        active: true,
    };
    const left = getLeftPosition(labelData);
    if (left < 0) {
        labelData.x = labelData.x + Math.abs(left);
    }
    else {
        const right = left + labelData.size.width;
        if (right > xMax) {
            labelData.x = labelData.x - xMax - right;
        }
    }
    return labelData;
}
function getXValues(series, xAxis, xScale) {
    const categories = xAxis.categories || [];
    const xValues = series.reduce((acc, s) => {
        s.data.forEach((d) => {
            const key = String(xAxis.type === 'category'
                ? getDataCategoryValue({ axisDirection: 'x', categories, data: d })
                : d.x);
            if (!acc.has(key)) {
                acc.set(key, getXValue({ point: d, xAxis, xScale }));
            }
        });
        return acc;
    }, new Map());
    if (xAxis.type === 'category') {
        return categories.reduce((acc, category) => {
            const xValue = xValues.get(category);
            if (typeof xValue === 'number') {
                acc.push([category, xValue]);
            }
            return acc;
        }, []);
    }
    return sort(Array.from(xValues), ([_x, xValue]) => xValue);
}
export const prepareAreaData = (args) => {
    const { series, xAxis, xScale, yAxis, yScale, boundsHeight: plotHeight } = args;
    const [_xMin, xRangeMax] = xScale.range();
    const xMax = xRangeMax / (1 - xAxis.maxPadding);
    return Array.from(group(series, (s) => s.stackId)).reduce((result, [_stackId, seriesStack]) => {
        const xValues = getXValues(seriesStack, xAxis, xScale);
        const accumulatedYValues = new Map();
        xValues.forEach(([key]) => {
            accumulatedYValues.set(key, 0);
        });
        const seriesStackData = seriesStack.reduce((acc, s) => {
            const yAxisIndex = s.yAxis;
            const seriesYAxis = yAxis[yAxisIndex];
            const seriesYScale = yScale[yAxisIndex];
            const yMin = getYValue({ point: { y: 0 }, yAxis: seriesYAxis, yScale: seriesYScale });
            const seriesData = s.data.reduce((m, d) => {
                const key = String(xAxis.type === 'category'
                    ? getDataCategoryValue({
                        axisDirection: 'x',
                        categories: xAxis.categories || [],
                        data: d,
                    })
                    : d.x);
                return m.set(key, d);
            }, new Map());
            const points = xValues.reduce((pointsAcc, [x, xValue]) => {
                const accumulatedYValue = accumulatedYValues.get(x) || 0;
                const d = seriesData.get(x) ||
                    {
                        x,
                        // FIXME: think about how to break the series into separate areas(null Y values)
                        y: 0,
                    };
                const yValue = getYValue({ point: d, yAxis: seriesYAxis, yScale: seriesYScale }) -
                    accumulatedYValue;
                accumulatedYValues.set(x, yMin - yValue);
                pointsAcc.push({
                    y0: yMin - accumulatedYValue,
                    x: xValue,
                    y: yValue,
                    data: d,
                    series: s,
                });
                return pointsAcc;
            }, []);
            let labels = [];
            if (s.dataLabels.enabled) {
                labels = points.map((p) => getLabelData(p, s, xMax));
            }
            let markers = [];
            if (s.marker.states.normal.enabled || s.marker.states.hover.enabled) {
                markers = points.map((p) => ({
                    point: p,
                    active: true,
                    hovered: false,
                }));
            }
            acc.push({
                points,
                markers,
                labels,
                color: s.color,
                opacity: s.opacity,
                width: s.lineWidth,
                series: s,
                hovered: false,
                active: true,
                id: s.id,
            });
            return acc;
        }, []);
        if (series.some((s) => s.stacking === 'percent')) {
            xValues.forEach(([x], index) => {
                const stackHeight = accumulatedYValues.get(x) || 0;
                let acc = 0;
                const ratio = plotHeight / stackHeight;
                seriesStackData.forEach((item) => {
                    const point = item.points[index];
                    if (point) {
                        const height = (point.y0 - point.y) * ratio;
                        point.y0 = plotHeight - height - acc;
                        point.y = point.y0 + height;
                        acc += height;
                    }
                });
            });
        }
        return result.concat(seriesStackData);
    }, []);
};
