import React from 'react';
import { color, select } from 'd3';
import get from 'lodash/get';
import { block } from '../../../../../../utils/cn';
export { prepareBarYData } from './prepare-data';
const DEFAULT_LABEL_PADDING = 7;
const b = block('d3-bar-y');
export const BarYSeriesShapes = (args) => {
    const { dispatcher, preparedData, seriesOptions } = args;
    const ref = React.useRef(null);
    React.useEffect(() => {
        if (!ref.current) {
            return () => { };
        }
        const svgElement = select(ref.current);
        svgElement.selectAll('*').remove();
        const rectSelection = svgElement
            .selectAll('rect')
            .data(preparedData)
            .join('rect')
            .attr('class', b('segment'))
            .attr('x', (d) => d.x)
            .attr('y', (d) => d.y)
            .attr('height', (d) => d.height)
            .attr('width', (d) => d.width)
            .attr('fill', (d) => d.color)
            .attr('opacity', (d) => d.data.opacity || null)
            .attr('cursor', (d) => d.series.cursor);
        const dataLabels = preparedData.filter((d) => d.series.dataLabels.enabled);
        const labelSelection = svgElement
            .selectAll('text')
            .data(dataLabels)
            .join('text')
            .text((d) => String(d.data.label || d.data.x))
            .attr('class', b('label'))
            .attr('x', (d) => {
            if (d.series.dataLabels.inside) {
                return d.x + d.width / 2;
            }
            return d.x + d.width + DEFAULT_LABEL_PADDING;
        })
            .attr('y', (d) => {
            return d.y + d.height / 2 + d.series.dataLabels.maxHeight / 2;
        })
            .attr('text-anchor', (d) => {
            if (d.series.dataLabels.inside) {
                return 'middle';
            }
            return 'right';
        })
            .style('font-size', (d) => d.series.dataLabels.style.fontSize)
            .style('font-weight', (d) => d.series.dataLabels.style.fontWeight || null)
            .style('fill', (d) => d.series.dataLabels.style.fontColor || null);
        const hoverOptions = get(seriesOptions, 'bar-y.states.hover');
        const inactiveOptions = get(seriesOptions, 'bar-y.states.inactive');
        dispatcher.on('hover-shape.bar-y', (data) => {
            if (hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.enabled) {
                const hovered = data === null || data === void 0 ? void 0 : data.reduce((acc, d) => {
                    acc.add(d.data.y);
                    return acc;
                }, new Set());
                rectSelection.attr('fill', (d) => {
                    var _a;
                    const fillColor = d.color;
                    if (hovered === null || hovered === void 0 ? void 0 : hovered.has(d.data.y)) {
                        return (((_a = color(fillColor)) === null || _a === void 0 ? void 0 : _a.brighter(hoverOptions.brightness).toString()) ||
                            fillColor);
                    }
                    return fillColor;
                });
            }
            if (inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.enabled) {
                const hoveredSeries = data === null || data === void 0 ? void 0 : data.map((d) => d.series.id);
                const newOpacity = (d) => {
                    if ((hoveredSeries === null || hoveredSeries === void 0 ? void 0 : hoveredSeries.length) && !hoveredSeries.includes(d.series.id)) {
                        return inactiveOptions.opacity || null;
                    }
                    return null;
                };
                rectSelection.attr('opacity', newOpacity);
                labelSelection.attr('opacity', newOpacity);
            }
        });
        return () => {
            dispatcher.on('hover-shape.bar-y', null);
        };
    }, [dispatcher, preparedData, seriesOptions]);
    return React.createElement("g", { ref: ref, className: b() });
};
