import React from 'react';
import { color, line as lineGenerator, select } from 'd3';
import get from 'lodash/get';
import { DashStyle } from '../../../../../../constants';
import { block } from '../../../../../../utils/cn';
import { filterOverlappingLabels, getWaterfallPointColor } from '../../../utils';
import { getLineDashArray } from '../utils';
export { prepareWaterfallData } from './prepare-data';
export * from './types';
const b = block('d3-waterfall');
export const WaterfallSeriesShapes = (args) => {
    const { dispatcher, preparedData, seriesOptions } = args;
    const ref = React.useRef(null);
    const connectorSelector = `.${b('connector')}`;
    React.useEffect(() => {
        var _a;
        if (!ref.current) {
            return () => { };
        }
        const svgElement = select(ref.current);
        const hoverOptions = get(seriesOptions, 'waterfall.states.hover');
        const inactiveOptions = get(seriesOptions, 'waterfall.states.inactive');
        svgElement.selectAll('*').remove();
        const rectSelection = svgElement
            .selectAll('allRects')
            .data(preparedData)
            .join('rect')
            .attr('class', b('segment'))
            .attr('x', (d) => d.x)
            .attr('y', (d) => d.y)
            .attr('height', (d) => d.height)
            .attr('width', (d) => d.width)
            .attr('fill', (d) => getWaterfallPointColor(d.data, d.series))
            .attr('opacity', (d) => d.opacity)
            .attr('cursor', (d) => d.series.cursor);
        let dataLabels = preparedData.map((d) => d.label).filter(Boolean);
        if (!((_a = preparedData[0]) === null || _a === void 0 ? void 0 : _a.series.dataLabels.allowOverlap)) {
            dataLabels = filterOverlappingLabels(dataLabels);
        }
        const labelSelection = svgElement
            .selectAll('text')
            .data(dataLabels)
            .join('text')
            .text((d) => d.text)
            .attr('class', b('label'))
            .attr('x', (d) => d.x)
            .attr('y', (d) => d.y)
            .attr('text-anchor', (d) => d.textAnchor)
            .style('font-size', (d) => d.style.fontSize)
            .style('font-weight', (d) => d.style.fontWeight || null)
            .style('fill', (d) => d.style.fontColor || null);
        // Add the connector line between bars
        svgElement
            .selectAll(connectorSelector)
            .data(preparedData)
            .join('path')
            .attr('class', b('connector'))
            .attr('d', (d, index) => {
            const line = lineGenerator();
            const prev = preparedData[index - 1];
            if (!prev) {
                return null;
            }
            const points = [];
            if (Number(prev.data.y) > 0) {
                points.push([prev.x, prev.y]);
            }
            else {
                points.push([prev.x, prev.y + prev.height]);
            }
            if (Number(d.data.y) > 0 && !d.data.total) {
                points.push([d.x + d.width, d.y + d.height]);
            }
            else {
                points.push([d.x + d.width, d.y]);
            }
            return line(points);
        })
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', () => getLineDashArray(DashStyle.Dash, 1));
        dispatcher.on('hover-shape.waterfall', (data) => {
            const hoverEnabled = hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.enabled;
            const inactiveEnabled = inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.enabled;
            if (!data) {
                if (hoverEnabled) {
                    rectSelection.attr('fill', (d) => getWaterfallPointColor(d.data, d.series));
                }
                if (inactiveEnabled) {
                    rectSelection.attr('opacity', null);
                    labelSelection.attr('opacity', null);
                }
                return;
            }
            if (hoverEnabled) {
                const hoveredValues = data.map((d) => d.data.x);
                rectSelection.attr('fill', (d) => {
                    var _a;
                    const fillColor = getWaterfallPointColor(d.data, d.series);
                    if (hoveredValues.includes(d.data.x)) {
                        const brightness = hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.brightness;
                        return ((_a = color(fillColor)) === null || _a === void 0 ? void 0 : _a.brighter(brightness).toString()) || fillColor;
                    }
                    return fillColor;
                });
            }
            if (inactiveEnabled) {
                const hoveredSeries = data.map((d) => d.series.id);
                rectSelection.attr('opacity', (d) => {
                    return hoveredSeries.includes(d.series.id)
                        ? null
                        : (inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.opacity) || null;
                });
                labelSelection.attr('opacity', (d) => {
                    return hoveredSeries.includes(d.series.id)
                        ? null
                        : (inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.opacity) || null;
                });
            }
        });
        return () => {
            dispatcher.on('hover-shape.waterfall', null);
        };
    }, [dispatcher, preparedData, seriesOptions]);
    return React.createElement("g", { ref: ref, className: b() });
};
