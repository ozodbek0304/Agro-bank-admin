import React from 'react';
import { arc, color, line as lineGenerator, select } from 'd3';
import get from 'lodash/get';
import { block } from '../../../../../../utils/cn';
import { setEllipsisForOverflowTexts } from '../../../utils';
import { setActiveState } from '../utils';
import { getCurveFactory } from './utils';
const b = block('d3-pie');
export function getHaloVisibility(d) {
    const enabled = d.data.pie.halo.enabled && d.data.hovered;
    return enabled ? '' : 'hidden';
}
export function PieSeriesShapes(args) {
    const { dispatcher, preparedData, seriesOptions } = args;
    const ref = React.useRef(null);
    React.useEffect(() => {
        if (!ref.current) {
            return () => { };
        }
        const svgElement = select(ref.current);
        svgElement.selectAll('*').remove();
        const segmentSelector = `.${b('segment')}`;
        const connectorSelector = `.${b('connector')}`;
        const shapesSelection = svgElement
            .selectAll('pie')
            .data(preparedData)
            .join('g')
            .attr('id', (pieData) => pieData.id)
            .attr('class', b('item'))
            .attr('transform', (pieData) => {
            const [x, y] = pieData.center;
            return `translate(${x}, ${y})`;
        })
            .style('stroke', (pieData) => pieData.borderColor)
            .style('stroke-width', (pieData) => pieData.borderWidth)
            .attr('cursor', (pieData) => pieData.series.cursor);
        // Render halo appearing outside the hovered slice
        shapesSelection
            .selectAll('halo')
            .data((pieData) => {
            if (pieData.halo.enabled) {
                return pieData.segments;
            }
            return [];
        })
            .join('path')
            .attr('d', (d) => {
            const arcGenerator = arc()
                .innerRadius(d.data.pie.innerRadius)
                .outerRadius(d.data.pie.radius + d.data.pie.halo.size)
                .cornerRadius(d.data.pie.borderRadius);
            return arcGenerator(d);
        })
            .attr('class', b('halo'))
            .attr('fill', (d) => d.data.color)
            .attr('opacity', (d) => d.data.pie.halo.opacity)
            .attr('z-index', -1)
            .attr('visibility', getHaloVisibility);
        // Render segments
        shapesSelection
            .selectAll(segmentSelector)
            .data((pieData) => pieData.segments)
            .join('path')
            .attr('d', (d) => {
            const arcGenerator = arc()
                .innerRadius(d.data.pie.innerRadius)
                .outerRadius(d.data.pie.radius)
                .cornerRadius(d.data.pie.borderRadius);
            return arcGenerator(d);
        })
            .attr('class', b('segment'))
            .attr('fill', (d) => d.data.color)
            .attr('opacity', (d) => d.data.opacity);
        shapesSelection
            .selectAll('text')
            .data((pieData) => pieData.labels)
            .join('text')
            .text((d) => d.text)
            .attr('class', b('label'))
            .attr('x', (d) => d.x)
            .attr('y', (d) => d.y)
            .attr('text-anchor', (d) => d.textAnchor)
            .style('font-size', (d) => d.style.fontSize)
            .style('font-weight', (d) => d.style.fontWeight || null)
            .style('fill', (d) => d.style.fontColor || null)
            .call(setEllipsisForOverflowTexts, (d) => d.size.width > d.maxWidth ? d.maxWidth : Infinity);
        // Add the polyline between chart and labels
        shapesSelection
            .selectAll(connectorSelector)
            .data((pieData) => pieData.labels)
            .enter()
            .append('path')
            .attr('class', b('connector'))
            .attr('d', (d) => {
            let line = lineGenerator();
            const curveFactory = getCurveFactory(d.segment.pie);
            if (curveFactory) {
                line = line.curve(curveFactory);
            }
            return line(d.connector.points);
        })
            .attr('stroke', (d) => d.connector.color)
            .attr('stroke-width', 1)
            .attr('stroke-linejoin', 'round')
            .attr('stroke-linecap', 'round')
            .style('fill', 'none');
        // Render custom shapes if defined
        shapesSelection.each(function (d, index, nodes) {
            var _a, _b;
            const customShape = (_b = (_a = d.series).renderCustomShape) === null || _b === void 0 ? void 0 : _b.call(_a, {
                series: {
                    innerRadius: d.innerRadius,
                },
            });
            if (customShape) {
                nodes[index].append(customShape);
            }
        });
        const getSelectedSegment = (element) => {
            const datum = select(element).datum();
            const seriesId = get(datum, 'data.series.id', get(datum, 'series.id'));
            return preparedData.reduce((result, pie) => {
                var _a;
                return result || ((_a = pie.segments.find((s) => s.data.series.id === seriesId)) === null || _a === void 0 ? void 0 : _a.data);
            }, undefined);
        };
        const eventName = `hover-shape.pie`;
        const hoverOptions = get(seriesOptions, 'pie.states.hover');
        const inactiveOptions = get(seriesOptions, 'pie.states.inactive');
        svgElement.on('click', (e) => {
            const selectedSegment = getSelectedSegment(e.target);
            if (selectedSegment) {
                dispatcher.call('click-chart', undefined, { point: selectedSegment.series.data, series: selectedSegment.series }, e);
            }
        });
        dispatcher.on(eventName, (data) => {
            var _a, _b;
            const selectedSeriesId = (_b = (_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.id;
            const hoverEnabled = hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.enabled;
            const inactiveEnabled = inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.enabled;
            shapesSelection.datum((_d, index, list) => {
                const pieSelection = select(list[index]);
                const haloSelection = pieSelection.selectAll(`.${b('halo')}`);
                pieSelection
                    .selectAll(segmentSelector)
                    .datum((d, i, elements) => {
                    const hovered = Boolean(hoverEnabled && d.data.series.id === selectedSeriesId);
                    if (d.data.hovered !== hovered) {
                        d.data.hovered = hovered;
                        select(elements[i]).attr('fill', () => {
                            var _a;
                            const initialColor = d.data.color;
                            if (d.data.hovered) {
                                return (((_a = color(initialColor)) === null || _a === void 0 ? void 0 : _a.brighter(hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.brightness).toString()) || initialColor);
                            }
                            return initialColor;
                        });
                        const currentSegmentHalo = haloSelection.nodes()[i];
                        select(currentSegmentHalo).attr('visibility', getHaloVisibility);
                    }
                    setActiveState({
                        element: elements[i],
                        state: inactiveOptions,
                        active: Boolean(!inactiveEnabled ||
                            !selectedSeriesId ||
                            selectedSeriesId === d.data.series.id),
                        datum: d.data,
                    });
                    return d;
                });
                const labelSelection = pieSelection.selectAll('tspan');
                const connectorSelection = pieSelection.selectAll(connectorSelector);
                labelSelection.merge(connectorSelection).datum((d, i, elements) => {
                    return setActiveState({
                        element: elements[i],
                        state: inactiveOptions,
                        active: Boolean(!inactiveEnabled ||
                            !selectedSeriesId ||
                            selectedSeriesId === d.series.id),
                        datum: d,
                    });
                });
            });
        });
        return () => {
            dispatcher.on(eventName, null);
        };
    }, [dispatcher, preparedData, seriesOptions]);
    return React.createElement("g", { ref: ref, className: b(), style: { zIndex: 9 } });
}
