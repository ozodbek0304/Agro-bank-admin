import React from 'react';
import { color, select } from 'd3';
import get from 'lodash/get';
import { block } from '../../../../../../utils/cn';
import { setEllipsisForOverflowTexts } from '../../../utils';
const b = block('d3-treemap');
export const TreemapSeriesShape = (props) => {
    const { dispatcher, preparedData, seriesOptions } = props;
    const ref = React.useRef(null);
    React.useEffect(() => {
        if (!ref.current) {
            return () => { };
        }
        const svgElement = select(ref.current);
        svgElement.selectAll('*').remove();
        const { labelData, leaves, series } = preparedData;
        const leaf = svgElement
            .selectAll('g')
            .data(leaves)
            .join('g')
            .attr('transform', (d) => `translate(${d.x0},${d.y0})`)
            .attr('cursor', series.cursor);
        const rectSelection = leaf
            .append('rect')
            .attr('id', (d) => d.id || d.name)
            .attr('fill', (d) => {
            var _a;
            if (d.data.color) {
                return d.data.color;
            }
            const levelOptions = (_a = series.levels) === null || _a === void 0 ? void 0 : _a.find((l) => l.index === d.depth);
            return (levelOptions === null || levelOptions === void 0 ? void 0 : levelOptions.color) || series.color;
        })
            .attr('width', (d) => d.x1 - d.x0)
            .attr('height', (d) => d.y1 - d.y0);
        const labelSelection = svgElement
            .selectAll('tspan')
            .data(labelData)
            .join('text')
            .text((d) => d.text)
            .attr('class', b('label'))
            .attr('x', (d) => d.x)
            .attr('y', (d) => d.y)
            .style('font-size', () => series.dataLabels.style.fontSize)
            .style('font-weight', () => { var _a; return ((_a = series.dataLabels.style) === null || _a === void 0 ? void 0 : _a.fontWeight) || null; })
            .style('fill', () => { var _a; return ((_a = series.dataLabels.style) === null || _a === void 0 ? void 0 : _a.fontColor) || null; })
            .call(setEllipsisForOverflowTexts, (d) => d.width);
        const getSelectedPart = (node) => {
            const hoveredRect = select(node);
            return hoveredRect.datum();
        };
        const eventName = `hover-shape.treemap`;
        const hoverOptions = get(seriesOptions, 'treemap.states.hover');
        const inactiveOptions = get(seriesOptions, 'treemap.states.inactive');
        svgElement.on('click', (e) => {
            const datum = getSelectedPart(e.target);
            dispatcher.call('click-chart', undefined, { point: datum.data, series }, e);
        });
        dispatcher.on(eventName, (data) => {
            var _a;
            const hoverEnabled = hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.enabled;
            const inactiveEnabled = inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.enabled;
            const hoveredData = (_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a.data;
            rectSelection.datum((d, index, list) => {
                const currentRect = select(list[index]);
                const hovered = Boolean(hoverEnabled && hoveredData === d.data);
                const inactive = Boolean(inactiveEnabled && hoveredData && !hovered);
                currentRect
                    .attr('fill', (currentD) => {
                    var _a, _b;
                    const levelOptions = (_a = series.levels) === null || _a === void 0 ? void 0 : _a.find((l) => l.index === currentD.depth);
                    const initialColor = (levelOptions === null || levelOptions === void 0 ? void 0 : levelOptions.color) || d.data.color || series.color;
                    if (hovered) {
                        return (((_b = color(initialColor)) === null || _b === void 0 ? void 0 : _b.brighter(hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.brightness).toString()) || initialColor);
                    }
                    return initialColor;
                })
                    .attr('opacity', () => {
                    if (inactive) {
                        return (inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.opacity) || null;
                    }
                    return null;
                });
                return d;
            });
            labelSelection.datum((d, index, list) => {
                const currentLabel = select(list[index]);
                const hovered = Boolean(hoverEnabled && hoveredData === d.nodeData);
                const inactive = Boolean(inactiveEnabled && hoveredData && !hovered);
                currentLabel.attr('opacity', () => {
                    if (inactive) {
                        return (inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.opacity) || null;
                    }
                    return null;
                });
                return d;
            });
        });
        return () => {
            dispatcher.on(eventName, null);
        };
    }, [dispatcher, preparedData, seriesOptions]);
    return React.createElement("g", { ref: ref, className: b() });
};
