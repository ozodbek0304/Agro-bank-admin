import React from 'react';
import { group } from 'd3';
import { getOnlyVisibleSeries } from '../../utils';
import { AreaSeriesShapes } from './area';
import { prepareAreaData } from './area/prepare-data';
import { BarXSeriesShapes, prepareBarXData } from './bar-x';
import { BarYSeriesShapes, prepareBarYData } from './bar-y';
import { LineSeriesShapes } from './line';
import { prepareLineData } from './line/prepare-data';
import { PieSeriesShapes } from './pie';
import { preparePieData } from './pie/prepare-data';
import { ScatterSeriesShape, prepareScatterData } from './scatter';
import { TreemapSeriesShape } from './treemap';
import { prepareTreemapData } from './treemap/prepare-data';
import { WaterfallSeriesShapes, prepareWaterfallData } from './waterfall';
import './styles.css';
export const useShapes = (args) => {
    const { boundsWidth, boundsHeight, dispatcher, series, seriesOptions, xAxis, xScale, yAxis, yScale, split, } = args;
    const shapesComponents = React.useMemo(() => {
        const visibleSeries = getOnlyVisibleSeries(series);
        const groupedSeries = group(visibleSeries, (item) => item.type);
        const shapesData = [];
        const shapes = Array.from(groupedSeries).reduce((acc, item) => {
            const [seriesType, chartSeries] = item;
            switch (seriesType) {
                case 'bar-x': {
                    if (xScale && yScale) {
                        const preparedData = prepareBarXData({
                            series: chartSeries,
                            seriesOptions,
                            xAxis,
                            xScale,
                            yAxis,
                            yScale,
                            boundsHeight,
                        });
                        acc.push(React.createElement(BarXSeriesShapes, { key: "bar-x", dispatcher: dispatcher, seriesOptions: seriesOptions, preparedData: preparedData }));
                        shapesData.push(...preparedData);
                    }
                    break;
                }
                case 'bar-y': {
                    if (xScale && yScale) {
                        const preparedData = prepareBarYData({
                            series: chartSeries,
                            seriesOptions,
                            xAxis,
                            xScale,
                            yAxis,
                            yScale,
                        });
                        acc.push(React.createElement(BarYSeriesShapes, { key: "bar-y", dispatcher: dispatcher, seriesOptions: seriesOptions, preparedData: preparedData }));
                        shapesData.push(...preparedData);
                    }
                    break;
                }
                case 'waterfall': {
                    if (xScale && yScale) {
                        const preparedData = prepareWaterfallData({
                            series: chartSeries,
                            seriesOptions,
                            xAxis,
                            xScale,
                            yAxis,
                            yScale,
                        });
                        acc.push(React.createElement(WaterfallSeriesShapes, { key: "waterfall", dispatcher: dispatcher, seriesOptions: seriesOptions, preparedData: preparedData }));
                        shapesData.push(...preparedData);
                    }
                    break;
                }
                case 'line': {
                    if (xScale && yScale) {
                        const preparedData = prepareLineData({
                            series: chartSeries,
                            xAxis,
                            xScale,
                            yAxis,
                            yScale,
                            split,
                        });
                        acc.push(React.createElement(LineSeriesShapes, { key: "line", dispatcher: dispatcher, seriesOptions: seriesOptions, preparedData: preparedData }));
                        shapesData.push(...preparedData);
                    }
                    break;
                }
                case 'area': {
                    if (xScale && yScale) {
                        const preparedData = prepareAreaData({
                            series: chartSeries,
                            xAxis,
                            xScale,
                            yAxis,
                            yScale,
                            boundsHeight,
                        });
                        acc.push(React.createElement(AreaSeriesShapes, { key: "area", dispatcher: dispatcher, seriesOptions: seriesOptions, preparedData: preparedData }));
                        shapesData.push(...preparedData);
                    }
                    break;
                }
                case 'scatter': {
                    if (xScale && yScale) {
                        const preparedData = prepareScatterData({
                            series: chartSeries,
                            xAxis,
                            xScale,
                            yAxis,
                            yScale,
                        });
                        acc.push(React.createElement(ScatterSeriesShape, { key: "scatter", dispatcher: dispatcher, preparedData: preparedData, seriesOptions: seriesOptions }));
                        shapesData.push(...preparedData);
                    }
                    break;
                }
                case 'pie': {
                    const preparedData = preparePieData({
                        series: chartSeries,
                        boundsWidth,
                        boundsHeight,
                    });
                    acc.push(React.createElement(PieSeriesShapes, { key: "pie", dispatcher: dispatcher, preparedData: preparedData, seriesOptions: seriesOptions }));
                    shapesData.push(...preparedData);
                    break;
                }
                case 'treemap': {
                    const preparedData = prepareTreemapData({
                        // We should have exactly one series with "treemap" type
                        // Otherwise data validation should emit an error
                        series: chartSeries[0],
                        width: boundsWidth,
                        height: boundsHeight,
                    });
                    acc.push(React.createElement(TreemapSeriesShape, { key: "treemap", dispatcher: dispatcher, preparedData: preparedData, seriesOptions: seriesOptions }));
                    shapesData.push(preparedData);
                }
            }
            return acc;
        }, []);
        return { shapes, shapesData };
    }, [
        boundsWidth,
        boundsHeight,
        dispatcher,
        series,
        seriesOptions,
        xAxis,
        xScale,
        yAxis,
        yScale,
    ]);
    return { shapes: shapesComponents.shapes, shapesData: shapesComponents.shapesData };
};
