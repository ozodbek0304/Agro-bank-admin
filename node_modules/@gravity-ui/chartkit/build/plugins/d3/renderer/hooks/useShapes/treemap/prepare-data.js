import { stratify, treemap, treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, } from 'd3';
import { LayoutAlgorithm } from '../../../../../../constants';
const DEFAULT_PADDING = 1;
function getLabelData(data) {
    return data.map((d) => {
        const text = d.data.name;
        return {
            text,
            x: d.x0,
            y: d.y0,
            width: d.x1 - d.x0,
            nodeData: d.data,
        };
    });
}
export function prepareTreemapData(args) {
    var _a;
    const { series, width, height } = args;
    const dataWithRootNode = getSeriesDataWithRootNode(series);
    const hierarchy = stratify()
        .id((d) => d.id || d.name)
        .parentId((d) => d.parentId)(dataWithRootNode)
        .sum((d) => d.value || 0);
    const treemapInstance = treemap();
    switch (series.layoutAlgorithm) {
        case LayoutAlgorithm.Binary: {
            treemapInstance.tile(treemapBinary);
            break;
        }
        case LayoutAlgorithm.Dice: {
            treemapInstance.tile(treemapDice);
            break;
        }
        case LayoutAlgorithm.Slice: {
            treemapInstance.tile(treemapSlice);
            break;
        }
        case LayoutAlgorithm.SliceDice: {
            treemapInstance.tile(treemapSliceDice);
            break;
        }
        case LayoutAlgorithm.Squarify: {
            treemapInstance.tile(treemapSquarify);
            break;
        }
    }
    const root = treemapInstance.size([width, height]).paddingInner((d) => {
        var _a, _b;
        const levelOptions = (_a = series.levels) === null || _a === void 0 ? void 0 : _a.find((l) => l.index === d.depth + 1);
        return (_b = levelOptions === null || levelOptions === void 0 ? void 0 : levelOptions.padding) !== null && _b !== void 0 ? _b : DEFAULT_PADDING;
    })(hierarchy);
    const leaves = root.leaves();
    const labelData = ((_a = series.dataLabels) === null || _a === void 0 ? void 0 : _a.enabled) ? getLabelData(leaves) : [];
    return { labelData, leaves, series };
}
function getSeriesDataWithRootNode(series) {
    return series.data.reduce((acc, d) => {
        const dataChunk = Object.assign({}, d);
        if (!dataChunk.parentId) {
            dataChunk.parentId = series.id;
        }
        acc.push(dataChunk);
        return acc;
    }, [{ name: series.name, id: series.id }]);
}
