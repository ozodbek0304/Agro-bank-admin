import React from 'react';
import { color, line as lineGenerator, select } from 'd3';
import get from 'lodash/get';
import { block } from '../../../../../../utils/cn';
import { filterOverlappingLabels } from '../../../utils';
import { getMarkerHaloVisibility, getMarkerVisibility, renderMarker, selectMarkerHalo, selectMarkerSymbol, setMarker, } from '../marker';
import { getLineDashArray, setActiveState } from '../utils';
const b = block('d3-line');
export const LineSeriesShapes = (args) => {
    const { dispatcher, preparedData, seriesOptions } = args;
    const ref = React.useRef(null);
    React.useEffect(() => {
        var _a;
        if (!ref.current) {
            return () => { };
        }
        const svgElement = select(ref.current);
        const hoverOptions = get(seriesOptions, 'line.states.hover');
        const inactiveOptions = get(seriesOptions, 'line.states.inactive');
        const line = lineGenerator()
            .x((d) => d.x)
            .y((d) => d.y);
        svgElement.selectAll('*').remove();
        const lineSelection = svgElement
            .selectAll('path')
            .data(preparedData)
            .join('path')
            .attr('d', (d) => line(d.points))
            .attr('fill', 'none')
            .attr('stroke', (d) => d.color)
            .attr('stroke-width', (d) => d.width)
            .attr('stroke-linejoin', (d) => d.linecap)
            .attr('stroke-linecap', (d) => d.linecap)
            .attr('stroke-dasharray', (d) => getLineDashArray(d.dashStyle, d.width))
            .attr('opacity', (d) => d.opacity)
            .attr('cursor', (d) => d.series.cursor);
        let dataLabels = preparedData.reduce((acc, d) => {
            return acc.concat(d.labels);
        }, []);
        if (!((_a = preparedData[0]) === null || _a === void 0 ? void 0 : _a.series.dataLabels.allowOverlap)) {
            dataLabels = filterOverlappingLabels(dataLabels);
        }
        const labelsSelection = svgElement
            .selectAll('text')
            .data(dataLabels)
            .join('text')
            .text((d) => d.text)
            .attr('class', b('label'))
            .attr('x', (d) => d.x)
            .attr('y', (d) => d.y)
            .attr('text-anchor', (d) => d.textAnchor)
            .style('font-size', (d) => d.style.fontSize)
            .style('font-weight', (d) => d.style.fontWeight || null)
            .style('fill', (d) => d.style.fontColor || null);
        const markers = preparedData.reduce((acc, d) => acc.concat(d.markers), []);
        const markerSelection = svgElement
            .selectAll('marker')
            .data(markers)
            .join('g')
            .call(renderMarker);
        const hoverEnabled = hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.enabled;
        const inactiveEnabled = inactiveOptions === null || inactiveOptions === void 0 ? void 0 : inactiveOptions.enabled;
        dispatcher.on('hover-shape.line', (data) => {
            const selected = (data === null || data === void 0 ? void 0 : data.filter((d) => d.series.type === 'line')) || [];
            const selectedDataItems = selected.map((d) => d.data);
            const selectedSeriesIds = selected.map((d) => { var _a; return (_a = d.series) === null || _a === void 0 ? void 0 : _a.id; });
            lineSelection.datum((d, index, list) => {
                const elementSelection = select(list[index]);
                const hovered = Boolean(hoverEnabled && selectedSeriesIds.includes(d.id));
                if (d.hovered !== hovered) {
                    d.hovered = hovered;
                    elementSelection.attr('stroke', (d) => {
                        var _a;
                        const initialColor = d.color || '';
                        if (d.hovered) {
                            return (((_a = color(initialColor)) === null || _a === void 0 ? void 0 : _a.brighter(hoverOptions === null || hoverOptions === void 0 ? void 0 : hoverOptions.brightness).toString()) || initialColor);
                        }
                        return initialColor;
                    });
                }
                return setActiveState({
                    element: list[index],
                    state: inactiveOptions,
                    active: Boolean(!inactiveEnabled ||
                        !selectedSeriesIds.length ||
                        selectedSeriesIds.includes(d.id)),
                    datum: d,
                });
            });
            labelsSelection.datum((d, index, list) => {
                return setActiveState({
                    element: list[index],
                    state: inactiveOptions,
                    active: Boolean(!inactiveEnabled ||
                        !selectedSeriesIds.length ||
                        selectedSeriesIds.includes(d.series.id)),
                    datum: d,
                });
            });
            markerSelection.datum((d, index, list) => {
                const elementSelection = select(list[index]);
                const hovered = Boolean(hoverEnabled && selectedDataItems.includes(d.point.data));
                if (d.hovered !== hovered) {
                    d.hovered = hovered;
                    elementSelection.attr('visibility', getMarkerVisibility(d));
                    selectMarkerHalo(elementSelection).attr('visibility', getMarkerHaloVisibility);
                    selectMarkerSymbol(elementSelection).call(setMarker, hovered ? 'hover' : 'normal');
                }
                if (d.point.series.marker.states.normal.enabled) {
                    const isActive = Boolean(!inactiveEnabled ||
                        !selectedSeriesIds.length ||
                        selectedSeriesIds.includes(d.point.series.id));
                    setActiveState({
                        element: list[index],
                        state: inactiveOptions,
                        active: isActive,
                        datum: d,
                    });
                }
                return d;
            });
        });
        return () => {
            dispatcher.on('hover-shape.line', null);
        };
    }, [dispatcher, preparedData, seriesOptions]);
    return React.createElement("g", { ref: ref, className: b() });
};
