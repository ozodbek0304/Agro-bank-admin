import { select } from 'd3';
import clone from 'lodash/clone';
import get from 'lodash/get';
import merge from 'lodash/merge';
import { legendDefaults } from '../../constants';
import { getHorisontalSvgTextHeight } from '../../utils';
import { getBoundsWidth } from '../useChartDimensions';
import { getYAxisWidth } from '../useChartDimensions/utils';
export const getPreparedLegend = (args) => {
    const { legend, series } = args;
    const enabled = Boolean(typeof (legend === null || legend === void 0 ? void 0 : legend.enabled) === 'boolean' ? legend === null || legend === void 0 ? void 0 : legend.enabled : series.length > 1);
    const defaultItemStyle = clone(legendDefaults.itemStyle);
    const itemStyle = get(legend, 'itemStyle');
    const computedItemStyle = merge(defaultItemStyle, itemStyle);
    const lineHeight = getHorisontalSvgTextHeight({ text: 'Tmp', style: computedItemStyle });
    const height = enabled ? lineHeight : 0;
    return {
        align: get(legend, 'align', legendDefaults.align),
        enabled,
        height,
        itemDistance: get(legend, 'itemDistance', legendDefaults.itemDistance),
        itemStyle: computedItemStyle,
        lineHeight,
        margin: get(legend, 'margin', legendDefaults.margin),
    };
};
const getFlattenLegendItems = (series) => {
    return series.reduce((acc, s) => {
        const legendEnabled = get(s, 'legend.enabled', true);
        if (legendEnabled) {
            acc.push(Object.assign(Object.assign({}, s), { symbol: s.legend.symbol }));
        }
        return acc;
    }, []);
};
const getGroupedLegendItems = (args) => {
    const { maxLegendWidth, items, preparedLegend } = args;
    const result = [[]];
    let textWidthsInLine = [0];
    let lineIndex = 0;
    items.forEach((item) => {
        select(document.body)
            .append('text')
            .text(item.name)
            .style('font-size', preparedLegend.itemStyle.fontSize)
            .each(function () {
            const resultItem = clone(item);
            const textWidth = this.getBoundingClientRect().width;
            resultItem.textWidth = textWidth;
            textWidthsInLine.push(textWidth);
            const textsWidth = textWidthsInLine.reduce((acc, width) => acc + width, 0);
            result[lineIndex].push(resultItem);
            const symbolsWidth = result[lineIndex].reduce((acc, { symbol }) => {
                return acc + symbol.width + symbol.padding;
            }, 0);
            const distancesWidth = (result[lineIndex].length - 1) * preparedLegend.itemDistance;
            const isOverfilled = maxLegendWidth < textsWidth + symbolsWidth + distancesWidth;
            if (isOverfilled) {
                result[lineIndex].pop();
                lineIndex += 1;
                textWidthsInLine = [textWidth];
                const nextLineIndex = lineIndex;
                result[nextLineIndex] = [];
                result[nextLineIndex].push(resultItem);
            }
        })
            .remove();
    });
    return result;
};
export const getLegendComponents = (args) => {
    const { chartWidth, chartHeight, chartMargin, series, preparedLegend, preparedYAxis } = args;
    const maxLegendWidth = getBoundsWidth({ chartWidth, chartMargin, preparedYAxis });
    const maxLegendHeight = (chartHeight - chartMargin.top - chartMargin.bottom - preparedLegend.margin) / 2;
    const flattenLegendItems = getFlattenLegendItems(series);
    const items = getGroupedLegendItems({
        maxLegendWidth,
        items: flattenLegendItems,
        preparedLegend,
    });
    let legendHeight = preparedLegend.lineHeight * items.length;
    let pagination;
    if (maxLegendHeight < legendHeight) {
        // extra line for paginator
        const limit = Math.floor(maxLegendHeight / preparedLegend.lineHeight) - 1;
        const maxPage = Math.ceil(items.length / limit);
        pagination = { limit, maxPage };
        legendHeight = maxLegendHeight;
    }
    preparedLegend.height = legendHeight;
    const top = chartHeight - chartMargin.bottom - preparedLegend.height;
    const offset = {
        left: chartMargin.left + getYAxisWidth(preparedYAxis[0]),
        top,
    };
    return { legendConfig: { offset, pagination }, legendItems: items };
};
