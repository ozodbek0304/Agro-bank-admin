import { select } from 'd3-selection';
export function handleOverflowingText(tSpan, maxWidth) {
    var _a, _b, _c;
    if (!tSpan) {
        return;
    }
    const svg = tSpan.closest('svg');
    if (!svg) {
        return;
    }
    const textNode = tSpan.closest('text');
    const angle = ((_a = Array.from((textNode === null || textNode === void 0 ? void 0 : textNode.transform.baseVal) || []).find((item) => item.angle)) === null || _a === void 0 ? void 0 : _a.angle) || 0;
    const revertRotation = svg.createSVGTransform();
    revertRotation.setRotate(-angle, 0, 0);
    textNode === null || textNode === void 0 ? void 0 : textNode.transform.baseVal.appendItem(revertRotation);
    let text = tSpan.textContent || '';
    let textLength = ((_b = tSpan.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.width) || 0;
    while (textLength > maxWidth && text.length > 1) {
        text = text.slice(0, -1);
        tSpan.textContent = text + 'â€¦';
        textLength = ((_c = tSpan.getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c.width) || 0;
    }
    textNode === null || textNode === void 0 ? void 0 : textNode.transform.baseVal.removeItem((textNode === null || textNode === void 0 ? void 0 : textNode.transform.baseVal.length) - 1);
}
export function setEllipsisForOverflowText(selection, maxWidth) {
    const text = selection.text();
    selection.text(null).append('title').text(text);
    const tSpan = selection.append('tspan').text(text).style('alignment-baseline', 'inherit');
    handleOverflowingText(tSpan.node(), maxWidth);
}
export function setEllipsisForOverflowTexts(selection, maxWidth) {
    selection.each(function (datum) {
        const textMaxWidth = typeof maxWidth === 'function' ? maxWidth(datum) : maxWidth;
        setEllipsisForOverflowText(select(this), textMaxWidth);
    });
}
export function hasOverlappingLabels({ width, labels, padding = 0, style, }) {
    const maxWidth = (width - padding * (labels.length - 1)) / labels.length;
    const textElement = select(document.body)
        .append('text')
        .style('font-size', (style === null || style === void 0 ? void 0 : style.fontSize) || '');
    const result = labels.some((label) => {
        var _a, _b;
        const textWidth = ((_b = (_a = textElement.text(label).node()) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.width) || 0;
        return textWidth > maxWidth;
    });
    textElement.remove();
    return result;
}
function renderLabels(selection, { labels, style = {}, attrs = {}, }) {
    const text = selection.append('g').append('text');
    text.style('font-size', style.fontSize || '');
    text.style('font-weight', style.fontWeight || '');
    Object.entries(attrs).forEach(([name, value]) => {
        text.attr(name, value);
    });
    text.selectAll('tspan')
        .data(labels)
        .enter()
        .append('tspan')
        .attr('x', 0)
        .attr('dy', 0)
        .text((d) => d);
    return text;
}
export function getLabelsSize({ labels, style, rotation, }) {
    var _a;
    if (!labels.filter(Boolean).length) {
        return { maxHeight: 0, maxWidth: 0 };
    }
    const container = select(document.body)
        .append('div')
        .attr('class', 'chartkit chartkit-theme_common');
    const svg = container.append('svg');
    const textSelection = renderLabels(svg, { labels, style });
    if (rotation) {
        textSelection
            .attr('text-anchor', rotation > 0 ? 'start' : 'end')
            .style('transform', `rotate(${rotation}deg)`);
    }
    const { height = 0, width = 0 } = ((_a = svg.select('g').node()) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {};
    container.remove();
    return { maxHeight: height, maxWidth: width };
}
export function wrapText(args) {
    const { text, style, width } = args;
    const height = getLabelsSize({
        labels: [text],
        style: style,
    }).maxHeight;
    // @ts-ignore
    const segmenter = new Intl.Segmenter([], { granularity: 'word' });
    const segments = Array.from(segmenter.segment(text));
    return segments.reduce((acc, s) => {
        const item = s;
        if (!acc.length) {
            acc.push({
                text: '',
                y: acc.length * height,
            });
        }
        let lastRow = acc[acc.length - 1];
        if (item.isWordLike &&
            getLabelsSize({
                labels: [lastRow.text + item.segment],
                style,
            }).maxWidth > width) {
            lastRow = {
                text: '',
                y: acc.length * height,
            };
            acc.push(lastRow);
        }
        lastRow.text += item.segment;
        return acc;
    }, []);
}
