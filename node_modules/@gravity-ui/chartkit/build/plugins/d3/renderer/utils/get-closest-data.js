import { Delaunay, bisector, sort } from 'd3';
import get from 'lodash/get';
import groupBy from 'lodash/groupBy';
function getClosestPointsByXValue(x, y, points) {
    var _a, _b;
    const sorted = sort(points, (p) => p.x);
    const closestXIndex = bisector((p) => p.x).center(sorted, x);
    if (closestXIndex === -1) {
        return [];
    }
    const closestX = sorted[closestXIndex].x;
    const closestPoints = sort(points.filter((p) => p.x === closestX), (p) => p.y0);
    let closestYIndex = -1;
    if (y < ((_a = closestPoints[0]) === null || _a === void 0 ? void 0 : _a.y0)) {
        closestYIndex = 0;
    }
    else if (y > ((_b = closestPoints[closestPoints.length - 1]) === null || _b === void 0 ? void 0 : _b.y1)) {
        closestYIndex = closestPoints.length - 1;
    }
    else {
        closestYIndex = closestPoints.findIndex((p) => y > p.y0 && y < p.y1);
    }
    return closestPoints.map((p, i) => ({
        data: p.data,
        series: p.series,
        closest: i === closestYIndex,
    }));
}
function getSeriesType(shapeData) {
    return get(shapeData, 'series.type') || get(shapeData, 'point.series.type');
}
export function getClosestPoints(args) {
    const { position, shapesData } = args;
    const [pointerX, pointerY] = position;
    const result = [];
    const groups = groupBy(shapesData, getSeriesType);
    Object.entries(groups).forEach(([seriesType, list]) => {
        var _a, _b;
        switch (seriesType) {
            case 'bar-x': {
                const points = list.map((d) => ({
                    data: d.data,
                    series: d.series,
                    x: d.x + d.width / 2,
                    y0: d.y,
                    y1: d.y + d.height,
                }));
                result.push(...getClosestPointsByXValue(pointerX, pointerY, points));
                break;
            }
            case 'waterfall': {
                const points = list.map((d) => ({
                    data: d.data,
                    series: d.series,
                    x: d.x + d.width / 2,
                    y0: d.y,
                    y1: d.y + d.height,
                }));
                result.push(...getClosestPointsByXValue(pointerX, pointerY, points));
                break;
            }
            case 'area': {
                const points = list.reduce((acc, d) => {
                    Array.prototype.push.apply(acc, d.points.map((p) => ({
                        data: p.data,
                        series: p.series,
                        x: p.x,
                        y0: p.y0,
                        y1: p.y,
                    })));
                    return acc;
                }, []);
                result.push(...getClosestPointsByXValue(pointerX, pointerY, points));
                break;
            }
            case 'line': {
                const points = list.reduce((acc, d) => {
                    acc.push(...d.points.map((p) => ({
                        data: p.data,
                        series: p.series,
                        x: p.x,
                        y0: p.y,
                        y1: p.y,
                    })));
                    return acc;
                }, []);
                result.push(...getClosestPointsByXValue(pointerX, pointerY, points));
                break;
            }
            case 'bar-y': {
                const points = list;
                const sorted = sort(points, (p) => p.y);
                const closestYIndex = bisector((p) => p.y).center(sorted, pointerY);
                let closestPoints = [];
                let closestXIndex = -1;
                if (closestYIndex !== -1) {
                    const closestY = sorted[closestYIndex].y;
                    closestPoints = sort(points.filter((p) => p.y === closestY), (p) => p.x);
                    const lastPoint = closestPoints[closestPoints.length - 1];
                    if (pointerX < ((_a = closestPoints[0]) === null || _a === void 0 ? void 0 : _a.x)) {
                        closestXIndex = 0;
                    }
                    else if (lastPoint && pointerX > lastPoint.x + lastPoint.width) {
                        closestXIndex = closestPoints.length - 1;
                    }
                    else {
                        closestXIndex = closestPoints.findIndex((p) => pointerX > p.x && pointerX < p.x + p.width);
                    }
                }
                result.push(...closestPoints.map((p, i) => ({
                    data: p.data,
                    series: p.series,
                    closest: i === closestXIndex,
                })));
                break;
            }
            case 'scatter': {
                const points = list;
                const delaunayX = Delaunay.from(points, (d) => d.point.x, (d) => d.point.y);
                const closestPoint = points[delaunayX.find(pointerX, pointerY)];
                if (closestPoint) {
                    result.push({
                        data: closestPoint.point.data,
                        series: closestPoint.point.series,
                        closest: true,
                    });
                }
                break;
            }
            case 'pie': {
                const points = list.map((d) => d.segments).flat();
                const closestPoint = points.find((p) => {
                    const { center, radius } = p.data.pie;
                    const x = pointerX - center[0];
                    const y = pointerY - center[1];
                    let angle = Math.atan2(y, x) + 0.5 * Math.PI;
                    angle = angle < 0 ? Math.PI * 2 + angle : angle;
                    const polarRadius = Math.sqrt(x * x + y * y);
                    return angle >= p.startAngle && angle <= p.endAngle && polarRadius < radius;
                });
                if (closestPoint) {
                    result.push({
                        data: closestPoint.data.series.data,
                        series: closestPoint.data.series,
                        closest: true,
                    });
                }
                break;
            }
            case 'treemap': {
                const data = list;
                const closestPoint = (_b = data[0]) === null || _b === void 0 ? void 0 : _b.leaves.find((l) => {
                    return (pointerX >= l.x0 && pointerX <= l.x1 && pointerY >= l.y0 && pointerY <= l.y1);
                });
                if (closestPoint) {
                    result.push({
                        data: closestPoint.data,
                        series: data[0].series,
                        closest: true,
                    });
                }
                break;
            }
        }
    });
    return result;
}
