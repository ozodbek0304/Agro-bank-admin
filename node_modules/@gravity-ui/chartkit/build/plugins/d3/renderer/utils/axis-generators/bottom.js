import { path, select } from 'd3';
import { getXAxisItems, getXAxisOffset, getXTickPosition } from '../axis';
import { calculateCos, calculateSin } from '../math';
import { getLabelsSize, setEllipsisForOverflowText } from '../text';
function addDomain(selection, options) {
    const { size, color } = options;
    const domainPath = selection
        .selectAll('.domain')
        .data([null])
        .enter()
        .insert('path', '.tick')
        .attr('class', 'domain')
        .attr('d', `M0,0V0H${size}`);
    if (color) {
        domainPath.style('stroke', color);
    }
}
export function axisBottom(args) {
    const { scale, ticks: { labelFormat, labelsPaddings = 0, labelsMargin = 0, labelsMaxWidth = Infinity, labelsStyle, labelsLineHeight, items: tickItems, count: ticksCount, maxTickCount, rotation, }, domain: { size: domainSize, color: domainColor }, } = args;
    const offset = getXAxisOffset();
    const position = getXTickPosition({ scale, offset });
    const values = getXAxisItems({ scale, count: ticksCount, maxCount: maxTickCount });
    const labelHeight = getLabelsSize({
        labels: values,
        style: labelsStyle,
    }).maxHeight;
    return function (selection) {
        var _a, _b;
        const x = ((_b = (_a = selection.node()) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.x) || 0;
        const right = x + domainSize;
        const top = -tickItems[0][0] || 0;
        let transform = `translate(0, ${labelHeight + labelsMargin - top}px)`;
        if (rotation) {
            const labelsOffsetTop = labelHeight * calculateCos(rotation) + labelsMargin - top;
            let labelsOffsetLeft = calculateSin(rotation) * labelHeight;
            if (Math.abs(rotation) % 360 === 90) {
                labelsOffsetLeft += ((rotation > 0 ? -1 : 1) * labelHeight) / 2;
            }
            transform = `translate(${-labelsOffsetLeft}px, ${labelsOffsetTop}px) rotate(${rotation}deg)`;
        }
        const tickPath = path();
        tickItems.forEach(([start, end]) => {
            tickPath.moveTo(0, start);
            tickPath.lineTo(0, end);
        });
        selection
            .selectAll('.tick')
            .data(values)
            .order()
            .join((el) => {
            const tick = el.append('g').attr('class', 'tick');
            tick.append('path').attr('d', tickPath.toString()).attr('stroke', 'currentColor');
            tick.append('text')
                .text(labelFormat)
                .attr('fill', 'currentColor')
                .attr('text-anchor', () => {
                if (rotation) {
                    return rotation > 0 ? 'start' : 'end';
                }
                return 'middle';
            })
                .style('transform', transform)
                .style('alignment-baseline', 'after-edge');
            return tick;
        })
            .attr('transform', function (d) {
            return `translate(${position(d) + offset}, ${top})`;
        });
        // Remove tick that has the same x coordinate like domain
        selection
            .select('.tick')
            .filter((d) => {
            return position(d) === 0;
        })
            .select('line')
            .remove();
        const labels = selection.selectAll('.tick text');
        // FIXME: handle rotated overlapping labels (with a smarter approach)
        if (rotation) {
            const maxWidth = labelsMaxWidth * calculateCos(rotation) + labelsLineHeight * calculateSin(rotation);
            labels.each(function () {
                setEllipsisForOverflowText(select(this), maxWidth);
            });
        }
        else {
            // remove overlapping labels
            let elementX = 0;
            selection
                .selectAll('.tick')
                .filter(function () {
                const node = this;
                const r = node.getBoundingClientRect();
                if (r.left < elementX) {
                    return true;
                }
                elementX = r.right + labelsPaddings;
                return false;
            })
                .remove();
            // add an ellipsis to the labels that go beyond the boundaries of the chart
            labels.each(function (_d, i, nodes) {
                if (i === nodes.length - 1) {
                    const currentElement = this;
                    const prevElement = nodes[i - 1];
                    const text = select(currentElement);
                    const currentElementPosition = currentElement.getBoundingClientRect();
                    const prevElementPosition = prevElement === null || prevElement === void 0 ? void 0 : prevElement.getBoundingClientRect();
                    const lackingSpace = Math.max(0, currentElementPosition.right - right);
                    if (lackingSpace) {
                        const remainSpace = right - ((prevElementPosition === null || prevElementPosition === void 0 ? void 0 : prevElementPosition.right) || 0) - labelsPaddings;
                        const translateX = currentElementPosition.width / 2 - lackingSpace;
                        text.attr('text-anchor', 'end').attr('transform', `translate(${translateX},0)`);
                        setEllipsisForOverflowText(text, remainSpace);
                    }
                }
            });
        }
        selection
            .call(addDomain, { size: domainSize, color: domainColor })
            .style('font-size', (labelsStyle === null || labelsStyle === void 0 ? void 0 : labelsStyle.fontSize) || '');
    };
}
