import { dateTime } from '@gravity-ui/date-utils';
import { defaults } from '@gravity-ui/yagr';
import merge from 'lodash/merge';
import { settings } from '../../../libs';
import { getRenderTooltip } from './tooltip';
const TOOLTIP_HEADER_CLASS_NAME = '_tooltip-header';
const TOOLTIP_LIST_CLASS_NAME = '_tooltip-list';
export const synchronizeTooltipTablesCellsWidth = (tooltipContainer) => {
    const tHeadNode = tooltipContainer.querySelector(`.${TOOLTIP_HEADER_CLASS_NAME}`);
    const tBodyNode = tooltipContainer.querySelector(`.${TOOLTIP_LIST_CLASS_NAME}`);
    if (!tHeadNode || !tBodyNode || !tHeadNode.children.length) {
        return;
    }
    const tHeadNodeFirstRow = tHeadNode.children[0];
    for (let j = 0; j < tHeadNodeFirstRow.children.length; j++) {
        const cell = tHeadNodeFirstRow.children[j];
        cell.removeAttribute('style');
        if ((tBodyNode === null || tBodyNode === void 0 ? void 0 : tBodyNode.children.length) === 1) {
            cell.innerHTML = '&nbsp;';
        }
    }
    const tBodyNodeFirstRow = tBodyNode.children[0];
    for (let j = 0; j < tBodyNodeFirstRow.children.length; j++) {
        const cell = tBodyNodeFirstRow.children[j];
        cell.removeAttribute('style');
    }
    const tHeadRowsWidth = tHeadNode.children[0].getBoundingClientRect().width;
    const tBodyRowsWidth = tBodyNode.children[0].getBoundingClientRect().width;
    const nodeWithWidesRows = tHeadRowsWidth > tBodyRowsWidth ? tHeadNode : tBodyNode;
    const nodeWithWidesRowsCellsWidth = Array.prototype.reduce.call(nodeWithWidesRows.children[0].children, (accum, cellNode) => {
        accum.push(cellNode.getBoundingClientRect().width);
        return accum;
    }, []);
    const nodeToSetCellsWidth = nodeWithWidesRows === tHeadNode ? tBodyNode : tHeadNode;
    const nodeToSetCellsWidthFirstRow = nodeToSetCellsWidth.children[0];
    for (let j = 0; j < nodeToSetCellsWidthFirstRow.children.length; j++) {
        const cell = nodeToSetCellsWidthFirstRow.children[j];
        cell.setAttribute('style', `width: ${nodeWithWidesRowsCellsWidth[j]}px`);
    }
    if (tBodyNode.children.length === 1) {
        for (const cell of tHeadNodeFirstRow.children) {
            cell.innerHTML = '';
        }
    }
};
export const checkFocus = (args) => (event) => {
    var _a;
    const { tooltip, yagr } = args;
    if (!yagr) {
        return;
    }
    const target = event.target;
    const seriesIdx = target && tooltip.contains(target) && target.tagName === 'TD'
        ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.dataset['seriesIdx']
        : undefined;
    const serie = seriesIdx ? yagr.uplot.series[Number(seriesIdx)] : null;
    yagr.setFocus(serie ? serie.id : null, true);
};
export const detectClickOutside = (args) => (event) => {
    var _a;
    const { tooltip, actions, yagr } = args;
    if (!yagr) {
        return;
    }
    const target = event.target;
    if (target instanceof Element) {
        const isClickInsideTooltip = target && tooltip.contains(target);
        const isClickOnUplotOver = target && ((_a = yagr.root.querySelector('.u-over')) === null || _a === void 0 ? void 0 : _a.contains(target));
        if (!isClickInsideTooltip && !isClickOnUplotOver) {
            actions.pin(false);
            actions.hide();
        }
    }
};
const getXAxisFormatter = (msm = 1, timeZone) => (_, ticks) => {
    const range = (ticks[ticks.length - 1] - ticks[0]) / msm;
    return ticks.map((rawValue) => {
        const d = dateTime({ input: rawValue / msm, timeZone });
        if (d.hour() === 0 && d.minute() === 0 && d.second() === 0) {
            return d.format('DD.MM.YY');
        }
        return d.format(range < 300 ? 'HH:mm:ss' : 'HH:mm');
    });
};
/**
 * This function needs to align timezone that uplot is processing.
 * Uplot uses simple new Date() when [processing ticks](https://github.com/leeoniya/uPlot/blob/master/src/opts.js#L177) on axis.
 * It leads that timestamp will be converted to user browser timezone.
 * In this function we artificially add shift diff between browser timezone and user timeozne to reset new Date() affects.
 */
export const getUplotTimezoneAligner = (chart, timeZone) => (ts) => {
    const dt = ts / ((chart === null || chart === void 0 ? void 0 : chart.timeMultiplier) || 1);
    const browserDate = dateTime({ input: dt });
    const browserTimezone = browserDate.utcOffset();
    const timestampRealTimezone = dateTime({ input: dt, timeZone }).utcOffset();
    const uPlotOffset = (browserTimezone - timestampRealTimezone) * 60 * 1000;
    return new Date(browserDate.valueOf() - uPlotOffset);
};
export const shapeYagrConfig = (args) => {
    var _a, _b;
    const { data, libraryConfig, theme } = args;
    const config = Object.assign(Object.assign({}, libraryConfig), { timeline: data.timeline, series: data.graphs });
    const { timeZone } = data;
    const chart = {
        appearance: {
            locale: settings.get('lang'),
            theme,
        },
    };
    merge(chart, config.chart);
    config.chart = chart;
    if ((_a = config.tooltip) === null || _a === void 0 ? void 0 : _a.show) {
        config.tooltip = config.tooltip || {};
        config.tooltip.render = ((_b = config.tooltip) === null || _b === void 0 ? void 0 : _b.render) || getRenderTooltip(data);
        if (!config.tooltip.className) {
            // "className" property prevent default yagr styles adding
            config.tooltip.className = 'chartkit-yagr-tooltip';
        }
        if (args.customTooltip) {
            config.tooltip.virtual = true;
        }
        /**
         * @todo remove this on next chartkit major release
         * This added to prevent breaking changes in chartkit, while updating yagr@4 which
         * has fixed tooltip sorting (@see https://github.com/gravity-ui/yagr/issues/149)
         */
        config.tooltip.sort = config.tooltip.sort || ((a, b) => b.rowIdx - a.rowIdx);
    }
    config.axes = config.axes || {};
    const xAxis = config.axes[defaults.DEFAULT_X_SCALE];
    config.editUplotOptions = (opts) => (Object.assign(Object.assign({}, opts), { tzDate: timeZone ? getUplotTimezoneAligner(config.chart, timeZone) : undefined }));
    if (xAxis && !xAxis.values) {
        xAxis.values = getXAxisFormatter(config.chart.timeMultiplier, timeZone);
    }
    if (!xAxis) {
        config.axes[defaults.DEFAULT_X_SCALE] = {
            values: getXAxisFormatter(config.chart.timeMultiplier, timeZone),
        };
    }
    return config;
};
