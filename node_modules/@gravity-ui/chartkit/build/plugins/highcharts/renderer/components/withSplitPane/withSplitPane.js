/* eslint callback-return: 0 */
import React from 'react';
import debounce from 'lodash/debounce';
import get from 'lodash/get';
import { getRandomCKId } from '../../../../../utils';
import { cn } from '../../../../../utils/cn';
import { chartTypesWithoutCrosshair } from '../../helpers/config/config';
import { StyledSplitPane } from '../StyledSplitPane/StyledSplitPane';
import './WithSplitPane.css';
const b = cn('with-split-pane');
const PANE_RESIZER_HEIGHT = 24;
const CHART_SECTION_PERCENTAGE = 0.6;
const MIN_TOOLTIP_SECTION_HEIGHT = 62;
const seriesTypesNeedsOnlyHoverState = ['line', 'area', 'arearange', 'bubble', 'map'];
const deviceWithNavBarHeight = window.innerHeight;
function getPointsForInitialRefresh(chart) {
    let minX = Infinity;
    let points = null;
    const type = get(chart, 'userOptions.chart.type');
    if (type === 'streamgraph') {
        points = chart.series[0].points[chart.series[0].points.length - 1];
    }
    else if (chart.series.length === 1) {
        const series = chart.series[0];
        const seriesType = (series && series.type) || (chart.options.chart && chart.options.chart.type);
        points =
            seriesType === 'sankey' || seriesType === 'map'
                ? chart.series[0].points[0]
                : [chart.series[0].points[0]];
    }
    else {
        points = chart.series
            .map((series) => {
            if (series.points[0]) {
                minX = Math.min(minX, series.points[0].x);
            }
            return series.points[0];
        })
            .filter((point) => {
            return point && point.x === minX;
        });
    }
    return points;
}
function forceHoverState(chart, activePoints) {
    var _a, _b, _c;
    const chartType = get(chart, 'userOptions.chart.type') || '';
    if (chartType === 'pie') {
        chart.tooltip.refresh(activePoints);
        chart.pointsForInitialRefresh = activePoints;
    }
    else if (((_a = chart.series) === null || _a === void 0 ? void 0 : _a.length) === 1) {
        const series = chart.series[0];
        const seriesType = (series && series.type) || (chart.options.chart && chart.options.chart.type);
        if (seriesType && seriesTypesNeedsOnlyHoverState.indexOf(seriesType)) {
            chart.series[0].points[0].setState('hover');
        }
        else {
            for (let i = chart.series[0].points.length - 1; i >= 0; i--) {
                chart.series[0].points[i].setState(i ? 'inactive' : 'hover');
            }
        }
    }
    if (chartTypesWithoutCrosshair.indexOf(chartType) === -1) {
        const point = Array.isArray(activePoints) ? activePoints[0] : activePoints;
        (_b = chart.xAxis) === null || _b === void 0 ? void 0 : _b[0].drawCrosshair(undefined, point);
        (_c = chart.yAxis) === null || _c === void 0 ? void 0 : _c[0].drawCrosshair(undefined, point);
    }
}
var PaneSplits;
(function (PaneSplits) {
    PaneSplits["VERTICAL"] = "vertical";
    PaneSplits["HORIZONTAL"] = "horizontal";
})(PaneSplits || (PaneSplits = {}));
export const withSplitPane = (ComposedComponent) => {
    class WithSplitPane extends React.PureComponent {
        constructor(props) {
            super(props);
            this.state = {
                paneSize: undefined,
                maxPaneSize: undefined,
                paneSplit: this.props.paneSplitOrientation ||
                    (window.innerWidth > window.innerHeight
                        ? PaneSplits.VERTICAL
                        : PaneSplits.HORIZONTAL),
                componentKey: getRandomCKId(),
            };
            this.tooltipContainerRef = React.createRef();
            this.rootRef = React.createRef();
            this.setInitialState = (waitForFirstRedraw = false) => {
                // @ts-ignore
                if (!this.props.forwardedRef.current) {
                    return;
                }
                // @ts-ignore
                const { chart } = this.props.forwardedRef.current;
                const points = getPointsForInitialRefresh(chart);
                chart.tooltip.refresh(points);
                chart.pointsForInitialRefresh = points;
                const callback = () => {
                    forceHoverState(chart, points);
                };
                if (this.state.paneSplit === PaneSplits.HORIZONTAL) {
                    this.setInitialPaneSize(callback);
                }
                else if (waitForFirstRedraw) {
                    chart.afterRedrawCallback = callback;
                }
                else {
                    callback();
                }
            };
            this.afterCreateCallback = (chart) => {
                var _a, _b;
                chart.tooltip.splitTooltip = true;
                chart.tooltip.getTooltipContainer = this.getTooltipContainer;
                (_b = (_a = this.props).callback) === null || _b === void 0 ? void 0 : _b.call(_a, chart);
            };
            this.setInitialPaneSize = (callback) => {
                if (!this.tooltipContainerRef.current || !this.rootRef.current) {
                    return;
                }
                const tooltipContentHeight = this.tooltipContainerRef.current.getBoundingClientRect().height;
                const rootHeight = this.rootRef.current.getBoundingClientRect().height;
                const maxPaneSize = rootHeight - MIN_TOOLTIP_SECTION_HEIGHT;
                const currentDeviceHeight = window.innerHeight;
                const otherParticipantsHeight = PANE_RESIZER_HEIGHT + (currentDeviceHeight - deviceWithNavBarHeight) + 1;
                const paneSize = rootHeight - tooltipContentHeight - otherParticipantsHeight;
                this.setState({
                    paneSize: paneSize > maxPaneSize ? maxPaneSize : paneSize,
                    maxPaneSize,
                    componentKey: getRandomCKId(),
                }, () => {
                    this.reflow();
                    setTimeout(callback, 0);
                });
            };
            this.handleOrientationChange = () => {
                const handleResizeAfterOrientationChange = () => {
                    var _a, _b;
                    const deviceWidth = window.innerWidth;
                    const deviceHeight = window.innerHeight;
                    const aspectRatioOrientation = deviceWidth > deviceHeight ? PaneSplits.VERTICAL : PaneSplits.HORIZONTAL;
                    this.setState({
                        paneSplit: this.props.paneSplitOrientation || aspectRatioOrientation,
                    }, () => {
                        this.setInitialState(true);
                    });
                    (_b = (_a = this.props).onSplitPaneOrientationChange) === null || _b === void 0 ? void 0 : _b.call(_a, aspectRatioOrientation);
                    window.removeEventListener('resize', handleResizeAfterOrientationChange);
                };
                window.addEventListener('resize', handleResizeAfterOrientationChange);
            };
            this.reflow = () => {
                // @ts-ignore
                if (this.props.forwardedRef.current) {
                    // @ts-ignore
                    this.props.forwardedRef.current.chart.reflow();
                }
            };
            this.handlePaneChange = (size) => {
                this.setState({ paneSize: size });
                // @ts-ignore
                if (this.props.forwardedRef && this.props.forwardedRef.current) {
                    if (this.props.onPaneChange) {
                        this.props.onPaneChange();
                    }
                    this.reflow();
                    // @ts-ignore
                    const { chart } = this.props.forwardedRef.current;
                    if (chart && chart.pointsForInitialRefresh) {
                        const points = getPointsForInitialRefresh(chart);
                        forceHoverState(chart, points);
                    }
                }
            };
            this.getTooltipContainer = () => {
                return this.tooltipContainerRef.current;
            };
            this.debouncedHandlePaneChange = debounce(this.handlePaneChange, 500);
        }
        componentDidMount() {
            window.addEventListener('orientationchange', this.handleOrientationChange);
            // @ts-ignore
            if (!this.props.forwardedRef.current) {
                return;
            }
            if (this.props.onSplitPaneMountCallback) {
                // @ts-ignore
                this.props.onSplitPaneMountCallback(this.props.forwardedRef.current.chart);
            }
            this.setInitialState();
        }
        componentWillUnmount() {
            window.removeEventListener('orientationchange', this.handleOrientationChange);
        }
        render() {
            return (React.createElement("div", { className: b(), ref: this.rootRef }, this.state.paneSplit === PaneSplits.VERTICAL
                ? this.renderVertical()
                : this.renderHorizontal()));
        }
        renderHorizontal() {
            const { paneSize, maxPaneSize, componentKey } = this.state;
            const thirdOfViewport = window.innerHeight / 3;
            return (React.createElement(StyledSplitPane, { split: "horizontal", onChange: this.debouncedHandlePaneChange, minSize: thirdOfViewport, maxSize: maxPaneSize || undefined, size: paneSize, paneOneRender: () => (React.createElement(ComposedComponent, Object.assign({}, this.props, { key: componentKey, ref: this.props.forwardedRef, callback: this.afterCreateCallback }))), paneTwoRender: () => React.createElement("div", { ref: this.tooltipContainerRef }) }));
        }
        renderVertical() {
            const { componentKey } = this.state;
            const paneSize = window.innerWidth * CHART_SECTION_PERCENTAGE;
            return (React.createElement(StyledSplitPane, { split: "vertical", allowResize: false, size: paneSize, paneOneRender: () => (React.createElement(ComposedComponent, Object.assign({}, this.props, { key: componentKey, ref: this.props.forwardedRef, callback: this.afterCreateCallback }))), paneTwoRender: () => React.createElement("div", { ref: this.tooltipContainerRef }) }));
        }
    }
    return React.forwardRef((props, ref) => {
        return React.createElement(WithSplitPane, Object.assign({}, props, { forwardedRef: ref }));
    });
};
