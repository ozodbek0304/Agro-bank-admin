import React from 'react';
import Highcharts from 'highcharts';
import get from 'lodash/get';
import { settings } from '../../../../libs';
import { settingsEventEmitter } from '../../../../libs/settings/settings';
import { getChartPerformanceDuration, getRandomCKId, markChartPerformance } from '../../../../utils';
import { getGraph } from '../helpers/graph';
import { initHighchartsLangOptions } from '../helpers/highcharts/highcharts';
import HighchartsReact from './HighchartsReact';
import { withSplitPane } from './withSplitPane/withSplitPane';
import './HighchartsComponent.css';
const HighcharsReactWithSplitPane = withSplitPane(HighchartsReact);
settingsEventEmitter.on('change-lang', {
    id: 'hc-lang-handler',
    action: initHighchartsLangOptions,
});
export class HighchartsComponent extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            prevData: null,
            options: null,
            callback: null,
            isError: false,
        };
        this.chartComponent = React.createRef();
        this.reflow = () => {
            if (this.chartComponent.current) {
                this.chartComponent.current.chart.reflow();
            }
        };
        this.extendChartInstance = (chart) => {
            chart.updateParams = this.updateParams;
            chart.getParams = this.getParams;
        };
        this.getParams = () => {
            return this.props.data.params || {};
        };
        this.updateParams = (params) => {
            if (this.props.onChange) {
                this.props.onChange({ type: 'PARAMS_CHANGED', data: { params } }, { forceUpdate: true }, true);
            }
        };
    }
    static getDerivedStateFromProps(nextProps, prevState) {
        var _a, _b;
        const isCurrentTooltipSplitted = get(prevState, 'options.tooltip.splitTooltip');
        const tooltipTypeWasChanged = isCurrentTooltipSplitted !== nextProps.splitTooltip;
        if (nextProps.data === prevState.prevData && !tooltipTypeWasChanged) {
            return null;
        }
        try {
            const { nonBodyScroll, data: { data, libraryConfig, config, comments }, isMobile, } = nextProps;
            const entryId = get(nextProps, 'data.entryId');
            const configOptions = Object.assign({
                nonBodyScroll,
                drillDownData: (_a = nextProps.data.config) === null || _a === void 0 ? void 0 : _a.drillDown,
                splitTooltip: nextProps.splitTooltip,
                highcharts: libraryConfig,
                entryId,
            }, config);
            const { config: options, callback } = getGraph({
                options: configOptions,
                holidays: (_b = settings.get('extra')) === null || _b === void 0 ? void 0 : _b.holidays,
                data,
                comments,
                isMobile,
            });
            return {
                prevData: nextProps.data,
                options,
                callback,
                isError: false,
            };
        }
        catch (error) {
            const { hoistConfigError, onError } = nextProps;
            if (onError && !hoistConfigError) {
                onError({ error });
            }
            if (hoistConfigError) {
                throw error;
            }
            return { isError: true };
        }
    }
    componentDidMount() {
        var _a, _b;
        if (!this.props.onChartLoad) {
            this.onLoad();
            return;
        }
        const needCallbacks = !this.state.isError && !this.props.splitTooltip;
        if (!needCallbacks) {
            return;
        }
        const widget = this.chartComponent.current ? this.chartComponent.current.chart : null;
        if (this.state.callback && widget) {
            this.state.callback(widget);
        }
        (_b = (_a = this.props).onChartLoad) === null || _b === void 0 ? void 0 : _b.call(_a, {
            widget,
        });
    }
    componentDidUpdate() {
        if (this.needRenderCallback()) {
            const widget = this.chartComponent.current ? this.chartComponent.current.chart : null;
            if (this.state.callback && widget) {
                this.state.callback(widget);
            }
            return;
        }
        this.onLoad();
    }
    render() {
        const { isError, options } = this.state;
        const Component = this.props.splitTooltip ? HighcharsReactWithSplitPane : HighchartsReact;
        if (isError) {
            return null;
        }
        markChartPerformance(this.getId(true));
        return (React.createElement(Component, { key: Math.random(), options: options, highcharts: Highcharts, onSplitPaneMountCallback: this.state.callback || undefined, onSplitPaneOrientationChange: this.props.onSplitPaneOrientationChange, paneSplitOrientation: this.props.paneSplitOrientation, callback: this.extendChartInstance, constructorType: (options === null || options === void 0 ? void 0 : options.useHighStock) ? 'stockChart' : 'chart', containerProps: { className: 'chartkit-graph' }, ref: this.chartComponent, onRender: this.needRenderCallback() && this.props.onRender }));
    }
    getId(refresh = false) {
        if (refresh) {
            this.id = getRandomCKId();
        }
        return `${this.props.id}_${this.id}`;
    }
    onLoad() {
        if (!this.state.isError && !this.props.splitTooltip) {
            const data = {
                widget: this.chartComponent.current ? this.chartComponent.current.chart : null,
                widgetData: this.state.options,
                loadedData: this.state.prevData,
            };
            if (this.state.callback && data.widget) {
                this.state.callback(data.widget);
            }
            const widgetRendering = getChartPerformanceDuration(this.getId());
            if (this.props.onLoad) {
                this.props.onLoad({ widget: data.widget, widgetRendering });
            }
            window.requestAnimationFrame(this.reflow);
        }
    }
    needRenderCallback() {
        const { splitTooltip, onRender } = this.props;
        const { isError } = this.state;
        return !splitTooltip && onRender && !isError;
    }
}
HighchartsComponent.defaultProps = {
    hoistConfigError: true,
};
