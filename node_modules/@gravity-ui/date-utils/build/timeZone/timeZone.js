"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseZoneInfo = exports.fixOffset = exports.normalizeTimeZone = exports.timeZoneOffset = exports.isValidTimeZone = exports.getTimeZonesList = exports.guessUserTimeZone = void 0;
var constants_1 = require("../constants");
var locale_1 = require("../utils/locale");
/**
 * Returns the user's time zone.
 */
// eslint-disable-next-line new-cap
var guessUserTimeZone = function () { return Intl.DateTimeFormat().resolvedOptions().timeZone; };
exports.guessUserTimeZone = guessUserTimeZone;
/**
 * Returns all time zones.
 */
// remove when Intl definition is extended
// @ts-expect-error https://github.com/microsoft/TypeScript/issues/49231
var getTimeZonesList = function () { var _a; return ((_a = Intl.supportedValuesOf) === null || _a === void 0 ? void 0 : _a.call(Intl, 'timeZone')) || []; };
exports.getTimeZonesList = getTimeZonesList;
var validTimeZones = {};
function isValidTimeZone(zone) {
    if (!zone) {
        return false;
    }
    if (Object.prototype.hasOwnProperty.call(validTimeZones, zone)) {
        return validTimeZones[zone];
    }
    try {
        new Intl.DateTimeFormat('en-US', { timeZone: zone }).format();
        validTimeZones[zone] = true;
        return true;
    }
    catch (_a) {
        validTimeZones[zone] = false;
        return false;
    }
}
exports.isValidTimeZone = isValidTimeZone;
var dateFields = [
    'year',
    'month',
    'day',
    'hour',
    'minute',
    'second',
    'era',
];
function isDateField(v) {
    return dateFields.includes(v);
}
function timeZoneOffset(zone, ts) {
    var date = new Date(ts);
    if (isNaN(date.valueOf()) || (zone !== 'system' && !isValidTimeZone(zone))) {
        return NaN;
    }
    if (zone === 'system') {
        return -date.getTimezoneOffset() || 0;
    }
    var dtf = (0, locale_1.getDateTimeFormat)('en-US', {
        hour12: false,
        timeZone: zone === 'system' ? undefined : zone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        era: 'short',
    });
    var formatted = dtf.formatToParts(date);
    var parts = {
        year: 1,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        era: 'AD',
    };
    for (var _i = 0, formatted_1 = formatted; _i < formatted_1.length; _i++) {
        var _a = formatted_1[_i], type = _a.type, value = _a.value;
        if (type === 'era') {
            parts.era = value;
        }
        else if (isDateField(type)) {
            parts[type] = parseInt(value, 10);
        }
    }
    // Date.UTC(year), year: 0 — is 1 BC, -1 — is 2 BC, e.t.c
    var year = parts.era === 'BC' ? -Math.abs(parts.year) + 1 : parts.year;
    var month = parts.month - 1; // month is zero base index
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    var hour = parts.hour === 24 ? 0 : parts.hour;
    var asUTC = Date.UTC(year, month, parts.day, hour, parts.minute, parts.second, 0);
    // years between 0 and 99 are interpreted as 19XX; revert that
    if (year < 100 && year >= 0) {
        var d = new Date(asUTC);
        d.setUTCFullYear(year, month, parts.day);
        asUTC = d.valueOf();
    }
    var asTS = date.valueOf();
    var over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
}
exports.timeZoneOffset = timeZoneOffset;
function normalizeTimeZone(input, defaultZone) {
    if (input === undefined || input === null) {
        return defaultZone;
    }
    var lowered = input.toLowerCase();
    if (lowered === 'utc' || lowered === 'gmt') {
        return constants_1.UtcTimeZone;
    }
    if (lowered === 'system') {
        return 'system';
    }
    if (lowered === 'default') {
        return defaultZone;
    }
    if (isValidTimeZone(input)) {
        return input;
    }
    throw new Error("InvalidZone: ".concat(input));
}
exports.normalizeTimeZone = normalizeTimeZone;
function fixOffset(localTS, o, tz) {
    // Our UTC time is just a guess because our offset is just a guess
    var utcGuess = localTS - o * 60 * 1000;
    // Test whether the zone matches the offset for this ts
    var o2 = timeZoneOffset(tz, utcGuess);
    // If so, offset didn't change and we're done
    if (o === o2) {
        return [utcGuess, o];
    }
    // If not, change the ts by the difference in the offset
    utcGuess -= (o2 - o) * 60 * 1000;
    // If that gives us the local time we want, we're done
    var o3 = timeZoneOffset(tz, utcGuess);
    if (o2 === o3) {
        return [utcGuess, o2];
    }
    // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time
    return [localTS - Math.min(o2, o3) * 60 * 1000, Math.min(o2, o3)];
}
exports.fixOffset = fixOffset;
function parseZoneInfo(_a) {
    var timeZone = _a.timeZone, ts = _a.ts, locale = _a.locale, offsetFormat = _a.offsetFormat;
    var date = new Date(ts);
    var intlOpts = {
        hourCycle: 'h23',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
    };
    if (timeZone) {
        intlOpts.timeZone = normalizeTimeZone(timeZone, timeZone);
    }
    var modified = __assign({ timeZoneName: offsetFormat }, intlOpts);
    var parsed = new Intl.DateTimeFormat(locale, modified)
        .formatToParts(date)
        .find(function (m) { return m.type.toLowerCase() === 'timezonename'; });
    return parsed ? parsed.value : '';
}
exports.parseZoneInfo = parseZoneInfo;
