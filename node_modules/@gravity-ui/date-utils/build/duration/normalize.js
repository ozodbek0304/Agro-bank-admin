"use strict";
// Copyright 2019 JS Foundation and other contributors
// Copyright 2024 YANDEX LLC
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rescale = exports.shiftTo = exports.removeZeros = exports.normalizeValues = exports.orderedUnits = void 0;
var daysInYearAccurate = 146097.0 / 400;
var daysInMonthAccurate = 146097.0 / 4800;
var lowOrderMatrix = {
    weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1000,
    },
    days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1000,
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },
    minutes: { seconds: 60, milliseconds: 60 * 1000 },
    seconds: { milliseconds: 1000 },
};
var matrix = __assign({ years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000,
    }, quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: (daysInYearAccurate * 24) / 4,
        minutes: (daysInYearAccurate * 24 * 60) / 4,
        seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,
        milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4,
    }, months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000,
    } }, lowOrderMatrix);
exports.orderedUnits = [
    'years',
    'quarters',
    'months',
    'weeks',
    'days',
    'hours',
    'minutes',
    'seconds',
    'milliseconds',
];
var reverseUnits = exports.orderedUnits.slice(0).reverse();
function normalizeValues(values, _a) {
    var _b, _c, _d, _e, _f, _g, _h;
    var _j = _a === void 0 ? {} : _a, roundUp = _j.roundUp;
    var newValues = __assign({}, values);
    var factor = durationToMilliseconds(values) < 0 ? -1 : 1;
    var previous = null;
    for (var i = 0; i < reverseUnits.length; i++) {
        var current = reverseUnits[i];
        if (newValues[current] === undefined || newValues[current] === null) {
            continue;
        }
        if (!previous) {
            previous = current;
            continue;
        }
        var previousVal = ((_b = newValues[previous]) !== null && _b !== void 0 ? _b : 0) * factor;
        // @ts-expect-error
        var conv = matrix[current][previous];
        // if (previousVal < 0):
        // lower order unit is negative (e.g. { years: 2, days: -2 })
        // normalize this by reducing the higher order unit by the appropriate amount
        // and increasing the lower order unit
        // this can never make the higher order unit negative, because this function only operates
        // on positive durations, so the amount of time represented by the lower order unit cannot
        // be larger than the higher order unit
        // else:
        // lower order unit is positive (e.g. { years: 2, days: 450 } or { years: -2, days: 450 })
        // in this case we attempt to convert as much as possible from the lower order unit into
        // the higher order one
        //
        // Math.floor takes care of both of these cases, rounding away from 0
        // if previousVal < 0 it makes the absolute value larger
        // if previousVal >= it makes the absolute value smaller
        var rollUp = Math.floor(previousVal / conv);
        newValues[current] = ((_c = newValues[current]) !== null && _c !== void 0 ? _c : 0) + rollUp * factor;
        newValues[previous] = ((_d = newValues[previous]) !== null && _d !== void 0 ? _d : 0) - rollUp * conv * factor;
        previous = current;
    }
    // try to convert any decimals into smaller units if possible
    // for example for { years: 2.5, days: 0, seconds: 0 } we want to get { years: 2, days: 182, hours: 12 }
    previous = null;
    for (var i = 0; i < exports.orderedUnits.length; i++) {
        var current = exports.orderedUnits[i];
        if (newValues[current] === undefined || newValues[current] === null) {
            continue;
        }
        if (!previous) {
            previous = current;
            continue;
        }
        var fraction = ((_e = newValues[previous]) !== null && _e !== void 0 ? _e : 0) % 1;
        newValues[previous] = ((_f = newValues[previous]) !== null && _f !== void 0 ? _f : 0) - fraction;
        // @ts-expect-error
        newValues[current] = ((_g = newValues[current]) !== null && _g !== void 0 ? _g : 0) + fraction * matrix[previous][current];
        previous = current;
    }
    if (roundUp && previous && newValues[previous]) {
        newValues[previous] = Math.round((_h = newValues[previous]) !== null && _h !== void 0 ? _h : 0);
    }
    return newValues;
}
exports.normalizeValues = normalizeValues;
function durationToMilliseconds(values) {
    var _a;
    var sum = (_a = values.milliseconds) !== null && _a !== void 0 ? _a : 0;
    for (var _i = 0, _b = reverseUnits.slice(1); _i < _b.length; _i++) {
        var unit = _b[_i];
        var v = values[unit];
        if (v) {
            // @ts-expect-error
            sum += v * matrix[unit]['milliseconds'];
        }
    }
    return sum;
}
function removeZeros(values) {
    var newValues = {};
    for (var _i = 0, _a = Object.entries(values); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (value !== 0) {
            newValues[key] = value;
        }
    }
    return newValues;
}
exports.removeZeros = removeZeros;
function shiftTo(values, units, options) {
    var _a;
    if (!units.length) {
        return values;
    }
    var newValues = {};
    var accumulated = {};
    var lastUnit;
    for (var _i = 0, orderedUnits_1 = exports.orderedUnits; _i < orderedUnits_1.length; _i++) {
        var unit = orderedUnits_1[_i];
        if (!units.includes(unit)) {
            if (values[unit]) {
                accumulated[unit] = values[unit];
            }
            continue;
        }
        lastUnit = unit;
        var own = 0;
        // anything we haven't boiled down yet should get boiled to this unit
        for (var _b = 0, _c = Object.keys(accumulated); _b < _c.length; _b++) {
            var ak = _c[_b];
            // @ts-expect-error
            own += matrix[ak][unit] * accumulated[ak];
            accumulated[ak] = 0;
        }
        // plus anything that's already in this unit
        var v = values[unit];
        if (v) {
            own += v;
        }
        // only keep the integer part for now in the hopes of putting any decimal part
        // into a smaller unit later
        var i = Math.trunc(own);
        newValues[unit] = i;
        accumulated[unit] = (own * 1000 - i * 1000) / 1000;
    }
    // lastUnit must be defined since units is not empty
    if (lastUnit) {
        // anything leftover becomes the decimal for the last unit
        for (var _d = 0, _e = Object.entries(accumulated); _d < _e.length; _d++) {
            var _f = _e[_d], key = _f[0], value = _f[1];
            if (value !== 0) {
                newValues[lastUnit] =
                    ((_a = newValues[lastUnit]) !== null && _a !== void 0 ? _a : 0) +
                        (key === lastUnit
                            ? value
                            : // @ts-expect-error
                                value / matrix[lastUnit][key]);
            }
        }
        var v = newValues[lastUnit];
        if (v) {
            newValues[lastUnit] = Math.round(v * 1000) / 1000;
        }
    }
    return normalizeValues(newValues, options);
}
exports.shiftTo = shiftTo;
function rescale(values, options) {
    var newValues = removeZeros(shiftTo(normalizeValues(values), ['years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds', 'milliseconds'], options));
    return newValues;
}
exports.rescale = rescale;
