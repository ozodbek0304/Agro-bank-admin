"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drawMarkersIfRequired = exports.renderCircle = void 0;
const defaults_1 = require("../../defaults");
const common_1 = require("../..//utils/common");
const renderCircle = (u, x, y, r, s, color, strokeColor, yScale) => {
    const { ctx } = u;
    const cx = Math.round(u.valToPos(x, defaults_1.DEFAULT_X_SCALE, true));
    const cy = Math.round(u.valToPos(y, yScale || defaults_1.DEFAULT_Y_SCALE, true));
    ctx.beginPath();
    ctx.arc(cx, cy, r * 2, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    if (s) {
        const lineWidth = ctx.lineWidth;
        const strokeStyle = ctx.strokeStyle;
        ctx.lineWidth = s;
        ctx.strokeStyle = strokeColor;
        ctx.stroke();
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = strokeStyle;
    }
    ctx.fill();
    ctx.closePath();
};
exports.renderCircle = renderCircle;
function drawMarkersIfRequired(u, i, i0, i1) {
    const { color, scale, spanGaps, count, pointsSize } = u.series[i];
    if (spanGaps && count > 1) {
        return false;
    }
    let j = i0;
    let prev;
    while (j <= i1) {
        const val = u.data[i][j];
        if (val === null) {
            prev = val;
            j++;
            continue;
        }
        const nextIdx = j + 1;
        const next = u.data[i][nextIdx];
        if ((0, common_1.isNil)(prev) && (0, common_1.isNil)(next)) {
            (0, exports.renderCircle)(u, u.data[0][j], val, pointsSize !== null && pointsSize !== void 0 ? pointsSize : (defaults_1.DEFAULT_POINT_SIZE / 2), 0, color, color, scale || defaults_1.DEFAULT_Y_SCALE);
        }
        prev = val;
        j++;
    }
    return undefined;
}
exports.drawMarkersIfRequired = drawMarkersIfRequired;
/*
 * This plugin configures points markers
 */
function YagrMarkersPlugin(yagr, config) {
    var _a;
    const { size = defaults_1.DEFAULT_POINT_SIZE, strokeWidth = 2, strokeColor = '#ffffff', show } = config.markers;
    const chartSeriesOptions = (_a = config.chart) === null || _a === void 0 ? void 0 : _a.series;
    const defaultDotsSize = (chartSeriesOptions === null || chartSeriesOptions === void 0 ? void 0 : chartSeriesOptions.pointsSize) || defaults_1.DEFAULT_POINT_SIZE;
    function drawCircles(u, i, i0, i1) {
        const { scale, _focus, color, getFocusedColor, type } = u.series[i];
        let j = i0;
        // eslint-disable-next-line no-nested-ternary
        const pointSize = type === 'dots' ? (show ? size : defaultDotsSize) : size;
        while (j <= i1) {
            const val = u.data[i][j];
            if (val !== null) {
                (0, exports.renderCircle)(u, u.data[0][j], val, pointSize, strokeWidth, (_focus || _focus === null ? color : getFocusedColor(yagr, i)) || color, strokeColor, scale || defaults_1.DEFAULT_Y_SCALE);
            }
            j++;
        }
        return undefined;
    }
    const markSeries = (idx, s) => {
        if (idx === 0 || idx === null) {
            return;
        }
        if (s.type === 'dots' || config.markers.show) {
            s.points = s.points || {};
            s.points.show = drawCircles;
        }
    };
    return {
        opts: (_, opts) => {
            if (!(config.markers.show || opts.series.some((s) => s.type === 'dots'))) {
                return;
            }
            opts.series.forEach((s, i) => markSeries(i, s));
        },
        hooks: {
            addSeries: (uplot, seriesIdx) => {
                const series = uplot.series[seriesIdx];
                markSeries(seriesIdx, series);
            },
            setSeries: (_, idx, series) => {
                markSeries(idx, series);
            },
        },
    };
}
exports.default = YagrMarkersPlugin;
