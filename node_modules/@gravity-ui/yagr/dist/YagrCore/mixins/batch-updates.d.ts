import type { MinimalValidConfig } from '../types';
import type Yagr from '..';
export interface Batch {
    active: boolean;
    fns: ((s: Batch) => void)[];
    /** If true then uPlot options will be re-configured  */
    reopt?: boolean;
    /** If true then data will be recalculated (use for stacks/normalization/other calculations) */
    recalc?: boolean;
    /** False or redraw uPlot redraw arguments */
    redraw?: false | [series: boolean, axes: boolean];
    /** If batch will end with full re-instantiation of uPlot */
    reinit?: boolean;
    /** If true, legend will be fully redrawn instead of re-initialization  */
    redrawLegend?: boolean;
}
export declare class BatchMixin<T extends MinimalValidConfig> {
    protected _batch: Batch;
    initMixin(): void;
    /**
     * @public
     * @param fn batch funcion.
     * @experimental
     * @descriptoin Batch wrapper. Batch function accepts batch state, it can be modified to change batch execution behaviour.
     * @example
     * ```typescript
     * yagr.batch((s) => {
     *    s.reopt = true; // reinit uPlot options
     *    s.recalc = true; // recalculate series
     *    s.redraw = [true, true]; // redraw chart
     *    s.reinit = true; // reinit uPlot chart
     * });
     * ```
     */
    batch(this: Yagr<T>, fn: (s: Batch) => void): void;
}
