"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchMixin = void 0;
const uplot_1 = __importDefault(require("uplot"));
const legend_1 = __importDefault(require("../plugins/legend/legend"));
class BatchMixin {
    initMixin() {
        this._batch = {
            active: false,
            fns: [],
        };
    }
    /**
     * @public
     * @param fn batch funcion.
     * @experimental
     * @descriptoin Batch wrapper. Batch function accepts batch state, it can be modified to change batch execution behaviour.
     * @example
     * ```typescript
     * yagr.batch((s) => {
     *    s.reopt = true; // reinit uPlot options
     *    s.recalc = true; // recalculate series
     *    s.redraw = [true, true]; // redraw chart
     *    s.reinit = true; // reinit uPlot chart
     * });
     * ```
     */
    batch(fn) {
        var _a;
        if (this._batch.active) {
            return fn(this._batch);
        }
        this._batch.active = true;
        fn(this._batch);
        if (this._batch.reinit) {
            return this.fullUpdate();
        }
        if (this._batch.redrawLegend) {
            (_a = this.plugins.legend) === null || _a === void 0 ? void 0 : _a.redraw();
        }
        if (this._batch.reopt) {
            this.createUplotOptions(true);
        }
        if (this._batch.recalc) {
            this.inStage('processing', () => {
                this.transformSeries();
            }).inStage('listen');
        }
        this._batch.fns.length && this.uplot.batch(() => this._batch.fns.forEach((fn) => fn(this._batch)));
        if (this._batch.redraw && this.uplot) {
            this.redraw(...this._batch.redraw);
        }
        this._batch = { active: false, fns: [] };
    }
    /**
     *
     * @internal
     * @description Full update of chart. Used when config is changed totally.
     */
    fullUpdate() {
        let left;
        let top;
        this.inStage('dispose', () => {
            var _a;
            if (this.uplot) {
                const cursor = this.uplot.cursor;
                left = cursor.left;
                top = cursor.top;
                // uplot may be undefined if chart is not rendered yet, but got update
                this.uplot.destroy();
            }
            (_a = this.plugins.legend) === null || _a === void 0 ? void 0 : _a.destroy();
        })
            .inStage('config', () => {
            this.plugins.legend = new legend_1.default();
            this._batch = { active: false, fns: [] };
            this.createUplotOptions(true);
            this.options = this.config.editUplotOptions ? this.config.editUplotOptions(this.options) : this.options;
        })
            .inStage('processing', () => {
            this.transformSeries();
        })
            .inStage('uplot', () => {
            this.uplot = new uplot_1.default(this.options, this.series, this.initRender);
            if (left && top && left > 0 && top > 0) {
                this.uplot.setCursor({ left, top });
            }
            // by default uPlot subsribes self to cursor, if we don't need it, we should unsubscribe manually
            if (!this.state.subscribed) {
                this.unsubscribe();
            }
        })
            .inStage('listen');
    }
}
exports.BatchMixin = BatchMixin;
