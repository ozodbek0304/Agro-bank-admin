import UPlot, { Options as UPlotOptions, AlignedData, Series, SyncPubSub } from 'uplot';
import LegendPlugin from './plugins/legend/legend';
import { TooltipPlugin } from './plugins/tooltip/tooltip';
import cursorPlugin from './plugins/cursor/cursor';
import { PlotLinesPlugin } from './plugins/plotLines/plotLines';
import { YagrConfig, MinimalValidConfig, InternalYargHooks } from './types';
import ColorParser from './utils/colors';
import ThemedDefaults from './defaults';
import i18n from './locale';
import { CreateUplotOptionsMixin } from './mixins/create-options';
import { TransformSeriesMixin } from './mixins/transform-series';
import { DynamicUpdatesMixin } from './mixins/dynamic-updates';
import { BatchMixin } from './mixins/batch-updates';
export interface YagrEvent {
    chart: Yagr;
    meta: YagrMeta;
}
export type YagrMeta = {
    renderTime: number;
    processTime: number;
    initTime: number;
};
type CachedProps = {
    width: number;
    height: number;
};
export interface YagrState {
    isEmptyDataSet: boolean;
    isMouseOver: boolean;
    stage: 'config' | 'processing' | 'uplot' | 'render' | 'listen' | 'dispose';
    inBatch?: boolean;
    y2uIdx: Record<string, number>;
    subscribed: boolean;
}
declare class Yagr<TConfig extends MinimalValidConfig = MinimalValidConfig> {
    id: string;
    options: UPlotOptions;
    uplot: UPlot;
    root: HTMLElement;
    series: AlignedData;
    config: YagrConfig;
    resizeOb?: ResizeObserver;
    canvas: HTMLCanvasElement;
    plugins: {
        tooltip?: ReturnType<TooltipPlugin>;
        plotLines?: ReturnType<PlotLinesPlugin>;
        cursor?: ReturnType<typeof cursorPlugin>;
        legend?: LegendPlugin;
    } & Partial<TConfig['plugins'] extends YagrConfig['plugins'] ? {
        [key in keyof TConfig['plugins']]: ReturnType<TConfig['plugins'][key]>;
    } : {}>;
    state: YagrState;
    utils: {
        colors: ColorParser;
        sync?: SyncPubSub;
        theme: ThemedDefaults;
        i18n: ReturnType<typeof i18n>;
    };
    get isEmpty(): boolean;
    protected _startTime: number;
    protected _meta: Partial<YagrMeta>;
    /** Create uPlot options methods */
    protected createUplotOptions: CreateUplotOptionsMixin<TConfig>['createUplotOptions'];
    protected transformSeries: TransformSeriesMixin<TConfig>['transformSeries'];
    protected _uHooks: Record<string, (u: uPlot) => void>;
    /** Dynamic update methods */
    setTheme: DynamicUpdatesMixin<TConfig>['setTheme'];
    setLocale: DynamicUpdatesMixin<TConfig>['setLocale'];
    setAxes: DynamicUpdatesMixin<TConfig>['setAxes'];
    setSeries: DynamicUpdatesMixin<TConfig>['setSeries'];
    setVisible: DynamicUpdatesMixin<TConfig>['setVisible'];
    setFocus: DynamicUpdatesMixin<TConfig>['setFocus'];
    setScales: DynamicUpdatesMixin<TConfig>['setScales'];
    setTitle: DynamicUpdatesMixin<TConfig>['setTitle'];
    setConfig: DynamicUpdatesMixin<TConfig>['setConfig'];
    /** Batch update methods */
    batch: BatchMixin<TConfig>['batch'];
    protected fullUpdate: BatchMixin<TConfig>['fullUpdate'];
    protected _batch: BatchMixin<TConfig>['_batch'];
    protected _cache: CachedProps;
    /** Mixin methods */
    private initMixins;
    constructor(root: HTMLElement, pConfig: TConfig);
    /**
     * Redraws Yagr instance by given options.
     */
    redraw(series?: boolean, axes?: boolean): void;
    /**
     *  Get uPlot's Series from series id
     */
    getSeriesById(id: string): Series;
    dispose(): void;
    toDataUrl(): string;
    subscribe(): void;
    unsubscribe(): void;
    protected init: () => void;
    protected execHooks: <T extends keyof InternalYargHooks>(hookName: T, ...args: Parameters<Required<InternalYargHooks>[T][0]>) => void;
    protected inStage(stage: YagrState['stage'], fn?: () => void): this;
    protected initRender: (u: uPlot, done: Function) => void;
    protected initTitle(): void;
    private onError;
    private trackMouse;
    private onResize;
    get clientHeight(): number;
    reflow(redraw?: boolean): void;
}
export default Yagr;
