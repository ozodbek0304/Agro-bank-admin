"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureAxes = exports.updateAxis = exports.getRedrawOptionsForAxesUpdate = exports.getTimeFormatter = exports.getDefaultNumberFormatter = exports.getAxisPositioning = void 0;
const uplot_1 = __importDefault(require("uplot"));
const defaults = __importStar(require("../defaults"));
const common_1 = require("./common");
const types_1 = require("./types");
const YAGR_AXIS_TO_UPLOT_AXIS = {
    right: types_1.Axis.Side.Right,
    top: types_1.Axis.Side.Top,
    bottom: types_1.Axis.Side.Bottom,
    left: types_1.Axis.Side.Left,
};
const AXIS_SIDE_TO_ALIGN = {
    left: types_1.Axis.Align.Right,
    right: types_1.Axis.Align.Left,
    top: undefined,
    bottom: undefined,
};
const getAxisPositioning = (side, align) => {
    return {
        side: side ? YAGR_AXIS_TO_UPLOT_AXIS[side] : types_1.Axis.Side.Left,
        align: align || (side ? AXIS_SIDE_TO_ALIGN[side] : undefined),
    };
};
exports.getAxisPositioning = getAxisPositioning;
const getDefaultNumberFormatter = (precision, nullValue = '') => {
    return (n) => {
        if ((0, common_1.isNil)(n)) {
            return nullValue;
        }
        if (n === 0) {
            return '0';
        }
        const abs = Math.abs(n);
        const precisionNum = precision === 'auto' ? 2 : precision;
        const [pow, suffix] = (0, common_1.getUnitSuffix)(abs);
        const transformedValue = n / pow;
        return ((precision === 'auto'
            ? String(transformedValue).replace(/\.(\d{5,})/, (match) => {
                return match.slice(0, 6);
            })
            : (0, common_1.toFixed)(transformedValue, precisionNum)) + suffix);
    };
};
exports.getDefaultNumberFormatter = getDefaultNumberFormatter;
/*
 * Generates ticks labels values
 */
const getNumericValueFormatter = (axisConfig) => {
    const p = axisConfig.precision;
    const numFormatter = (0, exports.getDefaultNumberFormatter)(typeof p === 'number' ? p : p || 'auto', '');
    return function defaultNumericValueFormatter(_, ticks) {
        return ticks.map(numFormatter);
    };
};
const dayTimeFormatter = uplot_1.default.fmtDate('{DD}.{MM}.{YYYY}');
const dateTimeFormatter = uplot_1.default.fmtDate('{HH}:{mm}:{ss}');
const minuteFormatter = uplot_1.default.fmtDate('{mm}:{ss}');
const secondFormatter = uplot_1.default.fmtDate('{mm}:{ss}.{fff}');
const yearFormatter = uplot_1.default.fmtDate('{YYYY}');
function getTimeFormatterByRange(range, ticksCount) {
    let formatter = dayTimeFormatter;
    const minRange = Math.ceil(range / ticksCount);
    if (minRange <= defaults.SECOND) {
        formatter = secondFormatter;
    }
    else if (minRange <= defaults.MINUTE) {
        formatter = minuteFormatter;
    }
    else if (minRange <= defaults.DAY) {
        formatter = dateTimeFormatter;
    }
    else if (minRange >= defaults.YEAR) {
        formatter = yearFormatter;
    }
    return (x) => formatter(new Date(x));
}
const getTimeFormatter = (config) => {
    const msm = config.chart.timeMultiplier || defaults.TIME_MULTIPLIER;
    return (_, ticks) => {
        const range = ticks[ticks.length - 1] - ticks[0];
        const rangeMs = range / msm;
        const formatter = getTimeFormatterByRange(rangeMs, ticks.length);
        return ticks.map((rawValue) => {
            return formatter(rawValue / msm);
        });
    };
};
exports.getTimeFormatter = getTimeFormatter;
function getSplits(splitsCount) {
    return (_, __, scaleMin, scaleMax) => {
        if (splitsCount <= 2) {
            return [scaleMin, scaleMax];
        }
        const dist = Math.abs(scaleMax - scaleMin);
        const step = dist / (splitsCount - 1);
        let i = step;
        const splits = [];
        while (scaleMin + i < scaleMax) {
            splits.push(scaleMin + i);
            i += step;
        }
        return [scaleMin, ...splits, scaleMax];
    };
}
// eslint-disable-next-line complexity
function getAxis(axisConfig, yagr) {
    var _a, _b;
    const theme = yagr.utils.theme;
    const config = yagr.config;
    const axis = {
        splits: axisConfig.splitsCount ? getSplits(axisConfig.splitsCount) : axisConfig.splits,
        show: typeof axisConfig.show === 'undefined' ? true : axisConfig.show,
        label: axisConfig.label || undefined,
        labelSize: axisConfig.labelSize || defaults.Y_AXIS_LABEL_SIZE,
        labelFont: axisConfig.labelFont || defaults.AXIS_LABEL_FONT,
        font: axisConfig.font || defaults.AXIS_VALUES_FONT,
        stroke: axisConfig.stroke || (() => theme.AXIS_STROKE),
        ticks: axisConfig.ticks ? { ...theme.Y_AXIS_TICKS, ...axisConfig.ticks } : theme.Y_AXIS_TICKS,
        grid: config.grid || axisConfig.grid || theme.GRID,
    };
    if (axisConfig.scale === defaults.DEFAULT_X_SCALE) {
        return Object.assign(axis, {
            getFormatter: getTimeFormatterByRange,
            gap: (_a = axisConfig.gap) !== null && _a !== void 0 ? _a : defaults.X_AXIS_TICK_GAP,
            size: (0, common_1.asFn)(axisConfig.size) || (() => defaults.X_AXIS_SIZE),
            values: axisConfig.values || (0, exports.getTimeFormatter)(config),
            ticks: axisConfig.ticks ? { ...theme.X_AXIS_TICKS, ...axisConfig.ticks } : theme.X_AXIS_TICKS,
            scale: defaults.DEFAULT_X_SCALE,
            space: axisConfig.space || (() => defaults.X_AXIS_SPACE),
            incrs: axisConfig.incrs || (() => defaults.X_AXIS_INCRS.map((i) => i * (config.chart.timeMultiplier || defaults.TIME_MULTIPLIER))),
            side: 2,
            stroke: axisConfig.stroke || (() => theme.AXIS_STROKE),
        });
    }
    Object.assign(axis, {
        gap: (_b = axisConfig.gap) !== null && _b !== void 0 ? _b : defaults.Y_AXIS_TICK_GAP,
        size: (0, common_1.asFn)(axisConfig.size) || defaults.Y_AXIS_SIZE,
        values: axisConfig.values || getNumericValueFormatter(axisConfig),
        scale: axisConfig.scale || defaults.DEFAULT_Y_SCALE,
        getFormatter: () => (0, exports.getDefaultNumberFormatter)(typeof axisConfig.precision === 'number' ? axisConfig.precision : axisConfig.precision || 'auto', ''),
        ...(0, exports.getAxisPositioning)(axisConfig.side || 'left', axisConfig.align),
    });
    if (axisConfig.space) {
        axis.space = axisConfig.space;
    }
    return axis;
}
function getRedrawOptionsForAxesUpdate(axes) {
    const options = [false, true];
    Object.values(axes).forEach((s) => {
        const uOpts = ['align', 'side', 'size', 'label', 'labelFont', 'labelGap', 'labelSize'];
        if (uOpts.some((t) => s[t] !== undefined)) {
            options[1] = true;
        }
    });
    return options;
}
exports.getRedrawOptionsForAxesUpdate = getRedrawOptionsForAxesUpdate;
function pxRatioFont(font) {
    let fontSize, fontSizeCss;
    // eslint-disable-next-line no-return-assign
    font = font.replace(/(\d+)px/, (_, p1) => (0, common_1.px)((fontSize = Math.round((fontSizeCss = Number(p1)) * window.devicePixelRatio))));
    return [font, fontSize, fontSizeCss];
}
function updateAxis(yagr, uAxis, axisConfig) {
    var _a, _b, _c;
    const upd = getAxis({
        ...axisConfig,
        font: uAxis.font,
    }, yagr);
    upd.ticks = { ...uAxis.ticks, ...upd.ticks };
    upd.grid = { ...uAxis.grid, ...upd.grid };
    upd.border = { ...uAxis.border, ...upd.border };
    upd.splits = upd.splits || uAxis.splits;
    /**
     * uPlot implicitly converts theese properties and mutate axis.font and axis.labelFont
     * but doesn't cover it with typings.
     * @see https://github.com/leeoniya/uPlot/blob/378faf6fab9b84d86fd25a5b4425dc44d486b64d/src/uPlot.js#L275
     */
    if (axisConfig.font && axisConfig.font !== ((_a = uAxis.font) === null || _a === void 0 ? void 0 : _a[0])) {
        //@ts-ignore 
        upd.font = pxRatioFont(axisConfig.font);
    }
    if (axisConfig.labelFont && axisConfig.labelFont !== ((_b = uAxis.labelFont) === null || _b === void 0 ? void 0 : _b[0])) {
        //@ts-ignore
        upd.labelFont = pxRatioFont(axisConfig.labelFont);
    }
    Object.assign(uAxis, upd);
    (_c = yagr.plugins.plotLines) === null || _c === void 0 ? void 0 : _c.update(axisConfig.plotLines, axisConfig.scale);
}
exports.updateAxis = updateAxis;
function configureAxes(yagr, config) {
    const axes = [];
    Object.entries(config.axes).forEach(([scale, axisConfig]) => {
        axes.push(getAxis({ ...axisConfig, scale }, yagr));
    });
    const x = defaults.DEFAULT_X_SCALE;
    const y = defaults.DEFAULT_Y_SCALE;
    if (!config.axes[x]) {
        axes.push(getAxis({ scale: x }, yagr));
    }
    if (!axes.find(({ scale }) => scale !== x)) {
        axes.push(getAxis({ scale: y }, yagr));
    }
    return axes;
}
exports.configureAxes = configureAxes;
