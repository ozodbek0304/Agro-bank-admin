import { Series } from 'uplot';
import { DataSeriesExtended, DataSeries, SnapToValue, ProcessingSettings } from '../types';
import { TooltipSection } from '../plugins/tooltip/types';
/**
 * Finds index of point in ranges of Y-Axis values.
 * Returns index of starting range when idx < Y <= idx next
 *
 * @param {TooltipSection} section - tooltip section
 * @param {number} value - Y value of cursor
 * @param {boolean} stickToRanges - if true, then always return index of range
 * @returns {number | null}
 */
export declare const findInRange: (section: TooltipSection, value: number, stickToRanges?: boolean) => number | null;
export declare const getSumByIdx: (seriesOptions: Series[], idx: number, scale: string) => number;
/**
 * Finds index of nearest non-null point in range of Y-Axis values
 *
 * @param {TooltipSection} section
 * @param {number} value
 * @returns {number | null}
 */
export declare const findSticky: (section: TooltipSection, value: number) => number | null;
export declare const getUnitSuffix: (value: number) => [number, string];
export declare function toFixed(num: number, fixed: number): string | number;
/**
 * Finds nearest non-null value's index in data series by given direction
 *
 * @param {DataSeriesExtended} data - Series data
 * @param {Series} series - Series options
 * @param {number} idx - cursor index
 * @param {SnapToValue | false} defaultSnapTo - default value for direction
 * @param {unknown} skipValue - value to skip
 * @returns {number}
 */
export declare function findDataIdx(data: DataSeriesExtended, series: Series, idx: number, defaultSnapTo?: SnapToValue | false, skipValue?: unknown): number;
export declare const genId: () => string;
/**
 * Processing data series to:
 *  1. Find missing data and interpolate these points
 *  2. Find string special values to convert them to nulls
 *
 * @param {DataSeriesExtended[]} series
 * @param {number[]} timeline
 * @param {ProcessingSettings} settings
 * @returns {DataSeries[]}
 */
export declare const preprocess: (series: DataSeriesExtended[], timeline: number[], settings: ProcessingSettings) => DataSeries[];
export declare const exec: <T, ArgsT extends unknown[]>(s: T | ((...a: ArgsT) => T), ...args: ArgsT) => T;
export declare function debounce<T extends Array<unknown> = []>(func: (...args: T) => void, timeout?: number): (...args: T) => void;
export declare const px: (x: number) => string;
export declare const html: (tag: string, attrs?: Record<string, string | Record<string, string>>, content?: string | HTMLElement) => HTMLElement;
type Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]];
type Join<K, P> = K extends string | number ? P extends string | number ? `${K}${'' extends P ? '' : '.'}${P}` : never : never;
export type Paths<T, D extends number = 10> = [D] extends [never] ? never : T extends object ? {
    [K in keyof T]-?: K extends string | number ? `${K}` | Join<K, Paths<T[K], Prev[D]>> : never;
}[keyof T] : '';
export declare function get(obj: object, key: string): object;
export declare function deepIsEqual(a: unknown, b: unknown): boolean;
export declare function asFn<T>(t: T): (T & Function) | (T & undefined) | (() => T);
export declare function asPlain<T>(t: T): T extends (...args: any[]) => any ? ReturnType<T> : T;
export declare function isNil(v: unknown): v is null | undefined;
export declare function inBetween(value: number, start: number, end: number): number;
export {};
