"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSerieFocusColors = exports.getFocusedColor = void 0;
const DEFAULT_SHADE_COLOR = [0, 0, 0, 0.6];
/**
 * This class implements:
 *  - color parsing from RGBA, HEX or CSS color name
 *  - linear shade/lighten @see https://github.com/PimpTrizkit/PJs/wiki/12.-Shade,-Blend-and-Convert-a-Web-Color-(pSBC.js)#stackoverflow-archive-begin
 */
class ColorParser {
    static parseRgba(rgbaColor) {
        const m = rgbaColor.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,?\s*(\d+\.?\d*)?\s*\)/);
        return m ? [m[1], m[2], m[3], m[4] || 1].map(Number) : null;
    }
    parse(color = '000') {
        const isVar = color.startsWith('var(--');
        let res = color, pure = true, prop;
        const ctx = this.context;
        const pColor = ctx.style.color;
        if (isVar || color.startsWith('--')) {
            pure = false;
            prop = isVar ? color.slice(4, -1) : color;
        }
        else if (!color.startsWith('#') && !color.startsWith('rgb')) {
            ctx.style.color = color;
            prop = 'color';
            pure = false;
        }
        res = pure ? res : getComputedStyle(ctx).getPropertyValue(prop);
        ctx.style.color = pColor;
        return res;
    }
    setContext(context) {
        this.context = context;
    }
    rgba(color) {
        return `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`;
    }
    toRgba(color, fallbackRgba) {
        return ColorParser.parseRgba(this.parse(color)) || fallbackRgba;
    }
    shade([r, g, b, a], value) {
        const direction = value < 0;
        const tOffset = direction ? 0 : 255 * value;
        const transition = direction ? 1 + value : 1 - value;
        const _r = Math.round(r * transition + tOffset);
        const _g = Math.round(g * transition + tOffset);
        const _b = Math.round(b * transition + tOffset);
        return 'rgba(' + _r + ',' + _g + ',' + _b + ',' + a + ')';
    }
}
exports.default = ColorParser;
const getFocusedColor = (y, seriesIdx) => {
    const shift = y.utils.theme.SHIFT;
    const s = y.uplot.series[seriesIdx];
    const mainColor = ColorParser.parseRgba(s.color) || DEFAULT_SHADE_COLOR;
    return y.utils.colors.shade(mainColor, shift);
};
exports.getFocusedColor = getFocusedColor;
const getSerieFocusColors = (y, field) => {
    return (u, idx) => {
        const s = u.series[idx];
        return s._focus === false ? s.getFocusedColor(y, idx) : s[field];
    };
};
exports.getSerieFocusColors = getSerieFocusColors;
