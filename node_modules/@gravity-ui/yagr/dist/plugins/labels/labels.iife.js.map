{
  "version": 3,
  "sources": ["../../../src/YagrCore/utils/common.ts", "../../../src/plugins/labels/utils.ts", "../../../src/plugins/labels/series.ts", "../../../src/plugins/labels/plotLines.ts", "../../../src/plugins/labels/axes.ts", "../../../src/plugins/labels/labels.ts"],
  "sourcesContent": ["/* eslint-disable no-nested-ternary */\n\nimport {Series} from 'uplot';\nimport {DataSeriesExtended, DataSeries, SnapToValue, ProcessingSettings, ProcessingInterpolation} from '../types';\nimport {TooltipSection} from '../plugins/tooltip/types';\n\n/**\n * Finds index of point in ranges of Y-Axis values.\n * Returns index of starting range when idx < Y <= idx next\n *\n * @param {TooltipSection} section - tooltip section\n * @param {number} value - Y value of cursor\n * @param {boolean} stickToRanges - if true, then always return index of range\n * @returns {number | null}\n */\nexport const findInRange = (section: TooltipSection, value: number, stickToRanges = true): number | null => {\n    const positive = value >= 0;\n    let max = -Infinity,\n        maxIdx = null;\n    let min = Infinity,\n        minIdx = null;\n\n    const diffs: Array<number | null> = [];\n    let result: number | null = null;\n\n    for (let r = section.rows.length - 1; r >= 0; r--) {\n        const row = section.rows[r];\n        const {displayY: y, rowIdx} = row;\n\n        let diff: number | null;\n\n        if (y !== null) {\n            if (y > max) {\n                max = y;\n                maxIdx = row.rowIdx;\n            }\n\n            if (y < min) {\n                min = y;\n                minIdx = row.rowIdx;\n            }\n        }\n\n        if (y === null || (positive ? y < 0 : y >= 0)) {\n            diff = null;\n        } else if (positive) {\n            diff = value > y ? null : y - value;\n        } else {\n            diff = value < y ? null : Math.abs(y - value);\n        }\n\n        const currentMin = result === null ? Infinity : (diffs[result] as number);\n        const nextMin = diff === null ? currentMin : Math.min(currentMin, diff);\n\n        if ((diff !== null && currentMin === diff) || nextMin !== currentMin) {\n            result = rowIdx;\n        }\n    }\n\n    if (result === null && stickToRanges) {\n        return value >= max ? maxIdx : value <= min ? minIdx : null;\n    }\n\n    return result;\n};\n\n/* Gets sum of all values of given data index by all series */\nexport const getSumByIdx = (seriesOptions: Series[], idx: number, scale: string) => {\n    let sum = 0;\n    let i = 0;\n    while (i < seriesOptions.length) {\n        const seriesIdx = seriesOptions.length - i - 1;\n        const opts = seriesOptions[seriesIdx];\n        const seriesValues = opts.$c;\n        i += 1;\n        if (opts.scale !== scale || opts.show === false) {\n            continue;\n        }\n        const value = seriesValues[idx];\n        sum += typeof value === 'number' ? value : 0;\n    }\n    return sum;\n};\n\n/**\n * Finds index of nearest non-null point in range of Y-Axis values\n *\n * @param {TooltipSection} section\n * @param {number} value\n * @returns {number | null}\n */\nexport const findSticky = (section: TooltipSection, value: number): number | null => {\n    let nearestIndex;\n    let nearestValue;\n\n    let i = 0;\n    while (!nearestValue && i < section.rows.length) {\n        const r = section.rows[i].displayY;\n        if (r !== null) {\n            nearestIndex = i;\n            nearestValue = Math.abs(r - (value || 0));\n        }\n        i += 1;\n    }\n\n    if (!nearestValue || nearestIndex === undefined) {\n        return null;\n    }\n\n    for (i = nearestIndex + 1; i < section.rows.length; i++) {\n        const v = section.rows[i].displayY;\n\n        if (v === null) {\n            continue;\n        }\n\n        const diff = Math.abs(v - value);\n\n        if (nearestValue > diff) {\n            nearestValue = diff;\n            nearestIndex = i;\n        }\n    }\n\n    return nearestIndex;\n};\n\nexport const getUnitSuffix = (value: number): [number, string] => {\n    if (value >= 1e18) {\n        return [1e18, 'E'];\n    } else if (value >= 1e15) {\n        return [1e15, 'P'];\n    } else if (value >= 1e12) {\n        return [1e12, 'T'];\n    } else if (value >= 1e9) {\n        return [1e9, 'G'];\n    } else if (value >= 1e6) {\n        return [1e6, 'M'];\n    } else if (value >= 1e3) {\n        return [1e3, 'K'];\n    }\n    return [1, ''];\n};\n\n/* Number.toFixed() wihout rounding */\nexport function toFixed(num: number, fixed: number) {\n    if (fixed === 0) {\n        return parseInt(num as unknown as string);\n    }\n\n    if (Number.isInteger(num)) {\n        return num + '.' + '0'.repeat(fixed);\n    }\n\n    const [int, frac] = num.toString().split('.');\n    return frac.length >= fixed ? `${int}.${frac.slice(0, fixed)}` : `${int}.${frac}${'0'.repeat(fixed - frac.length)}`;\n}\n\n/**\n * Finds nearest non-null value's index in data series by given direction\n *\n * @param {DataSeriesExtended} data - Series data\n * @param {Series} series - Series options\n * @param {number} idx - cursor index\n * @param {SnapToValue | false} defaultSnapTo - default value for direction\n * @param {unknown} skipValue - value to skip\n * @returns {number}\n */\nexport function findDataIdx(\n    data: DataSeriesExtended,\n    series: Series,\n    idx: number,\n    defaultSnapTo: SnapToValue | false = 'closest',\n    skipValue: unknown = null,\n) {\n    let corL = idx,\n        corR = idx;\n\n    const direction = series.snapToValues ?? defaultSnapTo;\n\n    if (direction === false) {\n        return idx;\n    }\n\n    if (direction === 'left' || direction === 'closest') {\n        for (let i = idx - 1; i >= 0; i--) {\n            if (data[i] !== skipValue) {\n                corL = i;\n                break;\n            }\n        }\n    }\n\n    if (direction === 'right' || direction === 'closest') {\n        for (let i = idx + 1; i < data.length; i++) {\n            if (data[i] !== skipValue) {\n                corR = i;\n                break;\n            }\n        }\n    }\n\n    if (direction === 'left') {\n        return corL;\n    }\n    if (direction === 'right') {\n        return corR;\n    }\n\n    return corR - idx > idx - corL ? corL : corR;\n}\n\n/*\n * Interpolation function\n */\nconst interpolateImpl = (\n    timeline: number[],\n    y1: number | null,\n    y2: number | null,\n    x1: number,\n    x2: number,\n    xIdx: number,\n    iGroup: number[],\n    type: ProcessingInterpolation['type'] | number = 'linear',\n) => {\n    let result = null;\n    const x = timeline[xIdx];\n\n    switch (type) {\n        case 'linear': {\n            if (y1 === null || y2 === null) {\n                return null;\n            }\n\n            result = y1 + ((x - x1) * (y2 - y1)) / (x2 - x1);\n\n            if (isNaN(result) || Math.abs(result) === Infinity) {\n                result = null;\n            }\n            break;\n        }\n        case 'previous': {\n            result = y1;\n            break;\n        }\n        case 'next': {\n            result = y2;\n            break;\n        }\n        case 'left': {\n            result = iGroup[iGroup.length - 1] === timeline.length - 1 || y2 === null ? null : y1;\n            break;\n        }\n        case 'right': {\n            result = iGroup[0] === 0 ? null : y2;\n            break;\n        }\n        case 'closest': {\n            const lD = Math.abs(x1 - timeline[xIdx]);\n            const rD = Math.abs(x2 - timeline[xIdx]);\n            result = lD < rD ? y1 : y2;\n            break;\n        }\n        default: {\n            result = type;\n        }\n    }\n    return result;\n};\n\nexport const genId = () => Math.random().toString(36).substr(2, 9).replace(/^\\d+/, '');\n\n/**\n * Processing data series to:\n *  1. Find missing data and interpolate these points\n *  2. Find string special values to convert them to nulls\n *\n * @param {DataSeriesExtended[]} series\n * @param {number[]} timeline\n * @param {ProcessingSettings} settings\n * @returns {DataSeries[]}\n */\nexport const preprocess = (\n    series: DataSeriesExtended[],\n    timeline: number[],\n    settings: ProcessingSettings,\n): DataSeries[] => {\n    const result = [];\n    const nullValues = settings.nullValues || {};\n    const interpolation = settings.interpolation;\n    for (let sIdx = 0; sIdx < series.length; sIdx++) {\n        const line = series[sIdx];\n        const resultLine = [];\n\n        let iGroup = [];\n        let y1 = null,\n            y2 = null,\n            x1,\n            x2;\n\n        for (let idx = 0; idx < line.length; idx++) {\n            let val = line[idx];\n\n            if (interpolation && val === interpolation.value) {\n                iGroup.push(idx);\n                continue;\n            }\n\n            if (nullValues[val as string]) {\n                val = null;\n            }\n\n            if (iGroup.length) {\n                y2 = val;\n                x2 = timeline[idx];\n                for (const iIdx of iGroup) {\n                    resultLine[iIdx] = interpolateImpl(\n                        timeline,\n                        y1 as number | null,\n                        y2 as number | null,\n                        x1 || timeline[0],\n                        x2 || timeline[timeline.length - 1],\n                        iIdx,\n                        iGroup,\n                        interpolation && interpolation.type,\n                    );\n                }\n                iGroup = [];\n            }\n\n            y1 = val;\n            x1 = timeline[idx];\n            resultLine.push(val);\n        }\n\n        y2 = null;\n\n        if (iGroup.length) {\n            for (const iIdx of iGroup) {\n                resultLine.push(\n                    interpolateImpl(\n                        timeline,\n                        y1 as number | null,\n                        y2 as number | null,\n                        x1 || timeline[0],\n                        x2 || timeline[timeline.length - 1],\n                        iIdx,\n                        iGroup,\n                        interpolation && interpolation.type,\n                    ),\n                );\n            }\n        }\n        result.push(resultLine);\n    }\n\n    return result as DataSeries[];\n};\n\nexport const exec = <T, ArgsT extends unknown[]>(s: T | ((...a: ArgsT) => T), ...args: ArgsT) => {\n    return typeof s === 'function' ? (s as (...a: ArgsT) => T)(...args) : s;\n};\n\nexport function debounce<T extends Array<unknown> = []>(func: (...args: T) => void, timeout = 300) {\n    let timer: ReturnType<typeof setTimeout>;\n\n    return (...args: T) => {\n        clearTimeout(timer);\n        timer = setTimeout(() => func(...args), timeout);\n    };\n}\n\nexport const px = (x: number) => x + 'px';\nexport const html = (\n    tag: string,\n    attrs: Record<string, string | Record<string, string>> = {},\n    content?: string | HTMLElement,\n) => {\n    const el = document.createElement(tag);\n    Object.keys(attrs).forEach((key) => {\n        const attr = attrs[key];\n        el.setAttribute(\n            key,\n            typeof attr === 'object'\n                ? Object.entries(attr)\n                      .map(([a, b]) => `${a}:${b}`)\n                      .join(';')\n                : attr,\n        );\n    });\n    if (content) {\n        if (typeof content === 'string') {\n            el.innerHTML = content;\n        } else {\n            el.appendChild(content);\n        }\n    }\n    return el;\n};\n\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]];\ntype Join<K, P> = K extends string | number\n    ? P extends string | number\n        ? `${K}${'' extends P ? '' : '.'}${P}`\n        : never\n    : never;\nexport type Paths<T, D extends number = 10> = [D] extends [never]\n    ? never\n    : T extends object\n    ? {\n          [K in keyof T]-?: K extends string | number ? `${K}` | Join<K, Paths<T[K], Prev[D]>> : never;\n      }[keyof T]\n    : '';\n\nexport function get(obj: object, key: string) {\n    return key.split('.').reduce((acc, key) => Object.getOwnPropertyDescriptor(acc, key)?.value ?? {}, obj);\n}\n\nexport function deepIsEqual(a: unknown, b: unknown): boolean {\n    if (typeof a !== typeof b) {\n        return false;\n    }\n\n    if (typeof a === 'function' || typeof b === 'function') {\n        a = (a as Function).toString();\n        b = (b as Function).toString();\n    }\n\n    if (typeof a !== 'object' || isNil(a) || isNil(b)) {\n        return a === b;\n    }\n\n    const aObject = a as Record<string, unknown>;\n    const bObject = b as Record<string, unknown>;\n\n    const aKeys = Object.keys(aObject);\n    const bKeys = Object.keys(bObject);\n\n    if (aKeys.length !== bKeys.length) {\n        return false;\n    }\n\n    for (const key of aKeys) {\n        if (!bObject.hasOwnProperty(key)) {\n            return false;\n        }\n\n        if (!deepIsEqual(aObject[key], bObject[key])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function asFn<T>(t: T) {\n    return typeof t === 'function' ? t : typeof t === 'undefined' ? t : () => t;\n}\n\nexport function asPlain<T>(t: T): T extends (...args: any[]) => any ? ReturnType<T> : T {\n    return typeof t === 'function' ? t() : t;\n}\n\nexport function isNil(v: unknown): v is null | undefined {\n    return v === null || v === undefined;\n}\n\nexport function inBetween(value: number, start: number, end: number) {\n    return value >= start && value <= end ? value : value < start ? start : end;\n}\n", "/* eslint-disable complexity, @typescript-eslint/no-loop-func, no-nested-ternary */\n\nimport type {AxisOptions} from '../../types';\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {html, isNil, px} from '../../YagrCore/utils/common';\nimport {AxisLabel, Clear, PointLabel} from './types';\n\nexport const defaultPositionTop = (u: uPlot, x: number, y: number, scale: string) => {\n    return [u.valToPos(x, 'x'), u.valToPos(y, scale) - 15];\n};\n\nexport const getId = () => (x: number) => String(x);\n\nexport function renderAxisLabel({\n    yagr,\n    scaleKey,\n    x,\n    y,\n    className = '',\n    render,\n    onRender,\n    onDestroy,\n    label,\n}: {\n    yagr: Yagr;\n    scaleKey: string;\n    x: number;\n    y: number;\n    label: AxisLabel;\n    className?: string;\n    render?: AxisLabel['render'];\n    onRender?: (e: HTMLElement) => void;\n    onDestroy?: (e: HTMLElement) => void;\n}) {\n    const over = yagr.root.querySelector('.u-over') as HTMLElement;\n\n    if (render) {\n        return render(yagr, x, y, label);\n    }\n\n    const labelValue = label.label ? (typeof label.label === 'function' ? label.label(label) : label.label) : '';\n\n    const div = html(\n        'div',\n        {\n            class: `yagr-label ${className}`,\n            style: {\n                visibility: 'hidden',\n            },\n        },\n        labelValue ?? label.value.toString(),\n    );\n\n    over.append(div);\n\n    if (scaleKey === 'x') {\n        div.style.top = px(y - div.clientHeight / 2);\n        div.style.left = px(x - div.clientWidth / 2);\n    } else {\n        if (yagr.config.axes[scaleKey]?.side === 'right') {\n            div.style.left = px(x - div.clientWidth / 2);\n        } else {\n            div.style.left = px(x);\n        }\n        div.style.top = px(y - div.clientHeight / 2);\n    }\n\n    div.style.visibility = 'visible';\n\n    onRender && onRender(div);\n\n    return () => {\n        onDestroy && onDestroy(div);\n        div.remove();\n    };\n}\n\nexport function renderPointLabel({\n    yagr,\n    label,\n    x,\n    y,\n    className = '',\n    shifts = {},\n    onRender,\n    onDestroy,\n}: {\n    yagr: Yagr;\n    label: string;\n    x: number;\n    y: number;\n    onRender?: (e: HTMLElement) => void;\n    onDestroy?: (e: HTMLElement) => void;\n    className?: string;\n    shifts?: {top?: number; left?: number};\n}) {\n    const over = yagr.root.querySelector('.u-over') as HTMLElement;\n    const div = html(\n        'div',\n        {\n            class: `yagr-label ${className}`,\n            style: {\n                top: px(y + (shifts.top || 0)),\n                left: px(x + (shifts.left || 0)),\n            },\n        },\n        label,\n    );\n\n    over.append(div);\n\n    onRender && onRender(div);\n\n    div.style.left = px(Number(div.style.left.replace('px', '')) - div.clientWidth / 2);\n\n    return () => {\n        div.remove();\n        onDestroy && onDestroy(div);\n    };\n}\n\nexport function drawLabelOnPoint(\n    yagr: Yagr,\n    serieIdx: number,\n    xIdx: number,\n    scaleKey: string | undefined,\n    labelOptions: PointLabel | undefined,\n    xAxisFormatter: ReturnType<Required<AxisOptions>['getFormatter']>,\n    selfAxisFormatter: ReturnType<Required<AxisOptions>['getFormatter']>,\n    onDraw?: (clear: Clear, label: string, serieIdx: number) => void,\n) {\n    const x = yagr.uplot.data[0][xIdx];\n    const y = yagr.uplot.data[serieIdx][xIdx];\n\n    if (isNil(y) || !scaleKey || !labelOptions) {\n        return;\n    }\n\n    const valX = xAxisFormatter(x);\n    const valY = selfAxisFormatter(y);\n    const label =\n        typeof labelOptions.label === 'function'\n            ? labelOptions.label(x, y, xIdx)\n            : labelOptions.label || `(${valX}, ${valY})`;\n\n    if (labelOptions.render) {\n        const clear = labelOptions.render(yagr, serieIdx, xIdx, scaleKey, labelOptions);\n\n        clear && onDraw && onDraw(clear, label ?? '', serieIdx);\n        return;\n    }\n\n    if (!label || isNil(y)) {\n        return;\n    }\n\n    const [xP, yP] = labelOptions.position\n        ? labelOptions.position(x, y)\n        : defaultPositionTop(yagr.uplot, x, y, scaleKey);\n\n    const prev = yagr.uplot.data[serieIdx][xIdx - 1];\n    const next = yagr.uplot.data[serieIdx][xIdx + 1];\n    const className =\n        prev !== null && prev !== undefined && next !== null && next !== undefined\n            ? y < prev && y < next\n                ? '_bottom'\n                : '_top'\n            : '_top';\n\n    let clear = () => {};\n    if (labelOptions.show !== false) {\n        clear = renderPointLabel({\n            yagr,\n            label,\n            x: xP,\n            y: yP,\n            className,\n            onRender: labelOptions.onRender,\n            onDestroy: labelOptions.onDestroy,\n        });\n    }\n    onDraw && onDraw(clear, label, serieIdx);\n}\n", "/* eslint-disable complexity, @typescript-eslint/no-loop-func, no-nested-ternary */\n\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {isNil} from '../../YagrCore/utils/common';\nimport {Clear, LabelsOptions} from './types';\nimport {drawLabelOnPoint, getId} from './utils';\n\ntype StoredPointLabel = {idx: number; label: string | null | undefined};\n\n/**\n * Sets up hooks for labels rending on series draw, additionally sets up focus state for series\n * to show/hide labels on series focus\n */\nexport function seriesDrawBasedLabels(yagr: Yagr, hooks: uPlot.Hooks.Arrays, options: LabelsOptions) {\n    const clears: Record<number, Clear[]> = {};\n    const cursorClears: Clear[] = [];\n    const focusClears: Clear[] = [];\n    const labels: Record<number, {idx: number; label: string}[]> = {};\n\n    hooks.drawClear = hooks.drawClear || [];\n    hooks.draw = hooks.draw || [];\n    hooks.setCursor = hooks.setCursor || [];\n    hooks.setSeries = hooks.setSeries || [];\n\n    function drawLabelsOnSeries(u: uPlot, seriesIdxs?: number[]) {\n        const sIdxs = [];\n\n        if (seriesIdxs) {\n            sIdxs.push(...seriesIdxs);\n        } else {\n            for (let sIdx = 1; sIdx < u.series.length; sIdx++) {\n                const series = u.series[sIdx];\n\n                if (options.scales?.draw) {\n                    const scaleKey = series.scale;\n                    if (scaleKey && options.scales?.draw[scaleKey]) {\n                        sIdxs.push(sIdx);\n                    }\n                }\n\n                if (options.series?.draw) {\n                    if (options.series?.draw[series.id]) {\n                        sIdxs.push(sIdx);\n                    }\n                }\n            }\n        }\n\n        for (const sIdx of sIdxs) {\n            const series = u.series[sIdx] as Required<uPlot.Series>;\n            if (!series.show || series._focus === false) {\n                continue;\n            }\n            const {scale = 'y', min, max} = series;\n            const tSeries = u.series[0] as Required<uPlot.Series>;\n            const labelOptions = options.series?.draw?.[series.id] || options.scales?.draw?.[series.scale];\n\n            const selfAxisFormatter = (u.axes.find((a) => a.scale === scale)?.getFormatter || getId)(max - min);\n            const xAxisFormatter = (u.axes.find((a) => a.scale === 'x')?.getFormatter || getId)(\n                tSeries.max - tSeries.min,\n            );\n\n            let idx = 0;\n            while (idx < u.data[0].length) {\n                drawLabelOnPoint(\n                    yagr,\n                    sIdx,\n                    idx,\n                    scale,\n                    labelOptions,\n                    xAxisFormatter,\n                    selfAxisFormatter,\n                    (clear, label) => {\n                        clears[sIdx] = clears[sIdx] || [];\n                        clears[sIdx].push(clear);\n                        labels[sIdx] = labels[sIdx] || [];\n                        labels[sIdx].push({idx, label});\n                    },\n                );\n                idx++;\n            }\n        }\n    }\n\n    function drawLabelsOnCursor(u: uPlot, idx: number) {\n        const sIdxs = [];\n\n        for (let sIdx = 1; sIdx < u.series.length; sIdx++) {\n            const series = u.series[sIdx];\n\n            if (options.scales?.cursor) {\n                const scaleKey = series.scale;\n                if (scaleKey && options.scales.cursor[scaleKey]) {\n                    sIdxs.push(sIdx);\n                }\n            }\n\n            if (options.series?.cursor) {\n                if (options.series.cursor[series.id]) {\n                    sIdxs.push(sIdx);\n                }\n            }\n        }\n\n        for (const sIdx of sIdxs) {\n            const series = u.series[sIdx] as Required<uPlot.Series>;\n            if (!series.show || series._focus === false) {\n                continue;\n            }\n            const {scale = 'y', min, max} = series;\n            const tSeries = u.series[0] as Required<uPlot.Series>;\n            const labelOptions = options.series?.cursor?.[series.id] || options.scales?.cursor?.[series.scale];\n\n            const selfAxisFormatter = (u.axes.find((a) => a.scale === scale)?.getFormatter || getId)(max - min);\n            const xAxisFormatter = (u.axes.find((a) => a.scale === 'x')?.getFormatter || getId)(\n                tSeries.max - tSeries.min,\n            );\n\n            drawLabelOnPoint(yagr, sIdx, idx, scale, labelOptions, xAxisFormatter, selfAxisFormatter, (clear) => {\n                cursorClears.push(clear);\n            });\n        }\n    }\n\n    if (options.series?.focus) {\n        hooks.setSeries.push((u, sIdx, opts) => {\n            if (sIdx === null) {\n                focusClears?.forEach((fn) => fn());\n                return;\n            }\n            const series = u.series[sIdx] as Required<uPlot.Series>;\n            const labelOptions = options.series?.focus?.[series.id];\n\n            if (!labelOptions) {\n                focusClears?.forEach((fn) => fn());\n                return;\n            }\n\n            if (series.show && opts.focus === true) {\n                const {scale = 'y', min, max} = series;\n                const tSeries = u.series[0] as Required<uPlot.Series>;\n\n                const selfAxisFormatter = (u.axes.find((a) => a.scale === scale)?.getFormatter || getId)(max - min);\n                const xAxisFormatter = (u.axes.find((a) => a.scale === 'x')?.getFormatter || getId)(\n                    tSeries.max - tSeries.min,\n                );\n\n                let idx = 0;\n                while (idx < u.data[0].length) {\n                    drawLabelOnPoint(\n                        yagr,\n                        sIdx,\n                        idx,\n                        scale,\n                        labelOptions,\n                        xAxisFormatter,\n                        selfAxisFormatter,\n                        (clear) => {\n                            focusClears.push(clear);\n                        },\n                    );\n                    idx++;\n                }\n            } else {\n                focusClears?.forEach((fn) => fn());\n            }\n        });\n    }\n\n    if (options.scales?.draw || options.series?.draw) {\n        hooks.draw.push((u) => {\n            drawLabelsOnSeries(u);\n        });\n        hooks.drawClear.push(() => {\n            Object.values(clears).forEach((fns) => fns.forEach((fn) => fn()));\n            Object.keys(clears).forEach((k) => delete clears[Number(k)]);\n        });\n    }\n\n    if (options.scales?.cursor || options.series?.cursor) {\n        hooks.setCursor.push((u) => {\n            cursorClears.forEach((fn) => fn());\n            const {idx} = u.cursor;\n            if (!isNil(idx)) {\n                drawLabelsOnCursor(u, idx);\n            }\n        });\n    }\n\n    return {\n        getSeriesLabels: () => labels,\n        getCurrentSeriesLabels: (): Record<number, StoredPointLabel | undefined> => {\n            const cursor = yagr.uplot.cursor;\n\n            if (cursor.idx === null) {\n                return {};\n            }\n\n            return Object.entries(labels).reduce((acc, [sIdx, labels]) => {\n                acc[Number(sIdx)] = labels.find((l) => l.idx === cursor.idx);\n                return acc;\n            }, {} as Record<number, StoredPointLabel | undefined>);\n        },\n    };\n}\n", "import type {PlotLineConfig, PerScale} from '../../types';\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {isNil} from '../../YagrCore/utils/common';\nimport {Clear, LabelsOptions, PlotLabel} from './types';\nimport {defaultPositionTop, renderPointLabel} from './utils';\n\ntype StoredPlotLabel = {band: PlotLineConfig; label: string | null | undefined};\n\n/**\n * Sets up hooks for labels rending on plotLines draw\n */\nexport function plotLinesDrawBasedLabels(yagr: Yagr, hooks: uPlot.Hooks.Arrays, options: LabelsOptions) {\n    let drawClears: Clear[] = [];\n    let cursorClears: Clear[] = [];\n\n    hooks.draw = hooks.draw || [];\n    hooks.drawClear = hooks.drawClear || [];\n    hooks.setCursor = hooks.setCursor || [];\n\n    function renderLabelsOnPlotLines(\n        psOptions: PerScale<PlotLabel>,\n        clears: Clear[],\n        predicate?: (pl: PlotLineConfig) => boolean,\n    ) {\n        const bands: {\n            bands: PlotLineConfig[];\n            labelOptions: PlotLabel;\n        }[] = [];\n\n        for (const [scaleName, labelOptions] of Object.entries(psOptions || {})) {\n            const foundBands = (yagr.plugins.plotLines?.get() || []).filter((p) => {\n                return p.scale === scaleName;\n            });\n\n            foundBands.length && bands.push({bands: foundBands, labelOptions});\n        }\n\n        if (!bands.length) {\n            return;\n        }\n\n        bands.forEach(({bands: plotLines, labelOptions}) => {\n            plotLines.forEach((band) => {\n                if (predicate?.(band) === false) {\n                    return;\n                }\n\n                const [x, y] =\n                    band.scale === 'x'\n                        ? [Array.isArray(band.value) ? band.value[0] : band.value, yagr.uplot.posToVal(0, 'y')]\n                        : [yagr.uplot.posToVal(0, 'x'), Array.isArray(band.value) ? band.value[0] : band.value];\n\n                const [xP, yP] = labelOptions.position\n                    ? labelOptions.position(x, y)\n                    : defaultPositionTop(yagr.uplot, x, y, band.scale || 'y');\n\n                const label =\n                    typeof labelOptions.label === 'function'\n                        ? labelOptions.label(band)\n                        : labelOptions.label || band.label;\n\n                if (labelOptions.render) {\n                    const clear = labelOptions.render(yagr, band, xP, yP, labelOptions);\n                    clear && drawClears.push(clear);\n                    return;\n                }\n\n                if (label && labelOptions.show !== false) {\n                    clears.push(\n                        renderPointLabel({\n                            yagr,\n                            label,\n                            x: xP,\n                            y: yP,\n                        }),\n                    );\n                }\n            });\n        });\n    }\n\n    if (options.plotLines?.cursor) {\n        hooks.setCursor.push((u) => {\n            cursorClears.forEach((fn) => fn());\n            cursorClears = [];\n\n            const {left, top} = u.cursor;\n\n            if (!isNil(left) && !isNil(top) && left >= 0 && top >= 0) {\n                renderLabelsOnPlotLines(options.plotLines?.cursor!, cursorClears, (band: PlotLineConfig) => {\n                    const x = yagr.uplot.posToVal(left, 'x');\n                    const [x1, x2] = Array.isArray(band.value) ? band.value : [band.value, band.value];\n                    const [y1, y2] = Array.isArray(band.value)\n                        ? [band.value[0], band.value[1]]\n                        : [band.value, band.value];\n\n                    if (band.scale === 'x') {\n                        if (x >= x1 && x <= x2) {\n                            return true;\n                        }\n                    } else {\n                        const y = yagr.uplot.posToVal(top, band.scale!);\n\n                        if (y >= y1 && y <= y2) {\n                            return true;\n                        }\n                    }\n\n                    return false;\n                });\n            }\n        });\n    }\n\n    if (options.plotLines?.draw) {\n        hooks.draw.push(() => {\n            renderLabelsOnPlotLines(options.plotLines?.draw!, drawClears);\n        });\n\n        hooks.drawClear.push(() => {\n            drawClears.forEach((fn) => fn());\n            drawClears = [];\n        });\n    }\n\n    return {\n        getPlotLinesLabels: () => {\n            const bands = yagr.plugins.plotLines?.get() || [];\n\n            return bands\n                .filter((band) => {\n                    return options.plotLines?.draw?.[band.scale || 'y'];\n                })\n                .map((band) => {\n                    return {band, label: options.plotLines?.draw?.[band.scale || 'y']?.label || band.label};\n                });\n        },\n        getCurrentPlotLinesLabels: () => {\n            const cursor = yagr.uplot.cursor;\n\n            if (!cursor.left || !cursor.top || cursor.left < 0 || cursor.top < 0) {\n                return [];\n            }\n\n            const labels: StoredPlotLabel[] = [];\n\n            const {left, top} = cursor;\n            const x = yagr.uplot.posToVal(left, 'x');\n\n            yagr.plugins.plotLines?.get().forEach((band) => {\n                const [x1, x2] = Array.isArray(band.value) ? band.value : [band.value, band.value];\n                const [y1, y2] = Array.isArray(band.value) ? [band.value[0], band.value[1]] : [band.value, band.value];\n\n                if (band.scale === 'x') {\n                    if (x >= x1 && x <= x2) {\n                        labels.push({band, label: band.label});\n                    }\n                } else {\n                    const y = yagr.uplot.posToVal(top, band.scale!);\n\n                    if (y >= y1 && y <= y2) {\n                        labels.push({band, label: band.label});\n                    }\n                }\n            });\n\n            return labels;\n        },\n    };\n}\n", "import type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {AxisLabel, Clear, LabelsOptions} from './types';\nimport {renderAxisLabel} from './utils';\nimport {isNil} from '../../YagrCore/utils/common';\n\nexport function axisDrawBasedLabels(yagr: Yagr, hooks: uPlot.Hooks.Arrays, options: LabelsOptions) {\n    let pointsClears: Clear[] = [];\n\n    function onDrawAxes(u: uPlot) {\n        pointsClears.forEach((fn) => fn());\n        pointsClears = [];\n\n        Object.entries(options.axes || {}).forEach(([scaleKey, opts]) => {\n            const axis = u.axes.find((a) => a.scale === scaleKey);\n\n            if (!axis) {\n                return;\n            }\n\n            opts.forEach((opt) => {\n                let x, y;\n                if (scaleKey === 'x') {\n                    x = u.valToPos(opt.value, 'x');\n                    y = u.valToPos(0, 'y');\n                } else {\n                    if (yagr.config.axes[scaleKey]?.side === 'right') {\n                        x = u.valToPos(u.data[0][u.data[0].length - 1], 'x');\n                    } else {\n                        x = u.valToPos(u.data[0][0], 'x');\n                    }\n                    y = u.valToPos(opt.value, 'y');\n                }\n\n                pointsClears.push(\n                    renderAxisLabel({\n                        yagr,\n                        scaleKey,\n                        x,\n                        y,\n                        render: opt.render,\n                        label: opt,\n                        className: opt.className,\n                        onRender: opt.onRender,\n                        onDestroy: opt.onDestroy,\n                    }),\n                );\n            });\n        });\n    }\n\n    hooks.drawAxes = hooks.drawAxes || [];\n\n    if (options.axes) {\n        hooks.drawAxes.push(onDrawAxes);\n    }\n\n    return {\n        getAxisLabels() {\n            return options.axes || {};\n        },\n        getCurrentAxisLabels(proximity: {x: number; y: number}) {\n            const cursor = yagr.uplot.cursor;\n\n            if (!cursor) {\n                return {};\n            }\n\n            const {left, top} = cursor;\n            if (isNil(left) || isNil(top) || left < 0 || top < 0) {\n                return {};\n            }\n\n            const labels: Record<string, AxisLabel[]> = {};\n\n            Object.entries(options.axes || {}).forEach(([scaleKey, opts]) => {\n                const axis = yagr.uplot.axes.find((a) => a.scale === scaleKey);\n\n                if (!axis) {\n                    return;\n                }\n\n                opts.forEach((opt) => {\n                    let x, y;\n                    if (scaleKey === 'x') {\n                        x = yagr.uplot.posToVal(left, 'x');\n\n                        if (Math.abs(x - opt.value) < proximity.x) {\n                            labels[scaleKey] = labels[scaleKey] || [];\n                            labels[scaleKey].push(opt);\n                        }\n                    } else {\n                        y = yagr.uplot.posToVal(top, 'y');\n\n                        if (Math.abs(y - opt.value) < proximity.y) {\n                            labels[scaleKey] = labels[scaleKey] || [];\n                            labels[scaleKey].push(opt);\n                        }\n                    }\n                });\n            });\n\n            return labels;\n        },\n    };\n}\n", "import type {YagrPlugin} from '../../types';\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {LabelsOptions} from './types';\nimport {seriesDrawBasedLabels} from './series';\nimport {plotLinesDrawBasedLabels} from './plotLines';\nimport {axisDrawBasedLabels} from './axes';\n\ntype SeriesMethods = ReturnType<typeof seriesDrawBasedLabels>;\ntype PlotLinesMethods = ReturnType<typeof plotLinesDrawBasedLabels>;\ntype AxisMethods = ReturnType<typeof axisDrawBasedLabels>;\n\nexport type LabelsPluginMethods = SeriesMethods & PlotLinesMethods & AxisMethods;\n\nexport default function YagrLabelsPlugin(options: LabelsOptions): YagrPlugin<LabelsPluginMethods> {\n    return (yagr: Yagr) => {\n        const hooks: uPlot.Hooks.Arrays = {};\n\n        return {\n            ...seriesDrawBasedLabels(yagr, hooks, options),\n            ...plotLinesDrawBasedLabels(yagr, hooks, options),\n            ...axisDrawBasedLabels(yagr, hooks, options),\n\n            uplot: {\n                hooks,\n            },\n        };\n    };\n}\n\nif (typeof window !== 'undefined') {\n    Object.assign(window, {YagrLabelsPlugin});\n}\n"],
  "mappings": "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",
  "names": ["clear", "labels"]
}
