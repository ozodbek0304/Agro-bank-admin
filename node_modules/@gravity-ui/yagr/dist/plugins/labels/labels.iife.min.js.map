{
  "version": 3,
  "sources": ["../../../src/YagrCore/utils/common.ts", "../../../src/plugins/labels/utils.ts", "../../../src/plugins/labels/series.ts", "../../../src/plugins/labels/plotLines.ts", "../../../src/plugins/labels/axes.ts", "../../../src/plugins/labels/labels.ts"],
  "sourcesContent": ["/* eslint-disable no-nested-ternary */\n\nimport {Series} from 'uplot';\nimport {DataSeriesExtended, DataSeries, SnapToValue, ProcessingSettings, ProcessingInterpolation} from '../types';\nimport {TooltipSection} from '../plugins/tooltip/types';\n\n/**\n * Finds index of point in ranges of Y-Axis values.\n * Returns index of starting range when idx < Y <= idx next\n *\n * @param {TooltipSection} section - tooltip section\n * @param {number} value - Y value of cursor\n * @param {boolean} stickToRanges - if true, then always return index of range\n * @returns {number | null}\n */\nexport const findInRange = (section: TooltipSection, value: number, stickToRanges = true): number | null => {\n    const positive = value >= 0;\n    let max = -Infinity,\n        maxIdx = null;\n    let min = Infinity,\n        minIdx = null;\n\n    const diffs: Array<number | null> = [];\n    let result: number | null = null;\n\n    for (let r = section.rows.length - 1; r >= 0; r--) {\n        const row = section.rows[r];\n        const {displayY: y, rowIdx} = row;\n\n        let diff: number | null;\n\n        if (y !== null) {\n            if (y > max) {\n                max = y;\n                maxIdx = row.rowIdx;\n            }\n\n            if (y < min) {\n                min = y;\n                minIdx = row.rowIdx;\n            }\n        }\n\n        if (y === null || (positive ? y < 0 : y >= 0)) {\n            diff = null;\n        } else if (positive) {\n            diff = value > y ? null : y - value;\n        } else {\n            diff = value < y ? null : Math.abs(y - value);\n        }\n\n        const currentMin = result === null ? Infinity : (diffs[result] as number);\n        const nextMin = diff === null ? currentMin : Math.min(currentMin, diff);\n\n        if ((diff !== null && currentMin === diff) || nextMin !== currentMin) {\n            result = rowIdx;\n        }\n    }\n\n    if (result === null && stickToRanges) {\n        return value >= max ? maxIdx : value <= min ? minIdx : null;\n    }\n\n    return result;\n};\n\n/* Gets sum of all values of given data index by all series */\nexport const getSumByIdx = (seriesOptions: Series[], idx: number, scale: string) => {\n    let sum = 0;\n    let i = 0;\n    while (i < seriesOptions.length) {\n        const seriesIdx = seriesOptions.length - i - 1;\n        const opts = seriesOptions[seriesIdx];\n        const seriesValues = opts.$c;\n        i += 1;\n        if (opts.scale !== scale || opts.show === false) {\n            continue;\n        }\n        const value = seriesValues[idx];\n        sum += typeof value === 'number' ? value : 0;\n    }\n    return sum;\n};\n\n/**\n * Finds index of nearest non-null point in range of Y-Axis values\n *\n * @param {TooltipSection} section\n * @param {number} value\n * @returns {number | null}\n */\nexport const findSticky = (section: TooltipSection, value: number): number | null => {\n    let nearestIndex;\n    let nearestValue;\n\n    let i = 0;\n    while (!nearestValue && i < section.rows.length) {\n        const r = section.rows[i].displayY;\n        if (r !== null) {\n            nearestIndex = i;\n            nearestValue = Math.abs(r - (value || 0));\n        }\n        i += 1;\n    }\n\n    if (!nearestValue || nearestIndex === undefined) {\n        return null;\n    }\n\n    for (i = nearestIndex + 1; i < section.rows.length; i++) {\n        const v = section.rows[i].displayY;\n\n        if (v === null) {\n            continue;\n        }\n\n        const diff = Math.abs(v - value);\n\n        if (nearestValue > diff) {\n            nearestValue = diff;\n            nearestIndex = i;\n        }\n    }\n\n    return nearestIndex;\n};\n\nexport const getUnitSuffix = (value: number): [number, string] => {\n    if (value >= 1e18) {\n        return [1e18, 'E'];\n    } else if (value >= 1e15) {\n        return [1e15, 'P'];\n    } else if (value >= 1e12) {\n        return [1e12, 'T'];\n    } else if (value >= 1e9) {\n        return [1e9, 'G'];\n    } else if (value >= 1e6) {\n        return [1e6, 'M'];\n    } else if (value >= 1e3) {\n        return [1e3, 'K'];\n    }\n    return [1, ''];\n};\n\n/* Number.toFixed() wihout rounding */\nexport function toFixed(num: number, fixed: number) {\n    if (fixed === 0) {\n        return parseInt(num as unknown as string);\n    }\n\n    if (Number.isInteger(num)) {\n        return num + '.' + '0'.repeat(fixed);\n    }\n\n    const [int, frac] = num.toString().split('.');\n    return frac.length >= fixed ? `${int}.${frac.slice(0, fixed)}` : `${int}.${frac}${'0'.repeat(fixed - frac.length)}`;\n}\n\n/**\n * Finds nearest non-null value's index in data series by given direction\n *\n * @param {DataSeriesExtended} data - Series data\n * @param {Series} series - Series options\n * @param {number} idx - cursor index\n * @param {SnapToValue | false} defaultSnapTo - default value for direction\n * @param {unknown} skipValue - value to skip\n * @returns {number}\n */\nexport function findDataIdx(\n    data: DataSeriesExtended,\n    series: Series,\n    idx: number,\n    defaultSnapTo: SnapToValue | false = 'closest',\n    skipValue: unknown = null,\n) {\n    let corL = idx,\n        corR = idx;\n\n    const direction = series.snapToValues ?? defaultSnapTo;\n\n    if (direction === false) {\n        return idx;\n    }\n\n    if (direction === 'left' || direction === 'closest') {\n        for (let i = idx - 1; i >= 0; i--) {\n            if (data[i] !== skipValue) {\n                corL = i;\n                break;\n            }\n        }\n    }\n\n    if (direction === 'right' || direction === 'closest') {\n        for (let i = idx + 1; i < data.length; i++) {\n            if (data[i] !== skipValue) {\n                corR = i;\n                break;\n            }\n        }\n    }\n\n    if (direction === 'left') {\n        return corL;\n    }\n    if (direction === 'right') {\n        return corR;\n    }\n\n    return corR - idx > idx - corL ? corL : corR;\n}\n\n/*\n * Interpolation function\n */\nconst interpolateImpl = (\n    timeline: number[],\n    y1: number | null,\n    y2: number | null,\n    x1: number,\n    x2: number,\n    xIdx: number,\n    iGroup: number[],\n    type: ProcessingInterpolation['type'] | number = 'linear',\n) => {\n    let result = null;\n    const x = timeline[xIdx];\n\n    switch (type) {\n        case 'linear': {\n            if (y1 === null || y2 === null) {\n                return null;\n            }\n\n            result = y1 + ((x - x1) * (y2 - y1)) / (x2 - x1);\n\n            if (isNaN(result) || Math.abs(result) === Infinity) {\n                result = null;\n            }\n            break;\n        }\n        case 'previous': {\n            result = y1;\n            break;\n        }\n        case 'next': {\n            result = y2;\n            break;\n        }\n        case 'left': {\n            result = iGroup[iGroup.length - 1] === timeline.length - 1 || y2 === null ? null : y1;\n            break;\n        }\n        case 'right': {\n            result = iGroup[0] === 0 ? null : y2;\n            break;\n        }\n        case 'closest': {\n            const lD = Math.abs(x1 - timeline[xIdx]);\n            const rD = Math.abs(x2 - timeline[xIdx]);\n            result = lD < rD ? y1 : y2;\n            break;\n        }\n        default: {\n            result = type;\n        }\n    }\n    return result;\n};\n\nexport const genId = () => Math.random().toString(36).substr(2, 9).replace(/^\\d+/, '');\n\n/**\n * Processing data series to:\n *  1. Find missing data and interpolate these points\n *  2. Find string special values to convert them to nulls\n *\n * @param {DataSeriesExtended[]} series\n * @param {number[]} timeline\n * @param {ProcessingSettings} settings\n * @returns {DataSeries[]}\n */\nexport const preprocess = (\n    series: DataSeriesExtended[],\n    timeline: number[],\n    settings: ProcessingSettings,\n): DataSeries[] => {\n    const result = [];\n    const nullValues = settings.nullValues || {};\n    const interpolation = settings.interpolation;\n    for (let sIdx = 0; sIdx < series.length; sIdx++) {\n        const line = series[sIdx];\n        const resultLine = [];\n\n        let iGroup = [];\n        let y1 = null,\n            y2 = null,\n            x1,\n            x2;\n\n        for (let idx = 0; idx < line.length; idx++) {\n            let val = line[idx];\n\n            if (interpolation && val === interpolation.value) {\n                iGroup.push(idx);\n                continue;\n            }\n\n            if (nullValues[val as string]) {\n                val = null;\n            }\n\n            if (iGroup.length) {\n                y2 = val;\n                x2 = timeline[idx];\n                for (const iIdx of iGroup) {\n                    resultLine[iIdx] = interpolateImpl(\n                        timeline,\n                        y1 as number | null,\n                        y2 as number | null,\n                        x1 || timeline[0],\n                        x2 || timeline[timeline.length - 1],\n                        iIdx,\n                        iGroup,\n                        interpolation && interpolation.type,\n                    );\n                }\n                iGroup = [];\n            }\n\n            y1 = val;\n            x1 = timeline[idx];\n            resultLine.push(val);\n        }\n\n        y2 = null;\n\n        if (iGroup.length) {\n            for (const iIdx of iGroup) {\n                resultLine.push(\n                    interpolateImpl(\n                        timeline,\n                        y1 as number | null,\n                        y2 as number | null,\n                        x1 || timeline[0],\n                        x2 || timeline[timeline.length - 1],\n                        iIdx,\n                        iGroup,\n                        interpolation && interpolation.type,\n                    ),\n                );\n            }\n        }\n        result.push(resultLine);\n    }\n\n    return result as DataSeries[];\n};\n\nexport const exec = <T, ArgsT extends unknown[]>(s: T | ((...a: ArgsT) => T), ...args: ArgsT) => {\n    return typeof s === 'function' ? (s as (...a: ArgsT) => T)(...args) : s;\n};\n\nexport function debounce<T extends Array<unknown> = []>(func: (...args: T) => void, timeout = 300) {\n    let timer: ReturnType<typeof setTimeout>;\n\n    return (...args: T) => {\n        clearTimeout(timer);\n        timer = setTimeout(() => func(...args), timeout);\n    };\n}\n\nexport const px = (x: number) => x + 'px';\nexport const html = (\n    tag: string,\n    attrs: Record<string, string | Record<string, string>> = {},\n    content?: string | HTMLElement,\n) => {\n    const el = document.createElement(tag);\n    Object.keys(attrs).forEach((key) => {\n        const attr = attrs[key];\n        el.setAttribute(\n            key,\n            typeof attr === 'object'\n                ? Object.entries(attr)\n                      .map(([a, b]) => `${a}:${b}`)\n                      .join(';')\n                : attr,\n        );\n    });\n    if (content) {\n        if (typeof content === 'string') {\n            el.innerHTML = content;\n        } else {\n            el.appendChild(content);\n        }\n    }\n    return el;\n};\n\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]];\ntype Join<K, P> = K extends string | number\n    ? P extends string | number\n        ? `${K}${'' extends P ? '' : '.'}${P}`\n        : never\n    : never;\nexport type Paths<T, D extends number = 10> = [D] extends [never]\n    ? never\n    : T extends object\n    ? {\n          [K in keyof T]-?: K extends string | number ? `${K}` | Join<K, Paths<T[K], Prev[D]>> : never;\n      }[keyof T]\n    : '';\n\nexport function get(obj: object, key: string) {\n    return key.split('.').reduce((acc, key) => Object.getOwnPropertyDescriptor(acc, key)?.value ?? {}, obj);\n}\n\nexport function deepIsEqual(a: unknown, b: unknown): boolean {\n    if (typeof a !== typeof b) {\n        return false;\n    }\n\n    if (typeof a === 'function' || typeof b === 'function') {\n        a = (a as Function).toString();\n        b = (b as Function).toString();\n    }\n\n    if (typeof a !== 'object' || isNil(a) || isNil(b)) {\n        return a === b;\n    }\n\n    const aObject = a as Record<string, unknown>;\n    const bObject = b as Record<string, unknown>;\n\n    const aKeys = Object.keys(aObject);\n    const bKeys = Object.keys(bObject);\n\n    if (aKeys.length !== bKeys.length) {\n        return false;\n    }\n\n    for (const key of aKeys) {\n        if (!bObject.hasOwnProperty(key)) {\n            return false;\n        }\n\n        if (!deepIsEqual(aObject[key], bObject[key])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function asFn<T>(t: T) {\n    return typeof t === 'function' ? t : typeof t === 'undefined' ? t : () => t;\n}\n\nexport function asPlain<T>(t: T): T extends (...args: any[]) => any ? ReturnType<T> : T {\n    return typeof t === 'function' ? t() : t;\n}\n\nexport function isNil(v: unknown): v is null | undefined {\n    return v === null || v === undefined;\n}\n\nexport function inBetween(value: number, start: number, end: number) {\n    return value >= start && value <= end ? value : value < start ? start : end;\n}\n", "/* eslint-disable complexity, @typescript-eslint/no-loop-func, no-nested-ternary */\n\nimport type {AxisOptions} from '../../types';\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {html, isNil, px} from '../../YagrCore/utils/common';\nimport {AxisLabel, Clear, PointLabel} from './types';\n\nexport const defaultPositionTop = (u: uPlot, x: number, y: number, scale: string) => {\n    return [u.valToPos(x, 'x'), u.valToPos(y, scale) - 15];\n};\n\nexport const getId = () => (x: number) => String(x);\n\nexport function renderAxisLabel({\n    yagr,\n    scaleKey,\n    x,\n    y,\n    className = '',\n    render,\n    onRender,\n    onDestroy,\n    label,\n}: {\n    yagr: Yagr;\n    scaleKey: string;\n    x: number;\n    y: number;\n    label: AxisLabel;\n    className?: string;\n    render?: AxisLabel['render'];\n    onRender?: (e: HTMLElement) => void;\n    onDestroy?: (e: HTMLElement) => void;\n}) {\n    const over = yagr.root.querySelector('.u-over') as HTMLElement;\n\n    if (render) {\n        return render(yagr, x, y, label);\n    }\n\n    const labelValue = label.label ? (typeof label.label === 'function' ? label.label(label) : label.label) : '';\n\n    const div = html(\n        'div',\n        {\n            class: `yagr-label ${className}`,\n            style: {\n                visibility: 'hidden',\n            },\n        },\n        labelValue ?? label.value.toString(),\n    );\n\n    over.append(div);\n\n    if (scaleKey === 'x') {\n        div.style.top = px(y - div.clientHeight / 2);\n        div.style.left = px(x - div.clientWidth / 2);\n    } else {\n        if (yagr.config.axes[scaleKey]?.side === 'right') {\n            div.style.left = px(x - div.clientWidth / 2);\n        } else {\n            div.style.left = px(x);\n        }\n        div.style.top = px(y - div.clientHeight / 2);\n    }\n\n    div.style.visibility = 'visible';\n\n    onRender && onRender(div);\n\n    return () => {\n        onDestroy && onDestroy(div);\n        div.remove();\n    };\n}\n\nexport function renderPointLabel({\n    yagr,\n    label,\n    x,\n    y,\n    className = '',\n    shifts = {},\n    onRender,\n    onDestroy,\n}: {\n    yagr: Yagr;\n    label: string;\n    x: number;\n    y: number;\n    onRender?: (e: HTMLElement) => void;\n    onDestroy?: (e: HTMLElement) => void;\n    className?: string;\n    shifts?: {top?: number; left?: number};\n}) {\n    const over = yagr.root.querySelector('.u-over') as HTMLElement;\n    const div = html(\n        'div',\n        {\n            class: `yagr-label ${className}`,\n            style: {\n                top: px(y + (shifts.top || 0)),\n                left: px(x + (shifts.left || 0)),\n            },\n        },\n        label,\n    );\n\n    over.append(div);\n\n    onRender && onRender(div);\n\n    div.style.left = px(Number(div.style.left.replace('px', '')) - div.clientWidth / 2);\n\n    return () => {\n        div.remove();\n        onDestroy && onDestroy(div);\n    };\n}\n\nexport function drawLabelOnPoint(\n    yagr: Yagr,\n    serieIdx: number,\n    xIdx: number,\n    scaleKey: string | undefined,\n    labelOptions: PointLabel | undefined,\n    xAxisFormatter: ReturnType<Required<AxisOptions>['getFormatter']>,\n    selfAxisFormatter: ReturnType<Required<AxisOptions>['getFormatter']>,\n    onDraw?: (clear: Clear, label: string, serieIdx: number) => void,\n) {\n    const x = yagr.uplot.data[0][xIdx];\n    const y = yagr.uplot.data[serieIdx][xIdx];\n\n    if (isNil(y) || !scaleKey || !labelOptions) {\n        return;\n    }\n\n    const valX = xAxisFormatter(x);\n    const valY = selfAxisFormatter(y);\n    const label =\n        typeof labelOptions.label === 'function'\n            ? labelOptions.label(x, y, xIdx)\n            : labelOptions.label || `(${valX}, ${valY})`;\n\n    if (labelOptions.render) {\n        const clear = labelOptions.render(yagr, serieIdx, xIdx, scaleKey, labelOptions);\n\n        clear && onDraw && onDraw(clear, label ?? '', serieIdx);\n        return;\n    }\n\n    if (!label || isNil(y)) {\n        return;\n    }\n\n    const [xP, yP] = labelOptions.position\n        ? labelOptions.position(x, y)\n        : defaultPositionTop(yagr.uplot, x, y, scaleKey);\n\n    const prev = yagr.uplot.data[serieIdx][xIdx - 1];\n    const next = yagr.uplot.data[serieIdx][xIdx + 1];\n    const className =\n        prev !== null && prev !== undefined && next !== null && next !== undefined\n            ? y < prev && y < next\n                ? '_bottom'\n                : '_top'\n            : '_top';\n\n    let clear = () => {};\n    if (labelOptions.show !== false) {\n        clear = renderPointLabel({\n            yagr,\n            label,\n            x: xP,\n            y: yP,\n            className,\n            onRender: labelOptions.onRender,\n            onDestroy: labelOptions.onDestroy,\n        });\n    }\n    onDraw && onDraw(clear, label, serieIdx);\n}\n", "/* eslint-disable complexity, @typescript-eslint/no-loop-func, no-nested-ternary */\n\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {isNil} from '../../YagrCore/utils/common';\nimport {Clear, LabelsOptions} from './types';\nimport {drawLabelOnPoint, getId} from './utils';\n\ntype StoredPointLabel = {idx: number; label: string | null | undefined};\n\n/**\n * Sets up hooks for labels rending on series draw, additionally sets up focus state for series\n * to show/hide labels on series focus\n */\nexport function seriesDrawBasedLabels(yagr: Yagr, hooks: uPlot.Hooks.Arrays, options: LabelsOptions) {\n    const clears: Record<number, Clear[]> = {};\n    const cursorClears: Clear[] = [];\n    const focusClears: Clear[] = [];\n    const labels: Record<number, {idx: number; label: string}[]> = {};\n\n    hooks.drawClear = hooks.drawClear || [];\n    hooks.draw = hooks.draw || [];\n    hooks.setCursor = hooks.setCursor || [];\n    hooks.setSeries = hooks.setSeries || [];\n\n    function drawLabelsOnSeries(u: uPlot, seriesIdxs?: number[]) {\n        const sIdxs = [];\n\n        if (seriesIdxs) {\n            sIdxs.push(...seriesIdxs);\n        } else {\n            for (let sIdx = 1; sIdx < u.series.length; sIdx++) {\n                const series = u.series[sIdx];\n\n                if (options.scales?.draw) {\n                    const scaleKey = series.scale;\n                    if (scaleKey && options.scales?.draw[scaleKey]) {\n                        sIdxs.push(sIdx);\n                    }\n                }\n\n                if (options.series?.draw) {\n                    if (options.series?.draw[series.id]) {\n                        sIdxs.push(sIdx);\n                    }\n                }\n            }\n        }\n\n        for (const sIdx of sIdxs) {\n            const series = u.series[sIdx] as Required<uPlot.Series>;\n            if (!series.show || series._focus === false) {\n                continue;\n            }\n            const {scale = 'y', min, max} = series;\n            const tSeries = u.series[0] as Required<uPlot.Series>;\n            const labelOptions = options.series?.draw?.[series.id] || options.scales?.draw?.[series.scale];\n\n            const selfAxisFormatter = (u.axes.find((a) => a.scale === scale)?.getFormatter || getId)(max - min);\n            const xAxisFormatter = (u.axes.find((a) => a.scale === 'x')?.getFormatter || getId)(\n                tSeries.max - tSeries.min,\n            );\n\n            let idx = 0;\n            while (idx < u.data[0].length) {\n                drawLabelOnPoint(\n                    yagr,\n                    sIdx,\n                    idx,\n                    scale,\n                    labelOptions,\n                    xAxisFormatter,\n                    selfAxisFormatter,\n                    (clear, label) => {\n                        clears[sIdx] = clears[sIdx] || [];\n                        clears[sIdx].push(clear);\n                        labels[sIdx] = labels[sIdx] || [];\n                        labels[sIdx].push({idx, label});\n                    },\n                );\n                idx++;\n            }\n        }\n    }\n\n    function drawLabelsOnCursor(u: uPlot, idx: number) {\n        const sIdxs = [];\n\n        for (let sIdx = 1; sIdx < u.series.length; sIdx++) {\n            const series = u.series[sIdx];\n\n            if (options.scales?.cursor) {\n                const scaleKey = series.scale;\n                if (scaleKey && options.scales.cursor[scaleKey]) {\n                    sIdxs.push(sIdx);\n                }\n            }\n\n            if (options.series?.cursor) {\n                if (options.series.cursor[series.id]) {\n                    sIdxs.push(sIdx);\n                }\n            }\n        }\n\n        for (const sIdx of sIdxs) {\n            const series = u.series[sIdx] as Required<uPlot.Series>;\n            if (!series.show || series._focus === false) {\n                continue;\n            }\n            const {scale = 'y', min, max} = series;\n            const tSeries = u.series[0] as Required<uPlot.Series>;\n            const labelOptions = options.series?.cursor?.[series.id] || options.scales?.cursor?.[series.scale];\n\n            const selfAxisFormatter = (u.axes.find((a) => a.scale === scale)?.getFormatter || getId)(max - min);\n            const xAxisFormatter = (u.axes.find((a) => a.scale === 'x')?.getFormatter || getId)(\n                tSeries.max - tSeries.min,\n            );\n\n            drawLabelOnPoint(yagr, sIdx, idx, scale, labelOptions, xAxisFormatter, selfAxisFormatter, (clear) => {\n                cursorClears.push(clear);\n            });\n        }\n    }\n\n    if (options.series?.focus) {\n        hooks.setSeries.push((u, sIdx, opts) => {\n            if (sIdx === null) {\n                focusClears?.forEach((fn) => fn());\n                return;\n            }\n            const series = u.series[sIdx] as Required<uPlot.Series>;\n            const labelOptions = options.series?.focus?.[series.id];\n\n            if (!labelOptions) {\n                focusClears?.forEach((fn) => fn());\n                return;\n            }\n\n            if (series.show && opts.focus === true) {\n                const {scale = 'y', min, max} = series;\n                const tSeries = u.series[0] as Required<uPlot.Series>;\n\n                const selfAxisFormatter = (u.axes.find((a) => a.scale === scale)?.getFormatter || getId)(max - min);\n                const xAxisFormatter = (u.axes.find((a) => a.scale === 'x')?.getFormatter || getId)(\n                    tSeries.max - tSeries.min,\n                );\n\n                let idx = 0;\n                while (idx < u.data[0].length) {\n                    drawLabelOnPoint(\n                        yagr,\n                        sIdx,\n                        idx,\n                        scale,\n                        labelOptions,\n                        xAxisFormatter,\n                        selfAxisFormatter,\n                        (clear) => {\n                            focusClears.push(clear);\n                        },\n                    );\n                    idx++;\n                }\n            } else {\n                focusClears?.forEach((fn) => fn());\n            }\n        });\n    }\n\n    if (options.scales?.draw || options.series?.draw) {\n        hooks.draw.push((u) => {\n            drawLabelsOnSeries(u);\n        });\n        hooks.drawClear.push(() => {\n            Object.values(clears).forEach((fns) => fns.forEach((fn) => fn()));\n            Object.keys(clears).forEach((k) => delete clears[Number(k)]);\n        });\n    }\n\n    if (options.scales?.cursor || options.series?.cursor) {\n        hooks.setCursor.push((u) => {\n            cursorClears.forEach((fn) => fn());\n            const {idx} = u.cursor;\n            if (!isNil(idx)) {\n                drawLabelsOnCursor(u, idx);\n            }\n        });\n    }\n\n    return {\n        getSeriesLabels: () => labels,\n        getCurrentSeriesLabels: (): Record<number, StoredPointLabel | undefined> => {\n            const cursor = yagr.uplot.cursor;\n\n            if (cursor.idx === null) {\n                return {};\n            }\n\n            return Object.entries(labels).reduce((acc, [sIdx, labels]) => {\n                acc[Number(sIdx)] = labels.find((l) => l.idx === cursor.idx);\n                return acc;\n            }, {} as Record<number, StoredPointLabel | undefined>);\n        },\n    };\n}\n", "import type {PlotLineConfig, PerScale} from '../../types';\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {isNil} from '../../YagrCore/utils/common';\nimport {Clear, LabelsOptions, PlotLabel} from './types';\nimport {defaultPositionTop, renderPointLabel} from './utils';\n\ntype StoredPlotLabel = {band: PlotLineConfig; label: string | null | undefined};\n\n/**\n * Sets up hooks for labels rending on plotLines draw\n */\nexport function plotLinesDrawBasedLabels(yagr: Yagr, hooks: uPlot.Hooks.Arrays, options: LabelsOptions) {\n    let drawClears: Clear[] = [];\n    let cursorClears: Clear[] = [];\n\n    hooks.draw = hooks.draw || [];\n    hooks.drawClear = hooks.drawClear || [];\n    hooks.setCursor = hooks.setCursor || [];\n\n    function renderLabelsOnPlotLines(\n        psOptions: PerScale<PlotLabel>,\n        clears: Clear[],\n        predicate?: (pl: PlotLineConfig) => boolean,\n    ) {\n        const bands: {\n            bands: PlotLineConfig[];\n            labelOptions: PlotLabel;\n        }[] = [];\n\n        for (const [scaleName, labelOptions] of Object.entries(psOptions || {})) {\n            const foundBands = (yagr.plugins.plotLines?.get() || []).filter((p) => {\n                return p.scale === scaleName;\n            });\n\n            foundBands.length && bands.push({bands: foundBands, labelOptions});\n        }\n\n        if (!bands.length) {\n            return;\n        }\n\n        bands.forEach(({bands: plotLines, labelOptions}) => {\n            plotLines.forEach((band) => {\n                if (predicate?.(band) === false) {\n                    return;\n                }\n\n                const [x, y] =\n                    band.scale === 'x'\n                        ? [Array.isArray(band.value) ? band.value[0] : band.value, yagr.uplot.posToVal(0, 'y')]\n                        : [yagr.uplot.posToVal(0, 'x'), Array.isArray(band.value) ? band.value[0] : band.value];\n\n                const [xP, yP] = labelOptions.position\n                    ? labelOptions.position(x, y)\n                    : defaultPositionTop(yagr.uplot, x, y, band.scale || 'y');\n\n                const label =\n                    typeof labelOptions.label === 'function'\n                        ? labelOptions.label(band)\n                        : labelOptions.label || band.label;\n\n                if (labelOptions.render) {\n                    const clear = labelOptions.render(yagr, band, xP, yP, labelOptions);\n                    clear && drawClears.push(clear);\n                    return;\n                }\n\n                if (label && labelOptions.show !== false) {\n                    clears.push(\n                        renderPointLabel({\n                            yagr,\n                            label,\n                            x: xP,\n                            y: yP,\n                        }),\n                    );\n                }\n            });\n        });\n    }\n\n    if (options.plotLines?.cursor) {\n        hooks.setCursor.push((u) => {\n            cursorClears.forEach((fn) => fn());\n            cursorClears = [];\n\n            const {left, top} = u.cursor;\n\n            if (!isNil(left) && !isNil(top) && left >= 0 && top >= 0) {\n                renderLabelsOnPlotLines(options.plotLines?.cursor!, cursorClears, (band: PlotLineConfig) => {\n                    const x = yagr.uplot.posToVal(left, 'x');\n                    const [x1, x2] = Array.isArray(band.value) ? band.value : [band.value, band.value];\n                    const [y1, y2] = Array.isArray(band.value)\n                        ? [band.value[0], band.value[1]]\n                        : [band.value, band.value];\n\n                    if (band.scale === 'x') {\n                        if (x >= x1 && x <= x2) {\n                            return true;\n                        }\n                    } else {\n                        const y = yagr.uplot.posToVal(top, band.scale!);\n\n                        if (y >= y1 && y <= y2) {\n                            return true;\n                        }\n                    }\n\n                    return false;\n                });\n            }\n        });\n    }\n\n    if (options.plotLines?.draw) {\n        hooks.draw.push(() => {\n            renderLabelsOnPlotLines(options.plotLines?.draw!, drawClears);\n        });\n\n        hooks.drawClear.push(() => {\n            drawClears.forEach((fn) => fn());\n            drawClears = [];\n        });\n    }\n\n    return {\n        getPlotLinesLabels: () => {\n            const bands = yagr.plugins.plotLines?.get() || [];\n\n            return bands\n                .filter((band) => {\n                    return options.plotLines?.draw?.[band.scale || 'y'];\n                })\n                .map((band) => {\n                    return {band, label: options.plotLines?.draw?.[band.scale || 'y']?.label || band.label};\n                });\n        },\n        getCurrentPlotLinesLabels: () => {\n            const cursor = yagr.uplot.cursor;\n\n            if (!cursor.left || !cursor.top || cursor.left < 0 || cursor.top < 0) {\n                return [];\n            }\n\n            const labels: StoredPlotLabel[] = [];\n\n            const {left, top} = cursor;\n            const x = yagr.uplot.posToVal(left, 'x');\n\n            yagr.plugins.plotLines?.get().forEach((band) => {\n                const [x1, x2] = Array.isArray(band.value) ? band.value : [band.value, band.value];\n                const [y1, y2] = Array.isArray(band.value) ? [band.value[0], band.value[1]] : [band.value, band.value];\n\n                if (band.scale === 'x') {\n                    if (x >= x1 && x <= x2) {\n                        labels.push({band, label: band.label});\n                    }\n                } else {\n                    const y = yagr.uplot.posToVal(top, band.scale!);\n\n                    if (y >= y1 && y <= y2) {\n                        labels.push({band, label: band.label});\n                    }\n                }\n            });\n\n            return labels;\n        },\n    };\n}\n", "import type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {AxisLabel, Clear, LabelsOptions} from './types';\nimport {renderAxisLabel} from './utils';\nimport {isNil} from '../../YagrCore/utils/common';\n\nexport function axisDrawBasedLabels(yagr: Yagr, hooks: uPlot.Hooks.Arrays, options: LabelsOptions) {\n    let pointsClears: Clear[] = [];\n\n    function onDrawAxes(u: uPlot) {\n        pointsClears.forEach((fn) => fn());\n        pointsClears = [];\n\n        Object.entries(options.axes || {}).forEach(([scaleKey, opts]) => {\n            const axis = u.axes.find((a) => a.scale === scaleKey);\n\n            if (!axis) {\n                return;\n            }\n\n            opts.forEach((opt) => {\n                let x, y;\n                if (scaleKey === 'x') {\n                    x = u.valToPos(opt.value, 'x');\n                    y = u.valToPos(0, 'y');\n                } else {\n                    if (yagr.config.axes[scaleKey]?.side === 'right') {\n                        x = u.valToPos(u.data[0][u.data[0].length - 1], 'x');\n                    } else {\n                        x = u.valToPos(u.data[0][0], 'x');\n                    }\n                    y = u.valToPos(opt.value, 'y');\n                }\n\n                pointsClears.push(\n                    renderAxisLabel({\n                        yagr,\n                        scaleKey,\n                        x,\n                        y,\n                        render: opt.render,\n                        label: opt,\n                        className: opt.className,\n                        onRender: opt.onRender,\n                        onDestroy: opt.onDestroy,\n                    }),\n                );\n            });\n        });\n    }\n\n    hooks.drawAxes = hooks.drawAxes || [];\n\n    if (options.axes) {\n        hooks.drawAxes.push(onDrawAxes);\n    }\n\n    return {\n        getAxisLabels() {\n            return options.axes || {};\n        },\n        getCurrentAxisLabels(proximity: {x: number; y: number}) {\n            const cursor = yagr.uplot.cursor;\n\n            if (!cursor) {\n                return {};\n            }\n\n            const {left, top} = cursor;\n            if (isNil(left) || isNil(top) || left < 0 || top < 0) {\n                return {};\n            }\n\n            const labels: Record<string, AxisLabel[]> = {};\n\n            Object.entries(options.axes || {}).forEach(([scaleKey, opts]) => {\n                const axis = yagr.uplot.axes.find((a) => a.scale === scaleKey);\n\n                if (!axis) {\n                    return;\n                }\n\n                opts.forEach((opt) => {\n                    let x, y;\n                    if (scaleKey === 'x') {\n                        x = yagr.uplot.posToVal(left, 'x');\n\n                        if (Math.abs(x - opt.value) < proximity.x) {\n                            labels[scaleKey] = labels[scaleKey] || [];\n                            labels[scaleKey].push(opt);\n                        }\n                    } else {\n                        y = yagr.uplot.posToVal(top, 'y');\n\n                        if (Math.abs(y - opt.value) < proximity.y) {\n                            labels[scaleKey] = labels[scaleKey] || [];\n                            labels[scaleKey].push(opt);\n                        }\n                    }\n                });\n            });\n\n            return labels;\n        },\n    };\n}\n", "import type {YagrPlugin} from '../../types';\nimport type uPlot from 'uplot';\nimport type Yagr from '../../index';\n\nimport {LabelsOptions} from './types';\nimport {seriesDrawBasedLabels} from './series';\nimport {plotLinesDrawBasedLabels} from './plotLines';\nimport {axisDrawBasedLabels} from './axes';\n\ntype SeriesMethods = ReturnType<typeof seriesDrawBasedLabels>;\ntype PlotLinesMethods = ReturnType<typeof plotLinesDrawBasedLabels>;\ntype AxisMethods = ReturnType<typeof axisDrawBasedLabels>;\n\nexport type LabelsPluginMethods = SeriesMethods & PlotLinesMethods & AxisMethods;\n\nexport default function YagrLabelsPlugin(options: LabelsOptions): YagrPlugin<LabelsPluginMethods> {\n    return (yagr: Yagr) => {\n        const hooks: uPlot.Hooks.Arrays = {};\n\n        return {\n            ...seriesDrawBasedLabels(yagr, hooks, options),\n            ...plotLinesDrawBasedLabels(yagr, hooks, options),\n            ...axisDrawBasedLabels(yagr, hooks, options),\n\n            uplot: {\n                hooks,\n            },\n        };\n    };\n}\n\nif (typeof window !== 'undefined') {\n    Object.assign(window, {YagrLabelsPlugin});\n}\n"],
  "mappings": "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",
  "names": ["px", "x", "html", "tag", "attrs", "content", "el", "key", "attr", "a", "b", "isNil", "v", "defaultPositionTop", "u", "y", "scale", "getId", "renderAxisLabel", "yagr", "scaleKey", "className", "render", "onRender", "onDestroy", "label", "over", "labelValue", "div", "renderPointLabel", "shifts", "drawLabelOnPoint", "serieIdx", "xIdx", "labelOptions", "xAxisFormatter", "selfAxisFormatter", "onDraw", "valX", "valY", "clear", "xP", "yP", "prev", "next", "seriesDrawBasedLabels", "hooks", "options", "clears", "cursorClears", "focusClears", "labels", "drawLabelsOnSeries", "seriesIdxs", "sIdxs", "sIdx", "series", "min", "max", "tSeries", "idx", "drawLabelsOnCursor", "opts", "fn", "fns", "k", "cursor", "acc", "l", "plotLinesDrawBasedLabels", "drawClears", "renderLabelsOnPlotLines", "psOptions", "predicate", "bands", "scaleName", "foundBands", "p", "plotLines", "band", "left", "top", "x1", "x2", "y1", "y2", "axisDrawBasedLabels", "pointsClears", "onDrawAxes", "opt", "proximity", "YagrLabelsPlugin"]
}
