"use strict";
/* eslint-disable complexity, @typescript-eslint/no-loop-func, no-nested-ternary */
Object.defineProperty(exports, "__esModule", { value: true });
exports.seriesDrawBasedLabels = void 0;
const common_1 = require("../../YagrCore/utils/common");
const utils_1 = require("./utils");
/**
 * Sets up hooks for labels rending on series draw, additionally sets up focus state for series
 * to show/hide labels on series focus
 */
function seriesDrawBasedLabels(yagr, hooks, options) {
    var _a, _b, _c, _d, _e;
    const clears = {};
    const cursorClears = [];
    const focusClears = [];
    const labels = {};
    hooks.drawClear = hooks.drawClear || [];
    hooks.draw = hooks.draw || [];
    hooks.setCursor = hooks.setCursor || [];
    hooks.setSeries = hooks.setSeries || [];
    function drawLabelsOnSeries(u, seriesIdxs) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const sIdxs = [];
        if (seriesIdxs) {
            sIdxs.push(...seriesIdxs);
        }
        else {
            for (let sIdx = 1; sIdx < u.series.length; sIdx++) {
                const series = u.series[sIdx];
                if ((_a = options.scales) === null || _a === void 0 ? void 0 : _a.draw) {
                    const scaleKey = series.scale;
                    if (scaleKey && ((_b = options.scales) === null || _b === void 0 ? void 0 : _b.draw[scaleKey])) {
                        sIdxs.push(sIdx);
                    }
                }
                if ((_c = options.series) === null || _c === void 0 ? void 0 : _c.draw) {
                    if ((_d = options.series) === null || _d === void 0 ? void 0 : _d.draw[series.id]) {
                        sIdxs.push(sIdx);
                    }
                }
            }
        }
        for (const sIdx of sIdxs) {
            const series = u.series[sIdx];
            if (!series.show || series._focus === false) {
                continue;
            }
            const { scale = 'y', min, max } = series;
            const tSeries = u.series[0];
            const labelOptions = ((_f = (_e = options.series) === null || _e === void 0 ? void 0 : _e.draw) === null || _f === void 0 ? void 0 : _f[series.id]) || ((_h = (_g = options.scales) === null || _g === void 0 ? void 0 : _g.draw) === null || _h === void 0 ? void 0 : _h[series.scale]);
            const selfAxisFormatter = (((_j = u.axes.find((a) => a.scale === scale)) === null || _j === void 0 ? void 0 : _j.getFormatter) || utils_1.getId)(max - min);
            const xAxisFormatter = (((_k = u.axes.find((a) => a.scale === 'x')) === null || _k === void 0 ? void 0 : _k.getFormatter) || utils_1.getId)(tSeries.max - tSeries.min);
            let idx = 0;
            while (idx < u.data[0].length) {
                (0, utils_1.drawLabelOnPoint)(yagr, sIdx, idx, scale, labelOptions, xAxisFormatter, selfAxisFormatter, (clear, label) => {
                    clears[sIdx] = clears[sIdx] || [];
                    clears[sIdx].push(clear);
                    labels[sIdx] = labels[sIdx] || [];
                    labels[sIdx].push({ idx, label });
                });
                idx++;
            }
        }
    }
    function drawLabelsOnCursor(u, idx) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const sIdxs = [];
        for (let sIdx = 1; sIdx < u.series.length; sIdx++) {
            const series = u.series[sIdx];
            if ((_a = options.scales) === null || _a === void 0 ? void 0 : _a.cursor) {
                const scaleKey = series.scale;
                if (scaleKey && options.scales.cursor[scaleKey]) {
                    sIdxs.push(sIdx);
                }
            }
            if ((_b = options.series) === null || _b === void 0 ? void 0 : _b.cursor) {
                if (options.series.cursor[series.id]) {
                    sIdxs.push(sIdx);
                }
            }
        }
        for (const sIdx of sIdxs) {
            const series = u.series[sIdx];
            if (!series.show || series._focus === false) {
                continue;
            }
            const { scale = 'y', min, max } = series;
            const tSeries = u.series[0];
            const labelOptions = ((_d = (_c = options.series) === null || _c === void 0 ? void 0 : _c.cursor) === null || _d === void 0 ? void 0 : _d[series.id]) || ((_f = (_e = options.scales) === null || _e === void 0 ? void 0 : _e.cursor) === null || _f === void 0 ? void 0 : _f[series.scale]);
            const selfAxisFormatter = (((_g = u.axes.find((a) => a.scale === scale)) === null || _g === void 0 ? void 0 : _g.getFormatter) || utils_1.getId)(max - min);
            const xAxisFormatter = (((_h = u.axes.find((a) => a.scale === 'x')) === null || _h === void 0 ? void 0 : _h.getFormatter) || utils_1.getId)(tSeries.max - tSeries.min);
            (0, utils_1.drawLabelOnPoint)(yagr, sIdx, idx, scale, labelOptions, xAxisFormatter, selfAxisFormatter, (clear) => {
                cursorClears.push(clear);
            });
        }
    }
    if ((_a = options.series) === null || _a === void 0 ? void 0 : _a.focus) {
        hooks.setSeries.push((u, sIdx, opts) => {
            var _a, _b, _c, _d;
            if (sIdx === null) {
                focusClears === null || focusClears === void 0 ? void 0 : focusClears.forEach((fn) => fn());
                return;
            }
            const series = u.series[sIdx];
            const labelOptions = (_b = (_a = options.series) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b[series.id];
            if (!labelOptions) {
                focusClears === null || focusClears === void 0 ? void 0 : focusClears.forEach((fn) => fn());
                return;
            }
            if (series.show && opts.focus === true) {
                const { scale = 'y', min, max } = series;
                const tSeries = u.series[0];
                const selfAxisFormatter = (((_c = u.axes.find((a) => a.scale === scale)) === null || _c === void 0 ? void 0 : _c.getFormatter) || utils_1.getId)(max - min);
                const xAxisFormatter = (((_d = u.axes.find((a) => a.scale === 'x')) === null || _d === void 0 ? void 0 : _d.getFormatter) || utils_1.getId)(tSeries.max - tSeries.min);
                let idx = 0;
                while (idx < u.data[0].length) {
                    (0, utils_1.drawLabelOnPoint)(yagr, sIdx, idx, scale, labelOptions, xAxisFormatter, selfAxisFormatter, (clear) => {
                        focusClears.push(clear);
                    });
                    idx++;
                }
            }
            else {
                focusClears === null || focusClears === void 0 ? void 0 : focusClears.forEach((fn) => fn());
            }
        });
    }
    if (((_b = options.scales) === null || _b === void 0 ? void 0 : _b.draw) || ((_c = options.series) === null || _c === void 0 ? void 0 : _c.draw)) {
        hooks.draw.push((u) => {
            drawLabelsOnSeries(u);
        });
        hooks.drawClear.push(() => {
            Object.values(clears).forEach((fns) => fns.forEach((fn) => fn()));
            Object.keys(clears).forEach((k) => delete clears[Number(k)]);
        });
    }
    if (((_d = options.scales) === null || _d === void 0 ? void 0 : _d.cursor) || ((_e = options.series) === null || _e === void 0 ? void 0 : _e.cursor)) {
        hooks.setCursor.push((u) => {
            cursorClears.forEach((fn) => fn());
            const { idx } = u.cursor;
            if (!(0, common_1.isNil)(idx)) {
                drawLabelsOnCursor(u, idx);
            }
        });
    }
    return {
        getSeriesLabels: () => labels,
        getCurrentSeriesLabels: () => {
            const cursor = yagr.uplot.cursor;
            if (cursor.idx === null) {
                return {};
            }
            return Object.entries(labels).reduce((acc, [sIdx, labels]) => {
                acc[Number(sIdx)] = labels.find((l) => l.idx === cursor.idx);
                return acc;
            }, {});
        },
    };
}
exports.seriesDrawBasedLabels = seriesDrawBasedLabels;
