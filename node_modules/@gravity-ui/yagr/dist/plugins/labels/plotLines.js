"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.plotLinesDrawBasedLabels = void 0;
const common_1 = require("../../YagrCore/utils/common");
const utils_1 = require("./utils");
/**
 * Sets up hooks for labels rending on plotLines draw
 */
function plotLinesDrawBasedLabels(yagr, hooks, options) {
    var _a, _b;
    let drawClears = [];
    let cursorClears = [];
    hooks.draw = hooks.draw || [];
    hooks.drawClear = hooks.drawClear || [];
    hooks.setCursor = hooks.setCursor || [];
    function renderLabelsOnPlotLines(psOptions, clears, predicate) {
        var _a;
        const bands = [];
        for (const [scaleName, labelOptions] of Object.entries(psOptions || {})) {
            const foundBands = (((_a = yagr.plugins.plotLines) === null || _a === void 0 ? void 0 : _a.get()) || []).filter((p) => {
                return p.scale === scaleName;
            });
            foundBands.length && bands.push({ bands: foundBands, labelOptions });
        }
        if (!bands.length) {
            return;
        }
        bands.forEach(({ bands: plotLines, labelOptions }) => {
            plotLines.forEach((band) => {
                if ((predicate === null || predicate === void 0 ? void 0 : predicate(band)) === false) {
                    return;
                }
                const [x, y] = band.scale === 'x'
                    ? [Array.isArray(band.value) ? band.value[0] : band.value, yagr.uplot.posToVal(0, 'y')]
                    : [yagr.uplot.posToVal(0, 'x'), Array.isArray(band.value) ? band.value[0] : band.value];
                const [xP, yP] = labelOptions.position
                    ? labelOptions.position(x, y)
                    : (0, utils_1.defaultPositionTop)(yagr.uplot, x, y, band.scale || 'y');
                const label = typeof labelOptions.label === 'function'
                    ? labelOptions.label(band)
                    : labelOptions.label || band.label;
                if (labelOptions.render) {
                    const clear = labelOptions.render(yagr, band, xP, yP, labelOptions);
                    clear && drawClears.push(clear);
                    return;
                }
                if (label && labelOptions.show !== false) {
                    clears.push((0, utils_1.renderPointLabel)({
                        yagr,
                        label,
                        x: xP,
                        y: yP,
                    }));
                }
            });
        });
    }
    if ((_a = options.plotLines) === null || _a === void 0 ? void 0 : _a.cursor) {
        hooks.setCursor.push((u) => {
            var _a;
            cursorClears.forEach((fn) => fn());
            cursorClears = [];
            const { left, top } = u.cursor;
            if (!(0, common_1.isNil)(left) && !(0, common_1.isNil)(top) && left >= 0 && top >= 0) {
                renderLabelsOnPlotLines((_a = options.plotLines) === null || _a === void 0 ? void 0 : _a.cursor, cursorClears, (band) => {
                    const x = yagr.uplot.posToVal(left, 'x');
                    const [x1, x2] = Array.isArray(band.value) ? band.value : [band.value, band.value];
                    const [y1, y2] = Array.isArray(band.value)
                        ? [band.value[0], band.value[1]]
                        : [band.value, band.value];
                    if (band.scale === 'x') {
                        if (x >= x1 && x <= x2) {
                            return true;
                        }
                    }
                    else {
                        const y = yagr.uplot.posToVal(top, band.scale);
                        if (y >= y1 && y <= y2) {
                            return true;
                        }
                    }
                    return false;
                });
            }
        });
    }
    if ((_b = options.plotLines) === null || _b === void 0 ? void 0 : _b.draw) {
        hooks.draw.push(() => {
            var _a;
            renderLabelsOnPlotLines((_a = options.plotLines) === null || _a === void 0 ? void 0 : _a.draw, drawClears);
        });
        hooks.drawClear.push(() => {
            drawClears.forEach((fn) => fn());
            drawClears = [];
        });
    }
    return {
        getPlotLinesLabels: () => {
            var _a;
            const bands = ((_a = yagr.plugins.plotLines) === null || _a === void 0 ? void 0 : _a.get()) || [];
            return bands
                .filter((band) => {
                var _a, _b;
                return (_b = (_a = options.plotLines) === null || _a === void 0 ? void 0 : _a.draw) === null || _b === void 0 ? void 0 : _b[band.scale || 'y'];
            })
                .map((band) => {
                var _a, _b, _c;
                return { band, label: ((_c = (_b = (_a = options.plotLines) === null || _a === void 0 ? void 0 : _a.draw) === null || _b === void 0 ? void 0 : _b[band.scale || 'y']) === null || _c === void 0 ? void 0 : _c.label) || band.label };
            });
        },
        getCurrentPlotLinesLabels: () => {
            var _a;
            const cursor = yagr.uplot.cursor;
            if (!cursor.left || !cursor.top || cursor.left < 0 || cursor.top < 0) {
                return [];
            }
            const labels = [];
            const { left, top } = cursor;
            const x = yagr.uplot.posToVal(left, 'x');
            (_a = yagr.plugins.plotLines) === null || _a === void 0 ? void 0 : _a.get().forEach((band) => {
                const [x1, x2] = Array.isArray(band.value) ? band.value : [band.value, band.value];
                const [y1, y2] = Array.isArray(band.value) ? [band.value[0], band.value[1]] : [band.value, band.value];
                if (band.scale === 'x') {
                    if (x >= x1 && x <= x2) {
                        labels.push({ band, label: band.label });
                    }
                }
                else {
                    const y = yagr.uplot.posToVal(top, band.scale);
                    if (y >= y1 && y <= y2) {
                        labels.push({ band, label: band.label });
                    }
                }
            });
            return labels;
        },
    };
}
exports.plotLinesDrawBasedLabels = plotLinesDrawBasedLabels;
