"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const defaults_1 = require("../../YagrCore/defaults");
const utils_1 = require("./utils");
const DataRef = (opst) => {
    const plugin = (yagr) => {
        const aggrs = {};
        const pluginMethods = {
            get: (fromIdx, toIdx) => {
                if (fromIdx === undefined && toIdx === undefined) {
                    return aggrs;
                }
                if (fromIdx === undefined) {
                    fromIdx = 0;
                }
                if (toIdx === undefined) {
                    toIdx = yagr.uplot.data[0].length - 1;
                }
                const result = {};
                yagr.uplot.series.forEach(({ scale, id }) => {
                    if (scale === defaults_1.DEFAULT_X_SCALE || !scale) {
                        return;
                    }
                    result[scale] = result[scale] || {};
                    result[scale].series = result[scale].series || {};
                    result[scale].series[id] = pluginMethods.calc(fromIdx, toIdx, id);
                });
                Object.keys(result).forEach((scale) => {
                    const total = {
                        min: (0, utils_1.safeMin)(Object.values(result[scale].series).map(({ min }) => min)),
                        max: (0, utils_1.safeMax)(Object.values(result[scale].series).map(({ max }) => max)),
                        sum: (0, utils_1.safeSum)(Object.values(result[scale].series).map(({ sum }) => sum)),
                        avg: 0,
                        count: Object.values(result[scale].series).reduce((acc, { count }) => acc + count, 0),
                        integral: Object.values(result[scale].series).reduce((acc, { integral }) => acc + (integral !== null && integral !== void 0 ? integral : 0), 0),
                        last: 0,
                    };
                    total.avg = total.sum === null ? null : total.sum / total.count;
                    total.last = null;
                    result[scale].total = total;
                });
                return result;
            },
            calc: (fromIdx, toIdx, seriesId) => {
                const seriesIdx = yagr.state.y2uIdx[seriesId];
                const timestamps = yagr.uplot.data[0].slice(fromIdx, toIdx + 1);
                const values = yagr.uplot.series[seriesIdx].$c;
                const integral = (0, utils_1.integrate)(timestamps, values.slice(fromIdx, toIdx + 1));
                const sum = (0, utils_1.safeSum)(values, fromIdx, toIdx);
                const min = (0, utils_1.safeMin)(values, fromIdx, toIdx);
                const max = (0, utils_1.safeMax)(values, fromIdx, toIdx);
                const cnt = (0, utils_1.countNumbers)(values, fromIdx, toIdx);
                const avg = sum === null ? null : sum / cnt;
                const last = (0, utils_1.getLast)(values, fromIdx, toIdx);
                return { min, max, sum, avg, count: cnt, integral, last };
            },
            uplot: {
                hooks: opst.calcOnReady === false
                    ? {}
                    : {
                        ready: (u) => {
                            Object.keys(u.scales).forEach((key) => {
                                if (key === defaults_1.DEFAULT_X_SCALE) {
                                    return;
                                }
                                aggrs[key] = {
                                    min: null,
                                    max: null,
                                    sum: null,
                                    avg: null,
                                    integral: null,
                                    count: 0,
                                    last: null,
                                };
                            });
                            u.series.forEach(({ scale, $c, count }) => {
                                if (scale === defaults_1.DEFAULT_X_SCALE) {
                                    return;
                                }
                                const numericValues = $c.filter((v) => typeof v === 'number' && v !== null);
                                aggrs[scale].min = (0, utils_1.safeMin)([...numericValues, aggrs[scale].min]);
                                aggrs[scale].max = (0, utils_1.safeMax)([...numericValues, aggrs[scale].max]);
                                const sum = aggrs[scale].sum;
                                const rowSum = (0, utils_1.safeSum)(numericValues);
                                aggrs[scale].sum =
                                    sum === null ? (0, utils_1.safeSum)(numericValues) : rowSum === null ? sum : sum + rowSum;
                                aggrs[scale].count += count;
                                const integral = aggrs[scale].integral;
                                const rowIntegral = (0, utils_1.integrate)(u.data[0], $c);
                                aggrs[scale].integral = integral === null ? rowIntegral : integral + rowIntegral;
                            });
                            Object.keys(aggrs).forEach((key) => {
                                const sum = aggrs[key].sum;
                                aggrs[key].avg = sum === null ? null : sum / aggrs[key].count;
                            });
                        },
                    },
            },
        };
        return pluginMethods;
    };
    return plugin;
};
exports.default = DataRef;
if (typeof window !== 'undefined') {
    Object.assign(window, { YagrAggregates: DataRef });
}
