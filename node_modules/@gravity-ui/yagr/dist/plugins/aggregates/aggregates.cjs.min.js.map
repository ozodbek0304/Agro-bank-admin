{
  "version": 3,
  "sources": ["../../../src/plugins/aggregates/aggregates.ts", "../../../src/YagrCore/defaults.ts", "../../../src/plugins/aggregates/utils.ts"],
  "sourcesContent": ["import {DataSeriesExtended, YagrPlugin} from '../../types';\nimport uPlot, {Series} from 'uplot';\nimport {DEFAULT_X_SCALE} from '../../YagrCore/defaults';\nimport type Yagr from '../../YagrCore/index';\nimport {countNumbers, getLast, integrate, safeMax, safeMin, safeSum} from './utils';\n\nexport type Aggregates = {\n    min: number | null;\n    max: number | null;\n    sum: number | null;\n    avg: number | null;\n    count: number;\n    integral: number | null;\n    last: number | null;\n};\nexport type AggregatesPerScale = Record<string, Aggregates>;\nexport type AggregatesPerSeries = Record<\n    string,\n    {\n        series: Record<string, Aggregates>;\n        total: Aggregates;\n    }\n>;\n\nexport type AggregatesPluginOptions = {\n    /** Should calc aggregates on ready event (true by default) */\n    calcOnReady?: boolean;\n};\n\nconst DataRef = (opst: AggregatesPluginOptions) => {\n    const plugin: YagrPlugin<{\n        get: (from?: number, to?: number) => AggregatesPerScale | AggregatesPerSeries;\n        calc: (from: number, to: number, id: string) => Aggregates;\n    }> = (yagr: Yagr) => {\n        const aggrs: AggregatesPerScale = {};\n\n        const pluginMethods = {\n            get: (fromIdx?: number, toIdx?: number) => {\n                if (fromIdx === undefined && toIdx === undefined) {\n                    return aggrs;\n                }\n\n                if (fromIdx === undefined) {\n                    fromIdx = 0;\n                }\n\n                if (toIdx === undefined) {\n                    toIdx = yagr.uplot.data[0].length - 1;\n                }\n\n                const result: AggregatesPerSeries = {};\n\n                yagr.uplot.series.forEach(({scale, id}) => {\n                    if (scale === DEFAULT_X_SCALE || !scale) {\n                        return;\n                    }\n                    result[scale] = result[scale] || {};\n                    result[scale].series = result[scale].series || {};\n                    result[scale].series[id] = pluginMethods.calc(fromIdx as number, toIdx as number, id);\n                });\n\n                Object.keys(result).forEach((scale) => {\n                    const total: Aggregates = {\n                        min: safeMin(Object.values(result[scale].series).map(({min}) => min)),\n                        max: safeMax(Object.values(result[scale].series).map(({max}) => max)),\n                        sum: safeSum(Object.values(result[scale].series).map(({sum}) => sum)),\n                        avg: 0,\n                        count: Object.values(result[scale].series).reduce((acc, {count}) => acc + count, 0),\n                        integral: Object.values(result[scale].series).reduce(\n                            (acc, {integral}) => acc + (integral ?? 0),\n                            0,\n                        ),\n                        last: 0,\n                    };\n\n                    total.avg = total.sum === null ? null : total.sum / total.count;\n                    total.last = null;\n\n                    result[scale].total = total;\n                });\n\n                return result;\n            },\n            calc: (fromIdx: number, toIdx: number, seriesId: string) => {\n                const seriesIdx = yagr.state.y2uIdx[seriesId];\n                const timestamps = yagr.uplot.data[0].slice(fromIdx, toIdx + 1) as number[];\n                const values = yagr.uplot.series[seriesIdx].$c;\n                const integral = integrate(timestamps, values.slice(fromIdx, toIdx + 1));\n                const sum = safeSum(values, fromIdx, toIdx);\n                const min = safeMin(values, fromIdx, toIdx);\n                const max = safeMax(values, fromIdx, toIdx);\n                const cnt = countNumbers(values, fromIdx, toIdx);\n                const avg = sum === null ? null : sum / cnt;\n                const last = getLast(values, fromIdx, toIdx);\n\n                return {min, max, sum, avg, count: cnt, integral, last};\n            },\n\n            uplot: {\n                hooks:\n                    opst.calcOnReady === false\n                        ? {}\n                        : {\n                              ready: (u: uPlot) => {\n                                  Object.keys(u.scales).forEach((key) => {\n                                      if (key === DEFAULT_X_SCALE) {\n                                          return;\n                                      }\n                                      aggrs[key] = {\n                                          min: null,\n                                          max: null,\n                                          sum: null,\n                                          avg: null,\n                                          integral: null,\n                                          count: 0,\n                                          last: null,\n                                      };\n                                  });\n\n                                  (u.series as Required<Series>[]).forEach(({scale, $c, count}) => {\n                                      if (scale === DEFAULT_X_SCALE) {\n                                          return;\n                                      }\n                                      const numericValues = $c.filter(\n                                          (v) => typeof v === 'number' && v !== null,\n                                      ) as number[];\n\n                                      aggrs[scale].min = safeMin([...numericValues, aggrs[scale].min]);\n                                      aggrs[scale].max = safeMax([...numericValues, aggrs[scale].max]);\n                                      const sum = aggrs[scale].sum;\n                                      const rowSum = safeSum(numericValues);\n                                      aggrs[scale].sum =\n                                          sum === null ? safeSum(numericValues) : rowSum === null ? sum : sum + rowSum;\n                                      aggrs[scale].count += count;\n                                      const integral = aggrs[scale].integral;\n                                      const rowIntegral = integrate(\n                                          u.data[0] as number[],\n                                          $c as DataSeriesExtended,\n                                      );\n                                      aggrs[scale].integral = integral === null ? rowIntegral : integral + rowIntegral;\n                                  });\n\n                                  Object.keys(aggrs).forEach((key) => {\n                                      const sum = aggrs[key].sum;\n                                      aggrs[key].avg = sum === null ? null : sum / aggrs[key].count;\n                                  });\n                              },\n                          },\n            },\n        };\n\n        return pluginMethods;\n    };\n    return plugin;\n};\n\nexport default DataRef;\n\nif (typeof window !== 'undefined') {\n    Object.assign(window, {YagrAggregates: DataRef});\n}\n", "import uPlot, {Padding} from 'uplot';\nimport {YagrTheme} from './types';\nimport type ColorParser from './utils/colors';\n\nexport const DEFAULT_X_SERIE_NAME = 'date';\nexport const DEFAULT_X_SCALE = 'x';\nexport const DEFAULT_Y_SCALE = 'y';\nexport const DEFAULT_FOCUS_ALPHA = 0.3;\nexport const DEFAULT_CANVAS_PIXEL_RATIO = typeof window === 'undefined' ? 1 : window.devicePixelRatio;\nexport const DEFAULT_MAX_TICKS = 5;\nexport const DEFAULT_Y_AXIS_OFFSET = 0.05;\nexport const DEFAULT_SCALE_MIN_RANGE = 0.01;\nexport const DEFAULT_LOGARITHMIC_MIN_SCALE_VALUE = 0.001;\nexport const DEFAULT_POINT_SIZE = DEFAULT_CANVAS_PIXEL_RATIO >= 2 ? 4 : 2;\n\nexport const DEFAULT_SYNC_KEY = 'sync';\nexport const DEFAULT_TITLE_FONT_SIZE = 14;\n\nexport const LIGHT_DEFAULT_LINE_COLOR = '#222222';\nexport const DARK_DEFAULT_LINE_COLOR = '#eeeeee';\n\nexport const DEFAULT_AXIS_FONT_SIZE = 11;\nexport const AXIS_LABEL_FONT = 'normal 11px Lucida Grande, Arial, Helvetica, sans-serif';\nexport const AXIS_VALUES_FONT = '11px Lucida Grande, Arial, Helvetica, sans-serif';\n\nexport const Y_AXIS_TICK_GAP = 6;\nexport const DEFAULT_Y_AXIS_SIZE = 12;\nexport const DEFAULT_Y_AXIS_PADDING = 12;\nexport const DEFAULT_Y_AXIS_LABEL_PADDING = 2;\nexport const Y_AXIS_SIZE = (self: uPlot, values: string[], axisIdx: number) => {\n    if (!values) {\n        return DEFAULT_Y_AXIS_SIZE;\n    }\n\n    const longesValue = values.reduce((l, c) => (l.length > c.length ? l : c));\n    const {ctx} = self;\n    ctx.save();\n    const axis = self.axes[axisIdx];\n\n    ctx.font = axis.font ? axis.font[0] : AXIS_VALUES_FONT;\n    const {width: textSize} = ctx.measureText(longesValue);\n    ctx.restore();\n\n    let labelSize = 0;\n    if (axis.label) {\n        labelSize = axis.labelSize || DEFAULT_AXIS_FONT_SIZE;\n\n        ctx.font = axis.labelFont ? axis.labelFont[0] : AXIS_LABEL_FONT;\n        const {fontBoundingBoxAscent: size} = ctx.measureText(axis.label);\n        labelSize = size;\n        ctx.restore();\n    }\n\n    return labelSize\n        ? textSize / DEFAULT_CANVAS_PIXEL_RATIO + labelSize / DEFAULT_CANVAS_PIXEL_RATIO + DEFAULT_Y_AXIS_LABEL_PADDING\n        : textSize / DEFAULT_CANVAS_PIXEL_RATIO + DEFAULT_Y_AXIS_PADDING;\n};\nexport const Y_AXIS_LABEL_SIZE = 11;\n\nexport const SECOND = 1000;\nexport const MINUTE = SECOND * 60;\nexport const HOUR = MINUTE * 60;\nexport const DAY = HOUR * 24;\nexport const YEAR = DAY * 365;\nexport const DECADE = YEAR * 10;\n\nexport const X_AXIS_TICK_GAP = 6;\nexport const X_AXIS_SIZE = 32;\nexport const X_AXIS_SPACE = 80;\nexport const X_AXIS_INCRS = [\n    // seconds divisors (# os ms)\n    1,\n    10,\n    50,\n    100,\n    200,\n    500,\n    // minute divisors\n    SECOND,\n    SECOND * 2,\n    SECOND * 5,\n    SECOND * 10,\n    SECOND * 15,\n    SECOND * 30,\n    // hour divisors\n    MINUTE,\n    MINUTE * 5,\n    MINUTE * 10,\n    MINUTE * 30,\n    // day divisors\n    HOUR,\n    HOUR * 2,\n    HOUR * 3,\n    HOUR * 4,\n    HOUR * 6,\n    HOUR * 12,\n    // month divisors\n    DAY,\n    DAY * 2,\n    DAY * 3,\n    DAY * 5,\n    DAY * 10,\n    DAY * 15,\n    DAY * 30,\n    DAY * 60,\n    DAY * 120,\n    DAY * 180,\n    // year divisors\n    YEAR,\n    YEAR * 2,\n    YEAR * 5,\n    YEAR * 10,\n];\n\nexport const TYPES_ORDER = ['dots', 'line', 'area', 'column'];\n\nexport const BARS_DRAW_FACTOR = 0.5;\nexport const BARS_DRAW_MAX = 100;\n\nexport const PADDING_LEFT: Padding = [14, 14, 0, 4];\nexport const PADDING_RIGHT: Padding = [14, 4, 0, 14];\nexport const PADDING_BOTH: Padding = [14, 4, 0, 4];\n\nexport const SERIE_COLOR = 'rgba(0, 0, 0, 1)';\nexport const SERIE_LINE_WIDTH = 2;\nexport const SERIE_AREA_BORDER_COLOR = 'rgba(0, 0, 0, 0.2)';\nexport const SERIE_AREA_BORDER_WIDTH = 1;\n\nexport const MARKER_DIAMETER = 8;\nexport const CURSOR_STYLE = '1px solid #ffa0a0';\n\nexport const MIN_SELECTION_WIDTH = 15;\n\nconst LIGHTEN_COLOR_SHIFT = 0.68;\nconst DARKEN_COLOR_SHIFT = -0.6;\n\nexport default class ThemedDefaults {\n    theme?: YagrTheme;\n    colors: ColorParser;\n\n    constructor(colors: ColorParser, theme: YagrTheme = 'light') {\n        this.setTheme(theme);\n        this.colors = colors;\n    }\n\n    setTheme(theme: YagrTheme) {\n        this.theme = theme;\n    }\n\n    get GRID() {\n        return {\n            show: true,\n            stroke: () => this.colors.parse('--yagr-grid'),\n            width: 1,\n        };\n    }\n\n    get X_AXIS_TICKS() {\n        return {size: 8, ...this.GRID};\n    }\n\n    get Y_AXIS_TICKS() {\n        return {size: 6, ...this.GRID};\n    }\n\n    get AXIS_STROKE() {\n        return this.colors.parse('--yagr-axis-stroke');\n    }\n\n    get BACKGROUND() {\n        return this.colors.parse('--yagr-background');\n    }\n\n    get SHIFT() {\n        return this.theme?.startsWith('light') ? LIGHTEN_COLOR_SHIFT : DARKEN_COLOR_SHIFT;\n    }\n\n    get DEFAULT_LINE_COLOR() {\n        return this.theme?.startsWith('light') ? LIGHT_DEFAULT_LINE_COLOR : DARK_DEFAULT_LINE_COLOR;\n    }\n}\n\nexport const TOOLTIP_Y_OFFSET = 24;\nexport const TOOLTIP_X_OFFSET = 24;\nexport const TOOLTIP_DEFAULT_MAX_LINES = 10;\nexport const TIME_MULTIPLIER = 1;", "import {DataSeriesExtended} from '../../types';\n\nexport function integrate(timestamps: number[], values: DataSeriesExtended) {\n    if (timestamps.length < 2) {\n        return 0;\n    }\n\n    let t0 = timestamps[0];\n    let x0 = Number(values[0]);\n    let t1: number;\n    let x1: number;\n    let integral = 0;\n\n    for (let i = 1; i < timestamps.length; i++) {\n        x1 = Number(values[i]);\n        t1 = timestamps[i];\n\n        // we skip over all non-numeric values in a serie\n        // so that all holes and single points (surrounded by\n        // empty void) do not add anything to the integral\n        if (!Number.isNaN(x1) && !Number.isNaN(x0)) {\n            const dt = t1 - t0;\n            const dx = x1 - x0;\n            const area = (x0 + dx / 2) * dt;\n            integral += area;\n        }\n\n        t0 = t1;\n        x0 = x1;\n    }\n\n    return integral;\n}\n\nexport function countNumbers(values: DataSeriesExtended, from = 0, to = values.length - 1) {\n    let cnt = 0;\n    for (let i = from; i <= to; i++) {\n        const val = values[i];\n        if (typeof val === 'number') {\n            cnt++;\n        }\n    }\n\n    return cnt;\n}\n\nexport function getLast(values: DataSeriesExtended, from = 0, to = values.length - 1): number | null {\n    for (let i = to; i >= from; i--) {\n        const val = values[i];\n        if (val !== null && typeof val === 'number') {\n            return val;\n        }\n    }\n\n    return null;\n}\n\nexport const safeMin = (values: DataSeriesExtended, from = 0, to = values.length - 1) => {\n    if (values.length === 0) {\n        return null;\n    }\n    let min = null;\n\n    for (let i = from; i <= to; i++) {\n        const v = values[i];\n\n        if (v === null || typeof v === 'string') {\n            continue;\n        }\n\n        if (min === null || v < min) {\n            min = v;\n        }\n    }\n\n    return min;\n};\n\nexport const safeMax = (values: DataSeriesExtended, from = 0, to = values.length - 1) => {\n    if (values.length === 0) {\n        return null;\n    }\n    let max = null;\n\n    for (let i = from; i <= to; i++) {\n        const v = values[i];\n\n        if (v === null || typeof v === 'string') {\n            continue;\n        }\n\n        if (max === null || v > max) {\n            max = v;\n        }\n    }\n\n    return max;\n};\n\nexport const safeSum = (values: DataSeriesExtended, from = 0, to = values.length - 1) => {\n    if (values.length === 0) {\n        return null;\n    }\n\n    let sum = null;\n\n    for (let i = from; i <= to; i++) {\n        const v = values[i];\n\n        if (v === null || typeof v === 'string') {\n            continue;\n        }\n\n        if (sum === null) {\n            sum = v;\n        } else {\n            sum += v;\n        }\n    }\n\n    return sum;\n};\n"],
  "mappings": "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",
  "names": ["timestamps", "values", "t0", "x0", "t1", "x1", "integral", "i", "dt", "dx", "area", "from", "to", "cnt", "val", "min", "v", "max", "sum", "opst", "yagr", "aggrs", "pluginMethods", "fromIdx", "toIdx", "result", "scale", "id", "total", "acc", "count", "seriesId", "seriesIdx", "avg", "last", "u", "key", "$c", "numericValues", "rowSum", "rowIntegral"]
}
