/**
* Copyright (c) 2024, Yandex LLC
* All rights reserved. (MIT Licensed)
*
* Yagr@4.3.0
* High-performance HTML5 canvas chart renderer based on uPlot
* https://github.com/gravity-ui/yagr
*/
(function (g, f) {
  var hasExports = typeof exports === 'object';
  if (typeof define === "function" && define.amd) {
    define([], f);
  } else if (typeof module === "object" && module.exports) {
    module.exports = f();
  } else {
    var m = hasExports ? f() : f();
    var root = hasExports ? exports : g;
    for(var i in m) root[i] = m[i];
  }}(typeof self !== 'undefined' ? self : this, () => {
var exports = {};
var module = { exports };
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugins/aggregates/aggregates.ts
var aggregates_exports = {};
__export(aggregates_exports, {
  default: () => aggregates_default
});
module.exports = __toCommonJS(aggregates_exports);

// src/YagrCore/defaults.ts
var DEFAULT_X_SCALE = "x";
var DEFAULT_CANVAS_PIXEL_RATIO = typeof window === "undefined" ? 1 : window.devicePixelRatio;
var DEFAULT_POINT_SIZE = DEFAULT_CANVAS_PIXEL_RATIO >= 2 ? 4 : 2;
var SECOND = 1e3;
var MINUTE = SECOND * 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;
var YEAR = DAY * 365;
var DECADE = YEAR * 10;
var X_AXIS_INCRS = [
  // seconds divisors (# os ms)
  1,
  10,
  50,
  100,
  200,
  500,
  // minute divisors
  SECOND,
  SECOND * 2,
  SECOND * 5,
  SECOND * 10,
  SECOND * 15,
  SECOND * 30,
  // hour divisors
  MINUTE,
  MINUTE * 5,
  MINUTE * 10,
  MINUTE * 30,
  // day divisors
  HOUR,
  HOUR * 2,
  HOUR * 3,
  HOUR * 4,
  HOUR * 6,
  HOUR * 12,
  // month divisors
  DAY,
  DAY * 2,
  DAY * 3,
  DAY * 5,
  DAY * 10,
  DAY * 15,
  DAY * 30,
  DAY * 60,
  DAY * 120,
  DAY * 180,
  // year divisors
  YEAR,
  YEAR * 2,
  YEAR * 5,
  YEAR * 10
];

// src/plugins/aggregates/utils.ts
function integrate(timestamps, values) {
  if (timestamps.length < 2) {
    return 0;
  }
  let t0 = timestamps[0];
  let x0 = Number(values[0]);
  let t1;
  let x1;
  let integral = 0;
  for (let i = 1; i < timestamps.length; i++) {
    x1 = Number(values[i]);
    t1 = timestamps[i];
    if (!Number.isNaN(x1) && !Number.isNaN(x0)) {
      const dt = t1 - t0;
      const dx = x1 - x0;
      const area = (x0 + dx / 2) * dt;
      integral += area;
    }
    t0 = t1;
    x0 = x1;
  }
  return integral;
}
function countNumbers(values, from = 0, to = values.length - 1) {
  let cnt = 0;
  for (let i = from; i <= to; i++) {
    const val = values[i];
    if (typeof val === "number") {
      cnt++;
    }
  }
  return cnt;
}
function getLast(values, from = 0, to = values.length - 1) {
  for (let i = to; i >= from; i--) {
    const val = values[i];
    if (val !== null && typeof val === "number") {
      return val;
    }
  }
  return null;
}
var safeMin = (values, from = 0, to = values.length - 1) => {
  if (values.length === 0) {
    return null;
  }
  let min = null;
  for (let i = from; i <= to; i++) {
    const v = values[i];
    if (v === null || typeof v === "string") {
      continue;
    }
    if (min === null || v < min) {
      min = v;
    }
  }
  return min;
};
var safeMax = (values, from = 0, to = values.length - 1) => {
  if (values.length === 0) {
    return null;
  }
  let max = null;
  for (let i = from; i <= to; i++) {
    const v = values[i];
    if (v === null || typeof v === "string") {
      continue;
    }
    if (max === null || v > max) {
      max = v;
    }
  }
  return max;
};
var safeSum = (values, from = 0, to = values.length - 1) => {
  if (values.length === 0) {
    return null;
  }
  let sum = null;
  for (let i = from; i <= to; i++) {
    const v = values[i];
    if (v === null || typeof v === "string") {
      continue;
    }
    if (sum === null) {
      sum = v;
    } else {
      sum += v;
    }
  }
  return sum;
};

// src/plugins/aggregates/aggregates.ts
var DataRef = (opst) => {
  const plugin = (yagr) => {
    const aggrs = {};
    const pluginMethods = {
      get: (fromIdx, toIdx) => {
        if (fromIdx === void 0 && toIdx === void 0) {
          return aggrs;
        }
        if (fromIdx === void 0) {
          fromIdx = 0;
        }
        if (toIdx === void 0) {
          toIdx = yagr.uplot.data[0].length - 1;
        }
        const result = {};
        yagr.uplot.series.forEach(({ scale, id }) => {
          if (scale === DEFAULT_X_SCALE || !scale) {
            return;
          }
          result[scale] = result[scale] || {};
          result[scale].series = result[scale].series || {};
          result[scale].series[id] = pluginMethods.calc(fromIdx, toIdx, id);
        });
        Object.keys(result).forEach((scale) => {
          const total = {
            min: safeMin(Object.values(result[scale].series).map(({ min }) => min)),
            max: safeMax(Object.values(result[scale].series).map(({ max }) => max)),
            sum: safeSum(Object.values(result[scale].series).map(({ sum }) => sum)),
            avg: 0,
            count: Object.values(result[scale].series).reduce((acc, { count }) => acc + count, 0),
            integral: Object.values(result[scale].series).reduce(
              (acc, { integral }) => acc + (integral ?? 0),
              0
            ),
            last: 0
          };
          total.avg = total.sum === null ? null : total.sum / total.count;
          total.last = null;
          result[scale].total = total;
        });
        return result;
      },
      calc: (fromIdx, toIdx, seriesId) => {
        const seriesIdx = yagr.state.y2uIdx[seriesId];
        const timestamps = yagr.uplot.data[0].slice(fromIdx, toIdx + 1);
        const values = yagr.uplot.series[seriesIdx].$c;
        const integral = integrate(timestamps, values.slice(fromIdx, toIdx + 1));
        const sum = safeSum(values, fromIdx, toIdx);
        const min = safeMin(values, fromIdx, toIdx);
        const max = safeMax(values, fromIdx, toIdx);
        const cnt = countNumbers(values, fromIdx, toIdx);
        const avg = sum === null ? null : sum / cnt;
        const last = getLast(values, fromIdx, toIdx);
        return { min, max, sum, avg, count: cnt, integral, last };
      },
      uplot: {
        hooks: opst.calcOnReady === false ? {} : {
          ready: (u) => {
            Object.keys(u.scales).forEach((key) => {
              if (key === DEFAULT_X_SCALE) {
                return;
              }
              aggrs[key] = {
                min: null,
                max: null,
                sum: null,
                avg: null,
                integral: null,
                count: 0,
                last: null
              };
            });
            u.series.forEach(({ scale, $c, count }) => {
              if (scale === DEFAULT_X_SCALE) {
                return;
              }
              const numericValues = $c.filter(
                (v) => typeof v === "number" && v !== null
              );
              aggrs[scale].min = safeMin([...numericValues, aggrs[scale].min]);
              aggrs[scale].max = safeMax([...numericValues, aggrs[scale].max]);
              const sum = aggrs[scale].sum;
              const rowSum = safeSum(numericValues);
              aggrs[scale].sum = sum === null ? safeSum(numericValues) : rowSum === null ? sum : sum + rowSum;
              aggrs[scale].count += count;
              const integral = aggrs[scale].integral;
              const rowIntegral = integrate(
                u.data[0],
                $c
              );
              aggrs[scale].integral = integral === null ? rowIntegral : integral + rowIntegral;
            });
            Object.keys(aggrs).forEach((key) => {
              const sum = aggrs[key].sum;
              aggrs[key].avg = sum === null ? null : sum / aggrs[key].count;
            });
          }
        }
      }
    };
    return pluginMethods;
  };
  return plugin;
};
var aggregates_default = DataRef;
if (typeof window !== "undefined") {
  Object.assign(window, { YagrAggregates: DataRef });
}
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
//# sourceMappingURL=aggregates.umd.js.map
