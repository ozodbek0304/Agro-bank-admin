{
  "version": 3,
  "sources": ["../src/YagrCore/defaults.ts", "../src/YagrCore/utils/colors.ts", "../src/YagrCore/utils/common.ts", "../src/YagrCore/plugins/cursor/cursor.ts", "../src/YagrCore/utils/events.ts", "../src/YagrCore/plugins/legend/legend.ts", "../node_modules/uplot/dist/uPlot.esm.js", "../src/YagrCore/locale.ts", "../src/YagrCore/plugins/tooltip/placement.ts", "../src/YagrCore/plugins/tooltip/utils.ts", "../src/YagrCore/plugins/tooltip/render.ts", "../src/YagrCore/plugins/tooltip/tooltip.ts", "../src/YagrCore/plugins/markers/index.ts", "../src/YagrCore/utils/paths.ts", "../src/YagrCore/utils/series.ts", "../src/YagrCore/utils/types.ts", "../src/YagrCore/utils/scales.ts", "../src/YagrCore/utils/axes.ts", "../src/YagrCore/utils/chart.ts", "../src/YagrCore/plugins/plotLines/plotLines.ts", "../src/YagrCore/mixins/create-options.ts", "../src/YagrCore/mixins/transform-series.ts", "../src/YagrCore/mixins/dynamic-updates.ts", "../src/YagrCore/utils/mixins.ts", "../src/YagrCore/mixins/batch-updates.ts", "../src/YagrCore/index.ts", "../src/index.ts"],
  "sourcesContent": ["import uPlot, {Padding} from 'uplot';\nimport {YagrTheme} from './types';\nimport type ColorParser from './utils/colors';\n\nexport const DEFAULT_X_SERIE_NAME = 'date';\nexport const DEFAULT_X_SCALE = 'x';\nexport const DEFAULT_Y_SCALE = 'y';\nexport const DEFAULT_FOCUS_ALPHA = 0.3;\nexport const DEFAULT_CANVAS_PIXEL_RATIO = typeof window === 'undefined' ? 1 : window.devicePixelRatio;\nexport const DEFAULT_MAX_TICKS = 5;\nexport const DEFAULT_Y_AXIS_OFFSET = 0.05;\nexport const DEFAULT_SCALE_MIN_RANGE = 0.01;\nexport const DEFAULT_LOGARITHMIC_MIN_SCALE_VALUE = 0.001;\nexport const DEFAULT_POINT_SIZE = DEFAULT_CANVAS_PIXEL_RATIO >= 2 ? 4 : 2;\n\nexport const DEFAULT_SYNC_KEY = 'sync';\nexport const DEFAULT_TITLE_FONT_SIZE = 14;\n\nexport const LIGHT_DEFAULT_LINE_COLOR = '#222222';\nexport const DARK_DEFAULT_LINE_COLOR = '#eeeeee';\n\nexport const DEFAULT_AXIS_FONT_SIZE = 11;\nexport const AXIS_LABEL_FONT = 'normal 11px Lucida Grande, Arial, Helvetica, sans-serif';\nexport const AXIS_VALUES_FONT = '11px Lucida Grande, Arial, Helvetica, sans-serif';\n\nexport const Y_AXIS_TICK_GAP = 6;\nexport const DEFAULT_Y_AXIS_SIZE = 12;\nexport const DEFAULT_Y_AXIS_PADDING = 12;\nexport const DEFAULT_Y_AXIS_LABEL_PADDING = 2;\nexport const Y_AXIS_SIZE = (self: uPlot, values: string[], axisIdx: number) => {\n    if (!values) {\n        return DEFAULT_Y_AXIS_SIZE;\n    }\n\n    const longesValue = values.reduce((l, c) => (l.length > c.length ? l : c));\n    const {ctx} = self;\n    ctx.save();\n    const axis = self.axes[axisIdx];\n\n    ctx.font = axis.font ? axis.font[0] : AXIS_VALUES_FONT;\n    const {width: textSize} = ctx.measureText(longesValue);\n    ctx.restore();\n\n    let labelSize = 0;\n    if (axis.label) {\n        labelSize = axis.labelSize || DEFAULT_AXIS_FONT_SIZE;\n\n        ctx.font = axis.labelFont ? axis.labelFont[0] : AXIS_LABEL_FONT;\n        const {fontBoundingBoxAscent: size} = ctx.measureText(axis.label);\n        labelSize = size;\n        ctx.restore();\n    }\n\n    return labelSize\n        ? textSize / DEFAULT_CANVAS_PIXEL_RATIO + labelSize / DEFAULT_CANVAS_PIXEL_RATIO + DEFAULT_Y_AXIS_LABEL_PADDING\n        : textSize / DEFAULT_CANVAS_PIXEL_RATIO + DEFAULT_Y_AXIS_PADDING;\n};\nexport const Y_AXIS_LABEL_SIZE = 11;\n\nexport const SECOND = 1000;\nexport const MINUTE = SECOND * 60;\nexport const HOUR = MINUTE * 60;\nexport const DAY = HOUR * 24;\nexport const YEAR = DAY * 365;\nexport const DECADE = YEAR * 10;\n\nexport const X_AXIS_TICK_GAP = 6;\nexport const X_AXIS_SIZE = 32;\nexport const X_AXIS_SPACE = 80;\nexport const X_AXIS_INCRS = [\n    // seconds divisors (# os ms)\n    1,\n    10,\n    50,\n    100,\n    200,\n    500,\n    // minute divisors\n    SECOND,\n    SECOND * 2,\n    SECOND * 5,\n    SECOND * 10,\n    SECOND * 15,\n    SECOND * 30,\n    // hour divisors\n    MINUTE,\n    MINUTE * 5,\n    MINUTE * 10,\n    MINUTE * 30,\n    // day divisors\n    HOUR,\n    HOUR * 2,\n    HOUR * 3,\n    HOUR * 4,\n    HOUR * 6,\n    HOUR * 12,\n    // month divisors\n    DAY,\n    DAY * 2,\n    DAY * 3,\n    DAY * 5,\n    DAY * 10,\n    DAY * 15,\n    DAY * 30,\n    DAY * 60,\n    DAY * 120,\n    DAY * 180,\n    // year divisors\n    YEAR,\n    YEAR * 2,\n    YEAR * 5,\n    YEAR * 10,\n];\n\nexport const TYPES_ORDER = ['dots', 'line', 'area', 'column'];\n\nexport const BARS_DRAW_FACTOR = 0.5;\nexport const BARS_DRAW_MAX = 100;\n\nexport const PADDING_LEFT: Padding = [14, 14, 0, 4];\nexport const PADDING_RIGHT: Padding = [14, 4, 0, 14];\nexport const PADDING_BOTH: Padding = [14, 4, 0, 4];\n\nexport const SERIE_COLOR = 'rgba(0, 0, 0, 1)';\nexport const SERIE_LINE_WIDTH = 2;\nexport const SERIE_AREA_BORDER_COLOR = 'rgba(0, 0, 0, 0.2)';\nexport const SERIE_AREA_BORDER_WIDTH = 1;\n\nexport const MARKER_DIAMETER = 8;\nexport const CURSOR_STYLE = '1px solid #ffa0a0';\n\nexport const MIN_SELECTION_WIDTH = 15;\n\nconst LIGHTEN_COLOR_SHIFT = 0.68;\nconst DARKEN_COLOR_SHIFT = -0.6;\n\nexport default class ThemedDefaults {\n    theme?: YagrTheme;\n    colors: ColorParser;\n\n    constructor(colors: ColorParser, theme: YagrTheme = 'light') {\n        this.setTheme(theme);\n        this.colors = colors;\n    }\n\n    setTheme(theme: YagrTheme) {\n        this.theme = theme;\n    }\n\n    get GRID() {\n        return {\n            show: true,\n            stroke: () => this.colors.parse('--yagr-grid'),\n            width: 1,\n        };\n    }\n\n    get X_AXIS_TICKS() {\n        return {size: 8, ...this.GRID};\n    }\n\n    get Y_AXIS_TICKS() {\n        return {size: 6, ...this.GRID};\n    }\n\n    get AXIS_STROKE() {\n        return this.colors.parse('--yagr-axis-stroke');\n    }\n\n    get BACKGROUND() {\n        return this.colors.parse('--yagr-background');\n    }\n\n    get SHIFT() {\n        return this.theme?.startsWith('light') ? LIGHTEN_COLOR_SHIFT : DARKEN_COLOR_SHIFT;\n    }\n\n    get DEFAULT_LINE_COLOR() {\n        return this.theme?.startsWith('light') ? LIGHT_DEFAULT_LINE_COLOR : DARK_DEFAULT_LINE_COLOR;\n    }\n}\n\nexport const TOOLTIP_Y_OFFSET = 24;\nexport const TOOLTIP_X_OFFSET = 24;\nexport const TOOLTIP_DEFAULT_MAX_LINES = 10;\nexport const TIME_MULTIPLIER = 1;", "import UPlot, {Series} from 'uplot';\nimport type Yagr from '../index';\n\nconst DEFAULT_SHADE_COLOR = [0, 0, 0, 0.6];\n\n/**\n * This class implements:\n *  - color parsing from RGBA, HEX or CSS color name\n *  - linear shade/lighten @see https://github.com/PimpTrizkit/PJs/wiki/12.-Shade,-Blend-and-Convert-a-Web-Color-(pSBC.js)#stackoverflow-archive-begin\n */\nexport default class ColorParser {\n    static parseRgba(rgbaColor: string) {\n        const m = rgbaColor.match(/rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,?\\s*(\\d+\\.?\\d*)?\\s*\\)/);\n        return m ? [m[1], m[2], m[3], m[4] || 1].map(Number) : null;\n    }\n\n    private context?: HTMLElement;\n\n    parse(color = '000') {\n        const isVar = color.startsWith('var(--');\n        let res = color,\n            pure = true,\n            prop;\n        const ctx = this.context as HTMLElement;\n\n        const pColor = ctx.style.color;\n\n        if (isVar || color.startsWith('--')) {\n            pure = false;\n            prop = isVar ? color.slice(4, -1) : color;\n        } else if (!color.startsWith('#') && !color.startsWith('rgb')) {\n            ctx.style.color = color;\n            prop = 'color';\n            pure = false;\n        }\n\n        res = pure ? res : getComputedStyle(ctx).getPropertyValue(prop as string);\n        ctx.style.color = pColor;\n        return res;\n    }\n\n    setContext(context: HTMLElement) {\n        this.context = context;\n    }\n\n    rgba(color: number[]) {\n        return `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`;\n    }\n\n    toRgba(color: string, fallbackRgba: number[]) {\n        return ColorParser.parseRgba(this.parse(color)) || fallbackRgba;\n    }\n\n    shade([r, g, b, a]: number[], value: number) {\n        const direction = value < 0;\n        const tOffset = direction ? 0 : 255 * value;\n        const transition = direction ? 1 + value : 1 - value;\n        const _r = Math.round(r * transition + tOffset);\n        const _g = Math.round(g * transition + tOffset);\n        const _b = Math.round(b * transition + tOffset);\n        return 'rgba(' + _r + ',' + _g + ',' + _b + ',' + a + ')';\n    }\n}\n\nexport const getFocusedColor = (y: Yagr, seriesIdx: number) => {\n    const shift = y.utils.theme.SHIFT;\n    const s = y.uplot.series[seriesIdx];\n    const mainColor = ColorParser.parseRgba(s.color) || DEFAULT_SHADE_COLOR;\n    return y.utils.colors.shade(mainColor, shift);\n};\n\nexport const getSerieFocusColors = (y: Yagr, field: keyof Series) => {\n    return (u: UPlot, idx: number) => {\n        const s = u.series[idx];\n        return s._focus === false ? s.getFocusedColor(y, idx) : (s[field] as string);\n    };\n};\n", "/* eslint-disable no-nested-ternary */\n\nimport {Series} from 'uplot';\nimport {DataSeriesExtended, DataSeries, SnapToValue, ProcessingSettings, ProcessingInterpolation} from '../types';\nimport {TooltipSection} from '../plugins/tooltip/types';\n\n/**\n * Finds index of point in ranges of Y-Axis values.\n * Returns index of starting range when idx < Y <= idx next\n *\n * @param {TooltipSection} section - tooltip section\n * @param {number} value - Y value of cursor\n * @param {boolean} stickToRanges - if true, then always return index of range\n * @returns {number | null}\n */\nexport const findInRange = (section: TooltipSection, value: number, stickToRanges = true): number | null => {\n    const positive = value >= 0;\n    let max = -Infinity,\n        maxIdx = null;\n    let min = Infinity,\n        minIdx = null;\n\n    const diffs: Array<number | null> = [];\n    let result: number | null = null;\n\n    for (let r = section.rows.length - 1; r >= 0; r--) {\n        const row = section.rows[r];\n        const {displayY: y, rowIdx} = row;\n\n        let diff: number | null;\n\n        if (y !== null) {\n            if (y > max) {\n                max = y;\n                maxIdx = row.rowIdx;\n            }\n\n            if (y < min) {\n                min = y;\n                minIdx = row.rowIdx;\n            }\n        }\n\n        if (y === null || (positive ? y < 0 : y >= 0)) {\n            diff = null;\n        } else if (positive) {\n            diff = value > y ? null : y - value;\n        } else {\n            diff = value < y ? null : Math.abs(y - value);\n        }\n\n        const currentMin = result === null ? Infinity : (diffs[result] as number);\n        const nextMin = diff === null ? currentMin : Math.min(currentMin, diff);\n\n        if ((diff !== null && currentMin === diff) || nextMin !== currentMin) {\n            result = rowIdx;\n        }\n    }\n\n    if (result === null && stickToRanges) {\n        return value >= max ? maxIdx : value <= min ? minIdx : null;\n    }\n\n    return result;\n};\n\n/* Gets sum of all values of given data index by all series */\nexport const getSumByIdx = (seriesOptions: Series[], idx: number, scale: string) => {\n    let sum = 0;\n    let i = 0;\n    while (i < seriesOptions.length) {\n        const seriesIdx = seriesOptions.length - i - 1;\n        const opts = seriesOptions[seriesIdx];\n        const seriesValues = opts.$c;\n        i += 1;\n        if (opts.scale !== scale || opts.show === false) {\n            continue;\n        }\n        const value = seriesValues[idx];\n        sum += typeof value === 'number' ? value : 0;\n    }\n    return sum;\n};\n\n/**\n * Finds index of nearest non-null point in range of Y-Axis values\n *\n * @param {TooltipSection} section\n * @param {number} value\n * @returns {number | null}\n */\nexport const findSticky = (section: TooltipSection, value: number): number | null => {\n    let nearestIndex;\n    let nearestValue;\n\n    let i = 0;\n    while (!nearestValue && i < section.rows.length) {\n        const r = section.rows[i].displayY;\n        if (r !== null) {\n            nearestIndex = i;\n            nearestValue = Math.abs(r - (value || 0));\n        }\n        i += 1;\n    }\n\n    if (!nearestValue || nearestIndex === undefined) {\n        return null;\n    }\n\n    for (i = nearestIndex + 1; i < section.rows.length; i++) {\n        const v = section.rows[i].displayY;\n\n        if (v === null) {\n            continue;\n        }\n\n        const diff = Math.abs(v - value);\n\n        if (nearestValue > diff) {\n            nearestValue = diff;\n            nearestIndex = i;\n        }\n    }\n\n    return nearestIndex;\n};\n\nexport const getUnitSuffix = (value: number): [number, string] => {\n    if (value >= 1e18) {\n        return [1e18, 'E'];\n    } else if (value >= 1e15) {\n        return [1e15, 'P'];\n    } else if (value >= 1e12) {\n        return [1e12, 'T'];\n    } else if (value >= 1e9) {\n        return [1e9, 'G'];\n    } else if (value >= 1e6) {\n        return [1e6, 'M'];\n    } else if (value >= 1e3) {\n        return [1e3, 'K'];\n    }\n    return [1, ''];\n};\n\n/* Number.toFixed() wihout rounding */\nexport function toFixed(num: number, fixed: number) {\n    if (fixed === 0) {\n        return parseInt(num as unknown as string);\n    }\n\n    if (Number.isInteger(num)) {\n        return num + '.' + '0'.repeat(fixed);\n    }\n\n    const [int, frac] = num.toString().split('.');\n    return frac.length >= fixed ? `${int}.${frac.slice(0, fixed)}` : `${int}.${frac}${'0'.repeat(fixed - frac.length)}`;\n}\n\n/**\n * Finds nearest non-null value's index in data series by given direction\n *\n * @param {DataSeriesExtended} data - Series data\n * @param {Series} series - Series options\n * @param {number} idx - cursor index\n * @param {SnapToValue | false} defaultSnapTo - default value for direction\n * @param {unknown} skipValue - value to skip\n * @returns {number}\n */\nexport function findDataIdx(\n    data: DataSeriesExtended,\n    series: Series,\n    idx: number,\n    defaultSnapTo: SnapToValue | false = 'closest',\n    skipValue: unknown = null,\n) {\n    let corL = idx,\n        corR = idx;\n\n    const direction = series.snapToValues ?? defaultSnapTo;\n\n    if (direction === false) {\n        return idx;\n    }\n\n    if (direction === 'left' || direction === 'closest') {\n        for (let i = idx - 1; i >= 0; i--) {\n            if (data[i] !== skipValue) {\n                corL = i;\n                break;\n            }\n        }\n    }\n\n    if (direction === 'right' || direction === 'closest') {\n        for (let i = idx + 1; i < data.length; i++) {\n            if (data[i] !== skipValue) {\n                corR = i;\n                break;\n            }\n        }\n    }\n\n    if (direction === 'left') {\n        return corL;\n    }\n    if (direction === 'right') {\n        return corR;\n    }\n\n    return corR - idx > idx - corL ? corL : corR;\n}\n\n/*\n * Interpolation function\n */\nconst interpolateImpl = (\n    timeline: number[],\n    y1: number | null,\n    y2: number | null,\n    x1: number,\n    x2: number,\n    xIdx: number,\n    iGroup: number[],\n    type: ProcessingInterpolation['type'] | number = 'linear',\n) => {\n    let result = null;\n    const x = timeline[xIdx];\n\n    switch (type) {\n        case 'linear': {\n            if (y1 === null || y2 === null) {\n                return null;\n            }\n\n            result = y1 + ((x - x1) * (y2 - y1)) / (x2 - x1);\n\n            if (isNaN(result) || Math.abs(result) === Infinity) {\n                result = null;\n            }\n            break;\n        }\n        case 'previous': {\n            result = y1;\n            break;\n        }\n        case 'next': {\n            result = y2;\n            break;\n        }\n        case 'left': {\n            result = iGroup[iGroup.length - 1] === timeline.length - 1 || y2 === null ? null : y1;\n            break;\n        }\n        case 'right': {\n            result = iGroup[0] === 0 ? null : y2;\n            break;\n        }\n        case 'closest': {\n            const lD = Math.abs(x1 - timeline[xIdx]);\n            const rD = Math.abs(x2 - timeline[xIdx]);\n            result = lD < rD ? y1 : y2;\n            break;\n        }\n        default: {\n            result = type;\n        }\n    }\n    return result;\n};\n\nexport const genId = () => Math.random().toString(36).substr(2, 9).replace(/^\\d+/, '');\n\n/**\n * Processing data series to:\n *  1. Find missing data and interpolate these points\n *  2. Find string special values to convert them to nulls\n *\n * @param {DataSeriesExtended[]} series\n * @param {number[]} timeline\n * @param {ProcessingSettings} settings\n * @returns {DataSeries[]}\n */\nexport const preprocess = (\n    series: DataSeriesExtended[],\n    timeline: number[],\n    settings: ProcessingSettings,\n): DataSeries[] => {\n    const result = [];\n    const nullValues = settings.nullValues || {};\n    const interpolation = settings.interpolation;\n    for (let sIdx = 0; sIdx < series.length; sIdx++) {\n        const line = series[sIdx];\n        const resultLine = [];\n\n        let iGroup = [];\n        let y1 = null,\n            y2 = null,\n            x1,\n            x2;\n\n        for (let idx = 0; idx < line.length; idx++) {\n            let val = line[idx];\n\n            if (interpolation && val === interpolation.value) {\n                iGroup.push(idx);\n                continue;\n            }\n\n            if (nullValues[val as string]) {\n                val = null;\n            }\n\n            if (iGroup.length) {\n                y2 = val;\n                x2 = timeline[idx];\n                for (const iIdx of iGroup) {\n                    resultLine[iIdx] = interpolateImpl(\n                        timeline,\n                        y1 as number | null,\n                        y2 as number | null,\n                        x1 || timeline[0],\n                        x2 || timeline[timeline.length - 1],\n                        iIdx,\n                        iGroup,\n                        interpolation && interpolation.type,\n                    );\n                }\n                iGroup = [];\n            }\n\n            y1 = val;\n            x1 = timeline[idx];\n            resultLine.push(val);\n        }\n\n        y2 = null;\n\n        if (iGroup.length) {\n            for (const iIdx of iGroup) {\n                resultLine.push(\n                    interpolateImpl(\n                        timeline,\n                        y1 as number | null,\n                        y2 as number | null,\n                        x1 || timeline[0],\n                        x2 || timeline[timeline.length - 1],\n                        iIdx,\n                        iGroup,\n                        interpolation && interpolation.type,\n                    ),\n                );\n            }\n        }\n        result.push(resultLine);\n    }\n\n    return result as DataSeries[];\n};\n\nexport const exec = <T, ArgsT extends unknown[]>(s: T | ((...a: ArgsT) => T), ...args: ArgsT) => {\n    return typeof s === 'function' ? (s as (...a: ArgsT) => T)(...args) : s;\n};\n\nexport function debounce<T extends Array<unknown> = []>(func: (...args: T) => void, timeout = 300) {\n    let timer: ReturnType<typeof setTimeout>;\n\n    return (...args: T) => {\n        clearTimeout(timer);\n        timer = setTimeout(() => func(...args), timeout);\n    };\n}\n\nexport const px = (x: number) => x + 'px';\nexport const html = (\n    tag: string,\n    attrs: Record<string, string | Record<string, string>> = {},\n    content?: string | HTMLElement,\n) => {\n    const el = document.createElement(tag);\n    Object.keys(attrs).forEach((key) => {\n        const attr = attrs[key];\n        el.setAttribute(\n            key,\n            typeof attr === 'object'\n                ? Object.entries(attr)\n                      .map(([a, b]) => `${a}:${b}`)\n                      .join(';')\n                : attr,\n        );\n    });\n    if (content) {\n        if (typeof content === 'string') {\n            el.innerHTML = content;\n        } else {\n            el.appendChild(content);\n        }\n    }\n    return el;\n};\n\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...0[]];\ntype Join<K, P> = K extends string | number\n    ? P extends string | number\n        ? `${K}${'' extends P ? '' : '.'}${P}`\n        : never\n    : never;\nexport type Paths<T, D extends number = 10> = [D] extends [never]\n    ? never\n    : T extends object\n    ? {\n          [K in keyof T]-?: K extends string | number ? `${K}` | Join<K, Paths<T[K], Prev[D]>> : never;\n      }[keyof T]\n    : '';\n\nexport function get(obj: object, key: string) {\n    return key.split('.').reduce((acc, key) => Object.getOwnPropertyDescriptor(acc, key)?.value ?? {}, obj);\n}\n\nexport function deepIsEqual(a: unknown, b: unknown): boolean {\n    if (typeof a !== typeof b) {\n        return false;\n    }\n\n    if (typeof a === 'function' || typeof b === 'function') {\n        a = (a as Function).toString();\n        b = (b as Function).toString();\n    }\n\n    if (typeof a !== 'object' || isNil(a) || isNil(b)) {\n        return a === b;\n    }\n\n    const aObject = a as Record<string, unknown>;\n    const bObject = b as Record<string, unknown>;\n\n    const aKeys = Object.keys(aObject);\n    const bKeys = Object.keys(bObject);\n\n    if (aKeys.length !== bKeys.length) {\n        return false;\n    }\n\n    for (const key of aKeys) {\n        if (!bObject.hasOwnProperty(key)) {\n            return false;\n        }\n\n        if (!deepIsEqual(aObject[key], bObject[key])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function asFn<T>(t: T) {\n    return typeof t === 'function' ? t : typeof t === 'undefined' ? t : () => t;\n}\n\nexport function asPlain<T>(t: T): T extends (...args: any[]) => any ? ReturnType<T> : T {\n    return typeof t === 'function' ? t() : t;\n}\n\nexport function isNil(v: unknown): v is null | undefined {\n    return v === null || v === undefined;\n}\n\nexport function inBetween(value: number, start: number, end: number) {\n    return value >= start && value <= end ? value : value < start ? start : end;\n}\n", "import {SnapToValue} from '../../types';\nimport UPlot, {Plugin, Series} from 'uplot';\n\nimport {CURSOR_STYLE, DEFAULT_X_SCALE, MARKER_DIAMETER, SERIE_COLOR} from '../../defaults';\nimport CP from '../../utils/colors';\nimport {findDataIdx, html, isNil} from '../../utils/common';\nimport type Yagr from '../..';\n\n/**\n * Options for cursor plugin.\n */\nexport interface CursorOptions {\n    /** Diameter of point markers */\n    markersSize?: number;\n    /** Snap cursor to non-null value (default: SnapToValue.Closest) */\n    snapToValues?: false | SnapToValue;\n    /** X crosshair options */\n    x?: {\n        visible?: boolean;\n        style?: string; // css style\n    };\n    /** Y crosshair options */\n    y?: {\n        visible?: boolean;\n        style?: string;\n    };\n    /** Max count of visible markers. If lines > value then markers will be hidden (default: 50) */\n    maxMarkers?: number;\n\n    /** Cursror sync key (default if true) */\n    sync?: true | string;\n\n    /** Hide cursor markers by predicate */\n    hideMarkers?: (value: number | null | string, seriesIdx: number) => boolean;\n}\n\nconst MAX_CURSORS = 50;\n\nfunction paintCursorPoint(series: Series, pt: HTMLElement, span?: HTMLElement) {\n    span ||= pt.querySelector('span') as HTMLElement;\n\n    if (!span) {\n        return;\n    }\n\n    pt.style.background = `${series.color}`;\n    span.style.background = series.color || SERIE_COLOR;\n    const colorRgba = CP.parseRgba(series.color) || [256, 256, 256, 0];\n    pt.style.boxShadow = `0px 0px 0px 1px rgba(${colorRgba[0]}, ${colorRgba[1]}, ${colorRgba[2]}, 0.5)`;\n}\n\n/*\n * Draws HTML points for cursor to transform\n */\nexport function cursorPoint(u: UPlot, seriesIndex: number) {\n    const serie = u.series[seriesIndex];\n    const span = html('span');\n    const pt = html(\n        'div',\n        {\n            class: 'yagr-point',\n            'data-idx': String(seriesIndex),\n        },\n        serie.empty ? undefined : span,\n    );\n\n    // @TODO possibly not to render at all. Requires PR into uPlot\n    if (serie.empty) {\n        pt.style.display = 'none';\n        return pt;\n    }\n\n    paintCursorPoint(serie, pt, span);\n\n    return pt;\n}\n\nfunction getPointsByIdx(over: HTMLDivElement, idx?: number) {\n    return idx === undefined\n        ? (Array.from(over.querySelectorAll('.yagr-point')) as HTMLDivElement[])\n        : [over.querySelector(`.yagr-point[data-idx=\"${idx}\"]`) as HTMLDivElement];\n}\n\n/*\n * Cursor plugin responsible for drawing cursor points and crosshairs,\n * and for syncing cursors.\n */\nexport default function CursorPlugin(\n    yagr: Yagr,\n    opts: CursorOptions,\n): {\n    pin: (v: boolean) => void;\n    focus: (i: number | null, f: boolean) => void;\n    uplot: Plugin;\n    updatePoints: () => void;\n    showPoints: (idx?: number) => void;\n    hidePoints: (idx?: number) => void;\n} {\n    const config = yagr.config;\n    const processing = config.processing || {};\n    const pInterpolation = Boolean(processing.interpolation);\n    const iValue = processing.interpolation?.value;\n\n    const snapToNulls = opts.snapToValues === false ? false : opts.snapToValues || 'closest';\n    const snapToInterpolated = pInterpolation ? processing.interpolation?.snapToValues ?? 'closest' : false;\n\n    let mem: Record<string, HTMLElement> = {};\n\n    /*\n     * This function finds non null value index and returns\n     * it's value for drawIdx hook for cursor\n     */\n    const snapOnValues = (self: UPlot, seriesIdx: number, hoveredIdx: number) => {\n        const series = self.series[seriesIdx];\n\n        if (series.scale === DEFAULT_X_SCALE) {\n            return hoveredIdx;\n        }\n\n        const seriesData = series.$c || self.data[seriesIdx];\n        const value = seriesData[hoveredIdx];\n\n        if (pInterpolation && value === iValue) {\n            return findDataIdx(seriesData, series, hoveredIdx, snapToInterpolated, iValue);\n        } else if (value === null) {\n            return findDataIdx(seriesData, series, hoveredIdx, snapToNulls, null);\n        }\n\n        return hoveredIdx;\n    };\n\n    return {\n        showPoints: (idx?: number) => {\n            const over = yagr.uplot.over;\n\n            if (!over) {\n                return;\n            }\n\n            const points = getPointsByIdx(over, idx);\n            points.forEach((pt) => {\n                pt.style.visibility = 'visible';\n            });\n        },\n        hidePoints: (idx?: number) => {\n            const over = yagr.uplot.over;\n\n            if (!over) {\n                return;\n            }\n\n            const points = getPointsByIdx(over, idx);\n            points.forEach((pt) => {\n                pt.style.visibility = 'hidden';\n            });\n        },\n        pin: (pinState: boolean) => {\n            const over = yagr.root.querySelector('.u-over');\n\n            if (!over) {\n                return;\n            }\n\n            if (pinState) {\n                const pointsHolder = document.createElement('div');\n                pointsHolder.classList.add('yagr-points-holder');\n                over.querySelectorAll('.yagr-point').forEach((elem) => {\n                    const newElem = elem.cloneNode(true) as HTMLElement;\n                    pointsHolder.appendChild(newElem);\n                    const idx = newElem.dataset['idx'];\n                    if (idx) {\n                        mem[idx] = newElem;\n                    }\n                });\n                over.appendChild(pointsHolder);\n            } else {\n                mem = {};\n                over.querySelector('.yagr-points-holder')?.remove();\n            }\n        },\n        updatePoints: () => {\n            (yagr.root.querySelectorAll('.yagr-point') as NodeListOf<HTMLElement>).forEach((pt) => {\n                const idx = Number(pt.dataset['idx']);\n                if (isNaN(idx)) {\n                    return;\n                }\n\n                const series = yagr.uplot.series[idx];\n\n                paintCursorPoint(series, pt);\n            });\n        },\n        focus: (serieIdx: number | null, focus: boolean) => {\n            Object.entries(mem).forEach(([idx, item]) => {\n                if (serieIdx === null) {\n                    item.style.display = focus ? 'block' : 'none';\n                    return;\n                }\n\n                item.style.display = idx === String(serieIdx) && focus ? 'block' : 'none';\n            });\n        },\n        uplot: {\n            opts: (_, uplotOptions) => {\n                uplotOptions.cursor = uplotOptions.cursor || {};\n\n                const emptyLines = uplotOptions.series.filter((s) => s.empty).length;\n                const totalLines = uplotOptions.series.length - 1;\n                const maxCursors = opts?.maxMarkers ?? MAX_CURSORS;\n\n                uplotOptions.cursor.points = {\n                    show: totalLines - emptyLines <= maxCursors ? cursorPoint : false,\n                    size: (u: uPlot, seriesIdx: number) => {\n                        const serie = u.series[seriesIdx];\n                        return (\n                            (serie.cursorOptions ? serie.cursorOptions.markersSize : opts?.markersSize) ||\n                            MARKER_DIAMETER\n                        );\n                    },\n                };\n\n                uplotOptions.cursor.dataIdx = snapOnValues;\n            },\n            hooks: {\n                ...(opts.hideMarkers && {\n                    setCursor: (u: uPlot) => {\n                        const idx = u.cursor.idx;\n\n                        if (isNil(idx)) {\n                            return;\n                        }\n\n                        for (let i = 1; i < u.series.length; i++) {\n                            const seriesValue = u.series[i].$c[idx];\n\n                            if (opts.hideMarkers!(seriesValue, i)) {\n                                yagr.plugins.cursor?.hidePoints(i);\n                            } else {\n                                yagr.plugins.cursor?.showPoints(i);\n                            }\n                        }\n                    },\n                }),\n                init: (u) => {\n                    const cX: HTMLElement | null = u.root.querySelector('.u-cursor-x');\n                    if (cX) {\n                        if (opts.x && opts.x.visible === false) {\n                            cX.style.display = 'none';\n                        }\n                        cX.style.borderRight = (opts.x && opts.x.style) || CURSOR_STYLE;\n                    }\n\n                    const cY: HTMLElement | null = u.root.querySelector('.u-cursor-y');\n                    if (cY) {\n                        if (opts.y && opts.y.visible !== false) {\n                            cY.style.borderBottom = opts.y.style || CURSOR_STYLE;\n                        } else {\n                            cY.style.display = 'none';\n                        }\n                    }\n                },\n            },\n        },\n    };\n}\n", "export const preventMouseEvents = (e: MouseEvent) => e.preventDefault();\n", "import UPlot, {Options, Series} from 'uplot';\n\nimport Yagr from '../../index';\nimport {DEFAULT_X_SERIE_NAME} from '../../defaults';\nimport {html} from '../../utils/common';\nimport {preventMouseEvents} from '../../utils/events';\n\nexport type LegendPosition = 'top' | 'bottom';\nexport interface LegendOptions {\n    /** Show legend (default: false) */\n    show?: boolean;\n    /** Root classname */\n    className?: string;\n    /** Legend placement position */\n    position?: LegendPosition;\n    /** Maximal space fro legend as a fraction of chart height (default: 0.3) */\n    maxLegendSpace?: number;\n    /** @TODO Maybe bugs here  */\n    fontSize?: number;\n    /** Basic behaviour includes only toggle behaviuor (\"Hide/show all\" button exists) */\n    behaviour?: 'basic' | 'extended';\n}\n\ninterface LegendState {\n    page: number;\n    pages: number;\n    paginated: boolean;\n    rowsPerPage: number;\n    pageSize: number;\n    requiredSpace: number;\n    totalSpace: number;\n    startSerieRange?: UPlot.Series;\n}\n\nconst ALL_SERIES_IDX = 'null' as const;\nconst PAGINATION_BUTTON_HEIGHT = 18;\nconst TOTAL_LEGEND_VERTICAL_PADDING_BOTTOM = 20;\nconst TOTAL_LEGEND_VERTICAL_PADDING_TOP = 48;\nconst DEFAULT_FONT_SIZE = 12;\nconst DEFAULT_LEGEND_PLACE_RATIO = 0.3;\n\nexport const hasOneVisibleLine = (series: Series[]) => {\n    return series.some(({show, id}) => id !== DEFAULT_X_SERIE_NAME && show);\n};\n\nconst getPrependingTitle = (i18n: Yagr['utils']['i18n'], series: Series[]) => {\n    return series.length > 3 && i18n(hasOneVisibleLine(series) ? 'hide-all' : 'show-all');\n};\n\nconst getPrependingTitleId = (series: Series[]): typeof ALL_SERIES_IDX | undefined => {\n    return (series.length > 3 && ALL_SERIES_IDX) || undefined;\n};\n\nexport default class LegendPlugin {\n    yagr!: Yagr;\n    uplot?: UPlot;\n    options!: LegendOptions;\n    pagesCount = 0;\n    state: LegendState = {\n        page: 0,\n        pages: 1,\n        pageSize: 0,\n        rowsPerPage: 1,\n        paginated: false,\n        requiredSpace: 0,\n        totalSpace: 0,\n    };\n    itemsHtml = '';\n    legendEl?: HTMLElement;\n    items?: HTMLElement;\n    container?: HTMLElement;\n    private _onDestroy?: () => void;\n\n    redraw() {\n        if (!this.options.show) {\n            return;\n        }\n        this.render();\n    }\n\n    destroy() {\n        if (this._onDestroy) {\n            this._onDestroy();\n        }\n        this.legendEl?.remove();\n    }\n\n    preInit = (yagr: Yagr, options: LegendOptions, uplotOptions: Options) => {\n        this.yagr = yagr;\n        this.options = Object.assign(\n            {\n                show: false,\n                position: 'bottom',\n                fontSize: DEFAULT_FONT_SIZE,\n                maxLegendSpace: DEFAULT_LEGEND_PLACE_RATIO,\n                className: undefined,\n                behaviour: 'basic',\n            },\n            options || {},\n        );\n        this.calc(uplotOptions);\n    };\n\n    init = (u: uPlot) => {\n        if (!this.options.show) {\n            return;\n        }\n\n        this.uplot = u;\n\n        /** Removing native uPlot legend */\n        u.root.querySelector('.u-legend')?.remove();\n        this.render();\n    };\n\n    update = () => {\n        const series: NodeListOf<HTMLDivElement> = this.yagr.root.querySelectorAll('[data-serie-id]');\n\n        series.forEach((serieNode) => {\n            const serieId = serieNode.getAttribute('data-serie-id');\n            if (!serieId || serieId === ALL_SERIES_IDX) {\n                return;\n            }\n            const serieVisible = this.uplot?.series[this.yagr.state.y2uIdx[serieId]]?.show;\n\n            serieNode.classList[serieVisible ? 'remove' : 'add']('yagr-legend__item_hidden');\n        });\n    };\n\n    private applyHandlers() {\n        const {yagr, uplot: u} = this;\n\n        if (!u) {\n            return () => {};\n        }\n\n        const series: NodeListOf<HTMLDivElement> = yagr.root.querySelectorAll('[data-serie-id]');\n        const unsubsribe: (() => void)[] = [];\n\n        const onSerieClickBasic = (serieNode: HTMLElement) => () => {\n            const serieId = serieNode.getAttribute('data-serie-id');\n            const seriesToToggle: [Series, boolean][] = [];\n\n            if (serieId === ALL_SERIES_IDX) {\n                const nextToggleState = !hasOneVisibleLine(u.series);\n\n                for (let idx = 1; idx < u.series.length; idx++) {\n                    seriesToToggle.push([u.series[idx], nextToggleState]);\n                }\n            } else {\n                const serie = u.series.find(({id}) => id === serieId);\n                if (!serie) {\n                    return;\n                }\n                seriesToToggle.push([serie, !serie.show]);\n            }\n\n            seriesToToggle.forEach(([serie, nextState]) => {\n                if (serie.show === nextState) {\n                    return;\n                }\n                const node = yagr.root.querySelector(`[data-serie-id=\"${serie.id}\"]`);\n                yagr.setVisible(serie.id, nextState, false);\n                node?.classList[nextState ? 'remove' : 'add']('yagr-legend__item_hidden');\n            });\n\n            const allSeriesItem = yagr.root.querySelector('.yagr-legend__all-series');\n\n            if (allSeriesItem) {\n                const title = getPrependingTitle(this.yagr.utils.i18n, u.series);\n                allSeriesItem.innerHTML = title || '';\n            }\n        };\n\n        const onSerieClickExtended = (serieNode: HTMLElement) => {\n            const changeVisibility = (id: string, visibility: boolean) => {\n                const node = yagr.root.querySelector(`[data-serie-id=\"${id}\"]`);\n                yagr.setVisible(id, visibility, false);\n                node?.classList[visibility ? 'remove' : 'add']('yagr-legend__item_hidden');\n            };\n\n            const toggleSerie = (serie: UPlot.Series) => {\n                changeVisibility(serie.id, !serie.show);\n            };\n\n            const selectSerie = (serie: UPlot.Series) => {\n                this.state.startSerieRange = serie;\n\n                const otherSeries = u.series.filter((s) => s.id !== serie.id);\n                const otherVisibility = !hasOneVisibleLine(otherSeries) && serie.show !== false;\n\n                u.series.forEach((s) => {\n                    const visibility = serie.id === s.id ? true : otherVisibility;\n                    changeVisibility(s.id, visibility);\n                });\n            };\n\n            const selectRange = (serie: UPlot.Series) => {\n                // If startSerieRange is undefined then startSerieRange = first valid legend element\n                if (!this.state.startSerieRange) {\n                    this.state.startSerieRange = u.series[1];\n                }\n\n                const range: number[] = [];\n\n                u.series.forEach((s, i) => {\n                    if (s.id === serie.id) {\n                        range.push(i);\n                    }\n                    // There is no 'else' because exist case when startSerieRange and target serie are same elements\n                    if (s.id === this.state.startSerieRange?.id) {\n                        range.push(i);\n                    }\n                });\n\n                u.series.forEach((s, i) => {\n                    const visibility = i >= range[0] && i <= range[1];\n                    changeVisibility(s.id, visibility);\n                });\n            };\n\n            return (e: MouseEvent) => {\n                const serieId = serieNode.getAttribute('data-serie-id');\n\n                const serie = u.series.find(({id}) => id === serieId);\n\n                if (!serie) {\n                    return;\n                }\n\n                e.preventDefault();\n\n                if (e.ctrlKey || e.metaKey) {\n                    toggleSerie(serie);\n                } else if (e.shiftKey) {\n                    selectRange(serie);\n                } else {\n                    selectSerie(serie);\n                }\n            };\n        };\n\n        const onSerieClick = {\n            basic: onSerieClickBasic,\n            extended: onSerieClickExtended,\n        };\n\n        const onSerieMouseEnter = (serieNode: HTMLElement) => () => {\n            const serieId = serieNode.getAttribute('data-serie-id');\n\n            if (serieNode.classList.contains('yagr-legend__item_hidden') || serieId === ALL_SERIES_IDX) {\n                return;\n            }\n\n            const targetSerie = this.yagr.uplot.series.find(({id}) => id === serieId);\n\n            if (targetSerie) {\n                yagr.setFocus(targetSerie.id, true);\n            }\n        };\n\n        const onSerieMouseLeave = () => {\n            yagr.setFocus(null, true);\n        };\n\n        series.forEach((serieNode) => {\n            const onClick = onSerieClick[this.options.behaviour || 'basic'](serieNode);\n            const onFocus = onSerieMouseEnter(serieNode);\n\n            serieNode.addEventListener('click', onClick);\n            serieNode.addEventListener('mouseenter', onFocus);\n            serieNode.addEventListener('mouseleave', onSerieMouseLeave);\n            serieNode.addEventListener('mousedown', preventMouseEvents);\n\n            unsubsribe.push(() => {\n                serieNode.removeEventListener('click', onClick);\n                serieNode.removeEventListener('mouseenter', onFocus);\n                serieNode.removeEventListener('mouseleave', onSerieMouseLeave);\n                serieNode.removeEventListener('mousedown', preventMouseEvents);\n            });\n        });\n\n        const destroy = () => unsubsribe.forEach((fn) => fn());\n        this._onDestroy = destroy;\n        return destroy;\n    }\n\n    private render() {\n        let reRender = false;\n        const {uplot: u, options} = this;\n        if (!u) {\n            return;\n        }\n\n        let legendEl = this.yagr.root.querySelector('.yagr-legend') as HTMLElement;\n\n        if (legendEl) {\n            reRender = true;\n        } else {\n            legendEl = html('div', {\n                class: `yagr-legend yagr-legend__${this.options.position} ${options?.className || ''}`,\n            });\n        }\n\n        if (!legendEl) {\n            return;\n        }\n\n        if (!reRender) {\n            if (options.position === 'top') {\n                u.root.before(legendEl);\n            } else {\n                u.root?.after(legendEl);\n            }\n        }\n\n        this.legendEl = legendEl;\n\n        if (!this.itemsHtml || reRender) {\n            this.calc(this.yagr.options);\n        }\n\n        legendEl.innerHTML = `<div class=\"yagr-legend__container\" style=\"height: ${this.state.requiredSpace}px\">${this.itemsHtml}</div>`;\n\n        this.items = legendEl.querySelector('.yagr-legend__items') as HTMLElement;\n        this.container = legendEl.querySelector('.yagr-legend__container') as HTMLElement;\n\n        if (this.state.paginated) {\n            const pagination = this.renderPagination();\n            this.container?.after(pagination);\n        } else {\n            this.items.style.justifyContent = 'center';\n        }\n\n        this.applyHandlers();\n    }\n\n    private measureLegend = (body: string) => {\n        const rootEl = this.yagr.root;\n        const pseudo = html(\n            'div',\n            {\n                class: 'yagr-legend',\n                style: {visibility: 'hidden'},\n            },\n            body,\n        );\n\n        rootEl.appendChild(pseudo);\n\n        const items = pseudo.childNodes[0] as HTMLElement;\n        const result = items.getBoundingClientRect();\n        pseudo.remove();\n\n        return result;\n    };\n\n    private nextPage = () => {\n        const {state} = this;\n        this.state.page += 1;\n\n        if (this.items) {\n            this.items.style.transform = `translate(0, ${-1 * state.page * state.pageSize}px)`;\n            this.renderPagination();\n        }\n    };\n\n    private prevPage = () => {\n        const {state} = this;\n        this.state.page -= 1;\n\n        if (this.items) {\n            this.items.style.transform = `translate(0, ${-1 * state.page * state.pageSize}px)`;\n            this.renderPagination();\n        }\n    };\n\n    private renderPagination() {\n        const {state} = this;\n\n        let pagination = this.yagr.root.querySelector('.yagr-legend__pagination');\n\n        if (pagination) {\n            const nextPage = pagination.querySelector('.yagr-legend__icon-down') as HTMLElement;\n            const prevPage = pagination.querySelector('.yagr-legend__icon-up') as HTMLElement;\n\n            nextPage.removeEventListener('click', this.nextPage);\n            prevPage.removeEventListener('click', this.prevPage);\n        } else {\n            pagination = html('div', {\n                class: 'yagr-legend__pagination',\n            });\n        }\n\n        const upClassName = state.page === 0 ? 'yagr-legend__icon-up_disabled' : '';\n        const downClassName = state.page === state.pages - 1 ? 'yagr-legend__icon-down_disabled' : '';\n\n        pagination.innerHTML = `<span class=\"yagr-legend__icon-up ${upClassName}\"></span>\n<span class=\"yagr-legend__pagination-text\">${state.page + 1}/${state.pages}</span>\n<span class=\"yagr-legend__icon-down ${downClassName}\"></span>`;\n\n        const nextPage = pagination.querySelector('.yagr-legend__icon-down') as HTMLElement;\n        const prevPage = pagination.querySelector('.yagr-legend__icon-up') as HTMLElement;\n\n        if (!downClassName) {\n            nextPage.addEventListener('click', this.nextPage);\n        }\n        if (!upClassName) {\n            prevPage.addEventListener('click', this.prevPage);\n        }\n\n        return pagination;\n    }\n\n    private createIconLineElement(serie: Series) {\n        const iconLineElement = html('span', {\n            class: `yagr-legend__icon yagr-legend__icon_${serie.type}`,\n            style: {'background-color': serie.color},\n        });\n\n        return iconLineElement;\n    }\n\n    private createSerieNameElement(serie: Series) {\n        const serieNameElement = html('span');\n        serieNameElement.innerText = serie.name || 'unnamed';\n\n        return serieNameElement;\n    }\n\n    private renderItems(uplotOptions: Options) {\n        const title = getPrependingTitle(this.yagr.utils.i18n, uplotOptions.series);\n        const titleId = this.options.behaviour !== 'extended' && getPrependingTitleId(uplotOptions.series);\n        const series: (Series | typeof ALL_SERIES_IDX)[] = titleId ? [titleId] : [];\n\n        for (let i = 1; i < uplotOptions.series.length; i++) {\n            series.push(uplotOptions.series[i]);\n        }\n\n        const content = series\n            .map((serie) => {\n                let serieContent;\n                let sId;\n                let additionalCn = ' ';\n\n                if (serie === ALL_SERIES_IDX) {\n                    serieContent = title;\n                    sId = titleId;\n                    additionalCn = ' yagr-legend__all-series ';\n                } else {\n                    sId = serie.id;\n                    const icon = this.createIconLineElement(serie);\n                    const name = this.createSerieNameElement(serie);\n\n                    serieContent = `${icon.outerHTML}${name.outerHTML}`;\n                }\n\n                const visible = typeof serie === 'string' ? true : serie.show !== false;\n\n                return `<div class=\"yagr-legend__item${additionalCn}${\n                    visible ? '' : 'yagr-legend__item_hidden'\n                }\" data-serie-id=\"${sId}\">${serieContent}</div>`;\n            })\n            .join('');\n\n        return `<div class=\"yagr-legend__items\">${content}</div>`;\n    }\n\n    private calc(uplotOptions: Options) {\n        if (!this.options.show) {\n            return;\n        }\n\n        const chartHeight = uplotOptions.height - this.VERTICAL_PADDING;\n        const html = this.renderItems(uplotOptions);\n        const {height: requiredHeight} = this.measureLegend(html);\n        const rowHeight = (this.options.fontSize as number) + 2;\n\n        const maxPossiblePlace = chartHeight * (this.options.maxLegendSpace as number);\n        const rowsPerPage = Math.floor(maxPossiblePlace / rowHeight);\n        const itemsRowsPerPage = rowsPerPage - 1;\n        const itemsPageSize = Math.min(itemsRowsPerPage * rowHeight, maxPossiblePlace);\n        const paginatedPageSize = Math.min(rowsPerPage * rowHeight, maxPossiblePlace);\n        const paginated = requiredHeight > itemsPageSize && itemsPageSize > 0;\n        const requiredSpace = Math.min(paginated ? paginatedPageSize : itemsPageSize, requiredHeight);\n        const pages = Math.ceil(requiredHeight / itemsPageSize);\n        const additionalSpace = paginated ? this.VERTICAL_PADDING + PAGINATION_BUTTON_HEIGHT : this.VERTICAL_PADDING;\n\n        this.state.requiredSpace = requiredSpace;\n        this.state.totalSpace = requiredSpace + additionalSpace;\n        this.state.paginated = paginated;\n        this.state.page = this.state.page || 0;\n        this.state.pages = pages;\n        this.state.pageSize = itemsPageSize;\n        this.state.rowsPerPage = rowsPerPage;\n        this.itemsHtml = html;\n    }\n\n    private get VERTICAL_PADDING() {\n        return this.options.position === 'bottom'\n            ? TOTAL_LEGEND_VERTICAL_PADDING_BOTTOM\n            : TOTAL_LEGEND_VERTICAL_PADDING_TOP;\n    }\n}\n", "/**\n* Copyright (c) 2023, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uPlot.js (\u03BCPlot)\n* A small, fast chart for time series, lines, areas, ohlc & bars\n* https://github.com/leeoniya/uPlot (v1.6.27)\n*/\n\nconst FEAT_TIME          = true;\n\nconst pre = \"u-\";\n\nconst UPLOT          =       \"uplot\";\nconst ORI_HZ         = pre + \"hz\";\nconst ORI_VT         = pre + \"vt\";\nconst TITLE          = pre + \"title\";\nconst WRAP           = pre + \"wrap\";\nconst UNDER          = pre + \"under\";\nconst OVER           = pre + \"over\";\nconst AXIS           = pre + \"axis\";\nconst OFF            = pre + \"off\";\nconst SELECT         = pre + \"select\";\nconst CURSOR_X       = pre + \"cursor-x\";\nconst CURSOR_Y       = pre + \"cursor-y\";\nconst CURSOR_PT      = pre + \"cursor-pt\";\nconst LEGEND         = pre + \"legend\";\nconst LEGEND_LIVE    = pre + \"live\";\nconst LEGEND_INLINE  = pre + \"inline\";\nconst LEGEND_SERIES  = pre + \"series\";\nconst LEGEND_MARKER  = pre + \"marker\";\nconst LEGEND_LABEL   = pre + \"label\";\nconst LEGEND_VALUE   = pre + \"value\";\n\nconst WIDTH       = \"width\";\nconst HEIGHT      = \"height\";\nconst TOP         = \"top\";\nconst BOTTOM      = \"bottom\";\nconst LEFT        = \"left\";\nconst RIGHT       = \"right\";\nconst hexBlack    = \"#000\";\nconst transparent = hexBlack + \"0\";\n\nconst mousemove   = \"mousemove\";\nconst mousedown   = \"mousedown\";\nconst mouseup     = \"mouseup\";\nconst mouseenter  = \"mouseenter\";\nconst mouseleave  = \"mouseleave\";\nconst dblclick    = \"dblclick\";\nconst resize      = \"resize\";\nconst scroll      = \"scroll\";\n\nconst change      = \"change\";\nconst dppxchange  = \"dppxchange\";\n\nconst LEGEND_DISP = \"--\";\n\nconst domEnv = typeof window != 'undefined';\n\nconst doc = domEnv ? document  : null;\nconst win = domEnv ? window    : null;\nconst nav = domEnv ? navigator : null;\n\nlet pxRatio;\n\n//export const canHover = domEnv && !win.matchMedia('(hover: none)').matches;\n\nlet query;\n\nfunction setPxRatio() {\n\tlet _pxRatio = devicePixelRatio;\n\n\t// during print preview, Chrome fires off these dppx queries even without changes\n\tif (pxRatio != _pxRatio) {\n\t\tpxRatio = _pxRatio;\n\n\t\tquery && off(change, query, setPxRatio);\n\t\tquery = matchMedia(`(min-resolution: ${pxRatio - 0.001}dppx) and (max-resolution: ${pxRatio + 0.001}dppx)`);\n\t\ton(change, query, setPxRatio);\n\n\t\twin.dispatchEvent(new CustomEvent(dppxchange));\n\t}\n}\n\nfunction addClass(el, c) {\n\tif (c != null) {\n\t\tlet cl = el.classList;\n\t\t!cl.contains(c) && cl.add(c);\n\t}\n}\n\nfunction remClass(el, c) {\n\tlet cl = el.classList;\n\tcl.contains(c) && cl.remove(c);\n}\n\nfunction setStylePx(el, name, value) {\n\tel.style[name] = value + \"px\";\n}\n\nfunction placeTag(tag, cls, targ, refEl) {\n\tlet el = doc.createElement(tag);\n\n\tif (cls != null)\n\t\taddClass(el, cls);\n\n\tif (targ != null)\n\t\ttarg.insertBefore(el, refEl);\n\n\treturn el;\n}\n\nfunction placeDiv(cls, targ) {\n\treturn placeTag(\"div\", cls, targ);\n}\n\nconst xformCache = new WeakMap();\n\nfunction elTrans(el, xPos, yPos, xMax, yMax) {\n\tlet xform = \"translate(\" + xPos + \"px,\" + yPos + \"px)\";\n\tlet xformOld = xformCache.get(el);\n\n\tif (xform != xformOld) {\n\t\tel.style.transform = xform;\n\t\txformCache.set(el, xform);\n\n\t\tif (xPos < 0 || yPos < 0 || xPos > xMax || yPos > yMax)\n\t\t\taddClass(el, OFF);\n\t\telse\n\t\t\tremClass(el, OFF);\n\t}\n}\n\nconst colorCache = new WeakMap();\n\nfunction elColor(el, background, borderColor) {\n\tlet newColor = background + borderColor;\n\tlet oldColor = colorCache.get(el);\n\n\tif (newColor != oldColor) {\n\t\tcolorCache.set(el, newColor);\n\t\tel.style.background = background;\n\t\tel.style.borderColor = borderColor;\n\t}\n}\n\nconst sizeCache = new WeakMap();\n\nfunction elSize(el, newWid, newHgt, centered) {\n\tlet newSize = newWid + \"\" + newHgt;\n\tlet oldSize = sizeCache.get(el);\n\n\tif (newSize != oldSize) {\n\t\tsizeCache.set(el, newSize);\n\t\tel.style.height = newHgt + \"px\";\n\t\tel.style.width = newWid + \"px\";\n\t\tel.style.marginLeft = centered ? -newWid/2 + \"px\" : 0;\n\t\tel.style.marginTop = centered ? -newHgt/2 + \"px\" : 0;\n\t}\n}\n\nconst evOpts = {passive: true};\nconst evOpts2 = {...evOpts, capture: true};\n\nfunction on(ev, el, cb, capt) {\n\tel.addEventListener(ev, cb, capt ? evOpts2 : evOpts);\n}\n\nfunction off(ev, el, cb, capt) {\n\tel.removeEventListener(ev, cb, capt ? evOpts2 : evOpts);\n}\n\ndomEnv && setPxRatio();\n\n// binary search for index of closest value\nfunction closestIdx(num, arr, lo, hi) {\n\tlet mid;\n\tlo = lo || 0;\n\thi = hi || arr.length - 1;\n\tlet bitwise = hi <= 2147483647;\n\n\twhile (hi - lo > 1) {\n\t\tmid = bitwise ? (lo + hi) >> 1 : floor((lo + hi) / 2);\n\n\t\tif (arr[mid] < num)\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\n\tif (num - arr[lo] <= arr[hi] - num)\n\t\treturn lo;\n\n\treturn hi;\n}\n\nfunction nonNullIdx(data, _i0, _i1, dir) {\n\tfor (let i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {\n\t\tif (data[i] != null)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nfunction getMinMax(data, _i0, _i1, sorted) {\n//\tconsole.log(\"getMinMax()\");\n\n\tlet _min = inf;\n\tlet _max = -inf;\n\n\tif (sorted == 1) {\n\t\t_min = data[_i0];\n\t\t_max = data[_i1];\n\t}\n\telse if (sorted == -1) {\n\t\t_min = data[_i1];\n\t\t_max = data[_i0];\n\t}\n\telse {\n\t\tfor (let i = _i0; i <= _i1; i++) {\n\t\t\tlet v = data[i];\n\n\t\t\tif (v != null) {\n\t\t\t\tif (v < _min)\n\t\t\t\t\t_min = v;\n\t\t\t\tif (v > _max)\n\t\t\t\t\t_max = v;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [_min, _max];\n}\n\nfunction getMinMaxLog(data, _i0, _i1) {\n//\tconsole.log(\"getMinMax()\");\n\n\tlet _min = inf;\n\tlet _max = -inf;\n\n\tfor (let i = _i0; i <= _i1; i++) {\n\t\tlet v = data[i];\n\n\t\tif (v != null && v > 0) {\n\t\t\tif (v < _min)\n\t\t\t\t_min = v;\n\t\t\tif (v > _max)\n\t\t\t\t_max = v;\n\t\t}\n\t}\n\n\treturn [\n\t\t_min ==  inf ?  1 : _min,\n\t\t_max == -inf ? 10 : _max,\n\t];\n}\n\nfunction rangeLog(min, max, base, fullMags) {\n\tlet minSign = sign(min);\n\tlet maxSign = sign(max);\n\n\tlet logFn = base == 10 ? log10 : log2;\n\n\tif (min == max) {\n\t\tif (minSign == -1) {\n\t\t\tmin *= base;\n\t\t\tmax /= base;\n\t\t}\n\t\telse {\n\t\t\tmin /= base;\n\t\t\tmax *= base;\n\t\t}\n\t}\n\n\tlet growMinAbs = minSign == 1 ? floor : ceil;\n\tlet growMaxAbs = maxSign == 1 ? ceil : floor;\n\n\tlet minExp = growMinAbs(logFn(abs(min)));\n\tlet maxExp = growMaxAbs(logFn(abs(max)));\n\n\tlet minIncr = pow(base, minExp);\n\tlet maxIncr = pow(base, maxExp);\n\n\t// fix values like Math.pow(10, -5) === 0.000009999999999999999\n\tif (base == 10) {\n\t\tif (minExp < 0)\n\t\t\tminIncr = roundDec(minIncr, -minExp);\n\t\tif (maxExp < 0)\n\t\t\tmaxIncr = roundDec(maxIncr, -maxExp);\n\t}\n\n\tif (fullMags || base == 2) {\n\t\tmin = minIncr * minSign;\n\t\tmax = maxIncr * maxSign;\n\t}\n\telse {\n\t\tmin = incrRoundDn(min, minIncr);\n\t\tmax = incrRoundUp(max, maxIncr);\n\t}\n\n\treturn [min, max];\n}\n\nfunction rangeAsinh(min, max, base, fullMags) {\n\tlet minMax = rangeLog(min, max, base, fullMags);\n\n\tif (min == 0)\n\t\tminMax[0] = 0;\n\n\tif (max == 0)\n\t\tminMax[1] = 0;\n\n\treturn minMax;\n}\n\nconst rangePad = 0.1;\n\nconst autoRangePart = {\n\tmode: 3,\n\tpad: rangePad,\n};\n\nconst _eqRangePart = {\n\tpad:  0,\n\tsoft: null,\n\tmode: 0,\n};\n\nconst _eqRange = {\n\tmin: _eqRangePart,\n\tmax: _eqRangePart,\n};\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction rangeNum(_min, _max, mult, extra) {\n\tif (isObj(mult))\n\t\treturn _rangeNum(_min, _max, mult);\n\n\t_eqRangePart.pad  = mult;\n\t_eqRangePart.soft = extra ? 0 : null;\n\t_eqRangePart.mode = extra ? 3 : 0;\n\n\treturn _rangeNum(_min, _max, _eqRange);\n}\n\n// nullish coalesce\nfunction ifNull(lh, rh) {\n\treturn lh == null ? rh : lh;\n}\n\n// checks if given index range in an array contains a non-null value\n// aka a range-bounded Array.some()\nfunction hasData(data, idx0, idx1) {\n\tidx0 = ifNull(idx0, 0);\n\tidx1 = ifNull(idx1, data.length - 1);\n\n\twhile (idx0 <= idx1) {\n\t\tif (data[idx0] != null)\n\t\t\treturn true;\n\t\tidx0++;\n\t}\n\n\treturn false;\n}\n\nfunction _rangeNum(_min, _max, cfg) {\n\tlet cmin = cfg.min;\n\tlet cmax = cfg.max;\n\n\tlet padMin = ifNull(cmin.pad, 0);\n\tlet padMax = ifNull(cmax.pad, 0);\n\n\tlet hardMin = ifNull(cmin.hard, -inf);\n\tlet hardMax = ifNull(cmax.hard,  inf);\n\n\tlet softMin = ifNull(cmin.soft,  inf);\n\tlet softMax = ifNull(cmax.soft, -inf);\n\n\tlet softMinMode = ifNull(cmin.mode, 0);\n\tlet softMaxMode = ifNull(cmax.mode, 0);\n\n\tlet delta = _max - _min;\n\tlet deltaMag = log10(delta);\n\n\tlet scalarMax = max(abs(_min), abs(_max));\n\tlet scalarMag = log10(scalarMax);\n\n\tlet scalarMagDelta = abs(scalarMag - deltaMag);\n\n\t// this handles situations like 89.7, 89.69999999999999\n\t// by assuming 0.001x deltas are precision errors\n//\tif (delta > 0 && delta < abs(_max) / 1e3)\n//\t\tdelta = 0;\n\n\t// treat data as flat if delta is less than 1 billionth\n\t// or range is 11+ orders of magnitude below raw values, e.g. 99999999.99999996 - 100000000.00000004\n\tif (delta < 1e-9 || scalarMagDelta > 10) {\n\t\tdelta = 0;\n\n\t\t// if soft mode is 2 and all vals are flat at 0, avoid the 0.1 * 1e3 fallback\n\t\t// this prevents 0,0,0 from ranging to -100,100 when softMin/softMax are -1,1\n\t\tif (_min == 0 || _max == 0) {\n\t\t\tdelta = 1e-9;\n\n\t\t\tif (softMinMode == 2 && softMin != inf)\n\t\t\t\tpadMin = 0;\n\n\t\t\tif (softMaxMode == 2 && softMax != -inf)\n\t\t\t\tpadMax = 0;\n\t\t}\n\t}\n\n\tlet nonZeroDelta = delta || scalarMax || 1e3;\n\tlet mag          = log10(nonZeroDelta);\n\tlet base         = pow(10, floor(mag));\n\n\tlet _padMin  = nonZeroDelta * (delta == 0 ? (_min == 0 ? .1 : 1) : padMin);\n\tlet _newMin  = roundDec(incrRoundDn(_min - _padMin, base/10), 9);\n\tlet _softMin = _min >= softMin && (softMinMode == 1 || softMinMode == 3 && _newMin <= softMin || softMinMode == 2 && _newMin >= softMin) ? softMin : inf;\n\tlet minLim   = max(hardMin, _newMin < _softMin && _min >= _softMin ? _softMin : min(_softMin, _newMin));\n\n\tlet _padMax  = nonZeroDelta * (delta == 0 ? (_max == 0 ? .1 : 1) : padMax);\n\tlet _newMax  = roundDec(incrRoundUp(_max + _padMax, base/10), 9);\n\tlet _softMax = _max <= softMax && (softMaxMode == 1 || softMaxMode == 3 && _newMax >= softMax || softMaxMode == 2 && _newMax <= softMax) ? softMax : -inf;\n\tlet maxLim   = min(hardMax, _newMax > _softMax && _max <= _softMax ? _softMax : max(_softMax, _newMax));\n\n\tif (minLim == maxLim && minLim == 0)\n\t\tmaxLim = 100;\n\n\treturn [minLim, maxLim];\n}\n\n// alternative: https://stackoverflow.com/a/2254896\nconst numFormatter = new Intl.NumberFormat(domEnv ? nav.language : 'en-US');\nconst fmtNum = val => numFormatter.format(val);\n\nconst M = Math;\n\nconst PI = M.PI;\nconst abs = M.abs;\nconst floor = M.floor;\nconst round = M.round;\nconst ceil = M.ceil;\nconst min = M.min;\nconst max = M.max;\nconst pow = M.pow;\nconst sign = M.sign;\nconst log10 = M.log10;\nconst log2 = M.log2;\n// TODO: seems like this needs to match asinh impl if the passed v is tweaked?\nconst sinh =  (v, linthresh = 1) => M.sinh(v) * linthresh;\nconst asinh = (v, linthresh = 1) => M.asinh(v / linthresh);\n\nconst inf = Infinity;\n\nfunction numIntDigits(x) {\n\treturn (log10((x ^ (x >> 31)) - (x >> 31)) | 0) + 1;\n}\n\nfunction clamp(num, _min, _max) {\n\treturn min(max(num, _min), _max);\n}\n\nfunction fnOrSelf(v) {\n\treturn typeof v == \"function\" ? v : () => v;\n}\n\nconst noop = () => {};\n\nconst retArg0 = _0 => _0;\n\nconst retArg1 = (_0, _1) => _1;\n\nconst retNull = _ => null;\n\nconst retTrue = _ => true;\n\nconst retEq = (a, b) => a == b;\n\n// this will probably prevent tick incrs > 14 decimal places\n// (we generate up to 17 dec, see fixedDec const)\nconst fixFloat = v => roundDec(v, 14);\n\nfunction incrRound(num, incr) {\n\treturn fixFloat(roundDec(fixFloat(num/incr))*incr);\n}\n\nfunction incrRoundUp(num, incr) {\n\treturn fixFloat(ceil(fixFloat(num/incr))*incr);\n}\n\nfunction incrRoundDn(num, incr) {\n\treturn fixFloat(floor(fixFloat(num/incr))*incr);\n}\n\n// https://stackoverflow.com/a/48764436\n// rounds half away from zero\nfunction roundDec(val, dec = 0) {\n\tif (isInt(val))\n\t\treturn val;\n//\telse if (dec == 0)\n//\t\treturn round(val);\n\n\tlet p = 10 ** dec;\n\tlet n = (val * p) * (1 + Number.EPSILON);\n\treturn round(n) / p;\n}\n\nconst fixedDec = new Map();\n\nfunction guessDec(num) {\n\treturn ((\"\"+num).split(\".\")[1] || \"\").length;\n}\n\nfunction genIncrs(base, minExp, maxExp, mults) {\n\tlet incrs = [];\n\n\tlet multDec = mults.map(guessDec);\n\n\tfor (let exp = minExp; exp < maxExp; exp++) {\n\t\tlet expa = abs(exp);\n\t\tlet mag = roundDec(pow(base, exp), expa);\n\n\t\tfor (let i = 0; i < mults.length; i++) {\n\t\t\tlet _incr = mults[i] * mag;\n\t\t\tlet dec = (_incr >= 0 && exp >= 0 ? 0 : expa) + (exp >= multDec[i] ? 0 : multDec[i]);\n\t\t\tlet incr = roundDec(_incr, dec);\n\t\t\tincrs.push(incr);\n\t\t\tfixedDec.set(incr, dec);\n\t\t}\n\t}\n\n\treturn incrs;\n}\n\n//export const assign = Object.assign;\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARR = [];\n\nconst nullNullTuple = [null, null];\n\nconst isArr = Array.isArray;\nconst isInt = Number.isInteger;\nconst isUndef = v => v === void 0;\n\nfunction isStr(v) {\n\treturn typeof v == 'string';\n}\n\nfunction isObj(v) {\n\tlet is = false;\n\n\tif (v != null) {\n\t\tlet c = v.constructor;\n\t\tis = c == null || c == Object;\n\t}\n\n\treturn is;\n}\n\nfunction fastIsObj(v) {\n\treturn v != null && typeof v == 'object';\n}\n\nconst TypedArray = Object.getPrototypeOf(Uint8Array);\n\nfunction copy(o, _isObj = isObj) {\n\tlet out;\n\n\tif (isArr(o)) {\n\t\tlet val = o.find(v => v != null);\n\n\t\tif (isArr(val) || _isObj(val)) {\n\t\t\tout = Array(o.length);\n\t\t\tfor (let i = 0; i < o.length; i++)\n\t\t\t\tout[i] = copy(o[i], _isObj);\n\t\t}\n\t\telse\n\t\t\tout = o.slice();\n\t}\n\telse if (o instanceof TypedArray) // also (ArrayBuffer.isView(o) && !(o instanceof DataView))\n\t\tout = o.slice();\n\telse if (_isObj(o)) {\n\t\tout = {};\n\t\tfor (let k in o)\n\t\t\tout[k] = copy(o[k], _isObj);\n\t}\n\telse\n\t\tout = o;\n\n\treturn out;\n}\n\nfunction assign(targ) {\n\tlet args = arguments;\n\n\tfor (let i = 1; i < args.length; i++) {\n\t\tlet src = args[i];\n\n\t\tfor (let key in src) {\n\t\t\tif (isObj(targ[key]))\n\t\t\t\tassign(targ[key], copy(src[key]));\n\t\t\telse\n\t\t\t\ttarg[key] = copy(src[key]);\n\t\t}\n\t}\n\n\treturn targ;\n}\n\n// nullModes\nconst NULL_REMOVE = 0;  // nulls are converted to undefined (e.g. for spanGaps: true)\nconst NULL_RETAIN = 1;  // nulls are retained, with alignment artifacts set to undefined (default)\nconst NULL_EXPAND = 2;  // nulls are expanded to include any adjacent alignment artifacts\n\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals, nullIdxs, alignedLen) {\n\tfor (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n\t\tlet nullIdx = nullIdxs[i];\n\n\t\tif (nullIdx > lastNullIdx) {\n\t\t\txi = nullIdx - 1;\n\t\t\twhile (xi >= 0 && yVals[xi] == null)\n\t\t\t\tyVals[xi--] = null;\n\n\t\t\txi = nullIdx + 1;\n\t\t\twhile (xi < alignedLen && yVals[xi] == null)\n\t\t\t\tyVals[lastNullIdx = xi++] = null;\n\t\t}\n\t}\n}\n\n// nullModes is a tables-matched array indicating how to treat nulls in each series\n// output is sorted ASC on the joined field (table[0]) and duplicate join values are collapsed\nfunction join(tables, nullModes) {\n\tif (allHeadersSame(tables)) {\n\t//\tconsole.log('cheap join!');\n\n\t\tlet table = tables[0].slice();\n\n\t\tfor (let i = 1; i < tables.length; i++)\n\t\t\ttable.push(...tables[i].slice(1));\n\n\t\tif (!isAsc(table[0]))\n\t\t\ttable = sortCols(table);\n\n\t\treturn table;\n\t}\n\n\tlet xVals = new Set();\n\n\tfor (let ti = 0; ti < tables.length; ti++) {\n\t\tlet t = tables[ti];\n\t\tlet xs = t[0];\n\t\tlet len = xs.length;\n\n\t\tfor (let i = 0; i < len; i++)\n\t\t\txVals.add(xs[i]);\n\t}\n\n\tlet data = [Array.from(xVals).sort((a, b) => a - b)];\n\n\tlet alignedLen = data[0].length;\n\n\tlet xIdxs = new Map();\n\n\tfor (let i = 0; i < alignedLen; i++)\n\t\txIdxs.set(data[0][i], i);\n\n\tfor (let ti = 0; ti < tables.length; ti++) {\n\t\tlet t = tables[ti];\n\t\tlet xs = t[0];\n\n\t\tfor (let si = 1; si < t.length; si++) {\n\t\t\tlet ys = t[si];\n\n\t\t\tlet yVals = Array(alignedLen).fill(undefined);\n\n\t\t\tlet nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n\n\t\t\tlet nullIdxs = [];\n\n\t\t\tfor (let i = 0; i < ys.length; i++) {\n\t\t\t\tlet yVal = ys[i];\n\t\t\t\tlet alignedIdx = xIdxs.get(xs[i]);\n\n\t\t\t\tif (yVal === null) {\n\t\t\t\t\tif (nullMode != NULL_REMOVE) {\n\t\t\t\t\t\tyVals[alignedIdx] = yVal;\n\n\t\t\t\t\t\tif (nullMode == NULL_EXPAND)\n\t\t\t\t\t\t\tnullIdxs.push(alignedIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tyVals[alignedIdx] = yVal;\n\t\t\t}\n\n\t\t\tnullExpand(yVals, nullIdxs, alignedLen);\n\n\t\t\tdata.push(yVals);\n\t\t}\n\t}\n\n\treturn data;\n}\n\nconst microTask = typeof queueMicrotask == \"undefined\" ? fn => Promise.resolve().then(fn) : queueMicrotask;\n\n// TODO: https://github.com/dy/sort-ids (~2x faster for 1e5+ arrays)\nfunction sortCols(table) {\n\tlet head = table[0];\n\tlet rlen = head.length;\n\n\tlet idxs = Array(rlen);\n\tfor (let i = 0; i < idxs.length; i++)\n\t\tidxs[i] = i;\n\n\tidxs.sort((i0, i1) => head[i0] - head[i1]);\n\n\tlet table2 = [];\n\tfor (let i = 0; i < table.length; i++) {\n\t\tlet row = table[i];\n\t\tlet row2 = Array(rlen);\n\n\t\tfor (let j = 0; j < rlen; j++)\n\t\t\trow2[j] = row[idxs[j]];\n\n\t\ttable2.push(row2);\n\t}\n\n\treturn table2;\n}\n\n// test if we can do cheap join (all join fields same)\nfunction allHeadersSame(tables) {\n\tlet vals0 = tables[0][0];\n\tlet len0 = vals0.length;\n\n\tfor (let i = 1; i < tables.length; i++) {\n\t\tlet vals1 = tables[i][0];\n\n\t\tif (vals1.length != len0)\n\t\t\treturn false;\n\n\t\tif (vals1 != vals0) {\n\t\t\tfor (let j = 0; j < len0; j++) {\n\t\t\t\tif (vals1[j] != vals0[j])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction isAsc(vals, samples = 100) {\n\tconst len = vals.length;\n\n\t// empty or single value\n\tif (len <= 1)\n\t\treturn true;\n\n\t// skip leading & trailing nullish\n\tlet firstIdx = 0;\n\tlet lastIdx = len - 1;\n\n\twhile (firstIdx <= lastIdx && vals[firstIdx] == null)\n\t\tfirstIdx++;\n\n\twhile (lastIdx >= firstIdx && vals[lastIdx] == null)\n\t\tlastIdx--;\n\n\t// all nullish or one value surrounded by nullish\n\tif (lastIdx <= firstIdx)\n\t\treturn true;\n\n\tconst stride = max(1, floor((lastIdx - firstIdx + 1) / samples));\n\n\tfor (let prevVal = vals[firstIdx], i = firstIdx + stride; i <= lastIdx; i += stride) {\n\t\tconst v = vals[i];\n\n\t\tif (v != null) {\n\t\t\tif (v <= prevVal)\n\t\t\t\treturn false;\n\n\t\t\tprevVal = v;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nconst months = [\n\t\"January\",\n\t\"February\",\n\t\"March\",\n\t\"April\",\n\t\"May\",\n\t\"June\",\n\t\"July\",\n\t\"August\",\n\t\"September\",\n\t\"October\",\n\t\"November\",\n\t\"December\",\n];\n\nconst days = [\n\t\"Sunday\",\n\t\"Monday\",\n\t\"Tuesday\",\n\t\"Wednesday\",\n\t\"Thursday\",\n\t\"Friday\",\n\t\"Saturday\",\n];\n\nfunction slice3(str) {\n\treturn str.slice(0, 3);\n}\n\nconst days3 = days.map(slice3);\n\nconst months3 = months.map(slice3);\n\nconst engNames = {\n\tMMMM: months,\n\tMMM:  months3,\n\tWWWW: days,\n\tWWW:  days3,\n};\n\nfunction zeroPad2(int) {\n\treturn (int < 10 ? '0' : '') + int;\n}\n\nfunction zeroPad3(int) {\n\treturn (int < 10 ? '00' : int < 100 ? '0' : '') + int;\n}\n\n/*\nfunction suffix(int) {\n\tlet mod10 = int % 10;\n\n\treturn int + (\n\t\tmod10 == 1 && int != 11 ? \"st\" :\n\t\tmod10 == 2 && int != 12 ? \"nd\" :\n\t\tmod10 == 3 && int != 13 ? \"rd\" : \"th\"\n\t);\n}\n*/\n\nconst subs = {\n\t// 2019\n\tYYYY:\td => d.getFullYear(),\n\t// 19\n\tYY:\t\td => (d.getFullYear()+'').slice(2),\n\t// July\n\tMMMM:\t(d, names) => names.MMMM[d.getMonth()],\n\t// Jul\n\tMMM:\t(d, names) => names.MMM[d.getMonth()],\n\t// 07\n\tMM:\t\td => zeroPad2(d.getMonth()+1),\n\t// 7\n\tM:\t\td => d.getMonth()+1,\n\t// 09\n\tDD:\t\td => zeroPad2(d.getDate()),\n\t// 9\n\tD:\t\td => d.getDate(),\n\t// Monday\n\tWWWW:\t(d, names) => names.WWWW[d.getDay()],\n\t// Mon\n\tWWW:\t(d, names) => names.WWW[d.getDay()],\n\t// 03\n\tHH:\t\td => zeroPad2(d.getHours()),\n\t// 3\n\tH:\t\td => d.getHours(),\n\t// 9 (12hr, unpadded)\n\th:\t\td => {let h = d.getHours(); return h == 0 ? 12 : h > 12 ? h - 12 : h;},\n\t// AM\n\tAA:\t\td => d.getHours() >= 12 ? 'PM' : 'AM',\n\t// am\n\taa:\t\td => d.getHours() >= 12 ? 'pm' : 'am',\n\t// a\n\ta:\t\td => d.getHours() >= 12 ? 'p' : 'a',\n\t// 09\n\tmm:\t\td => zeroPad2(d.getMinutes()),\n\t// 9\n\tm:\t\td => d.getMinutes(),\n\t// 09\n\tss:\t\td => zeroPad2(d.getSeconds()),\n\t// 9\n\ts:\t\td => d.getSeconds(),\n\t// 374\n\tfff:\td => zeroPad3(d.getMilliseconds()),\n};\n\nfunction fmtDate(tpl, names) {\n\tnames = names || engNames;\n\tlet parts = [];\n\n\tlet R = /\\{([a-z]+)\\}|[^{]+/gi, m;\n\n\twhile (m = R.exec(tpl))\n\t\tparts.push(m[0][0] == '{' ? subs[m[1]] : m[0]);\n\n\treturn d => {\n\t\tlet out = '';\n\n\t\tfor (let i = 0; i < parts.length; i++)\n\t\t\tout += typeof parts[i] == \"string\" ? parts[i] : parts[i](d, names);\n\n\t\treturn out;\n\t}\n}\n\nconst localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;\n\n// https://stackoverflow.com/questions/15141762/how-to-initialize-a-javascript-date-to-a-particular-time-zone/53652131#53652131\nfunction tzDate(date, tz) {\n\tlet date2;\n\n\t// perf optimization\n\tif (tz == 'UTC' || tz == 'Etc/UTC')\n\t\tdate2 = new Date(+date + date.getTimezoneOffset() * 6e4);\n\telse if (tz == localTz)\n\t\tdate2 = date;\n\telse {\n\t\tdate2 = new Date(date.toLocaleString('en-US', {timeZone: tz}));\n\t\tdate2.setMilliseconds(date.getMilliseconds());\n\t}\n\n\treturn date2;\n}\n\n//export const series = [];\n\n// default formatters:\n\nconst onlyWhole = v => v % 1 == 0;\n\nconst allMults = [1,2,2.5,5];\n\n// ...0.01, 0.02, 0.025, 0.05, 0.1, 0.2, 0.25, 0.5\nconst decIncrs = genIncrs(10, -16, 0, allMults);\n\n// 1, 2, 2.5, 5, 10, 20, 25, 50...\nconst oneIncrs = genIncrs(10, 0, 16, allMults);\n\n// 1, 2,      5, 10, 20, 25, 50...\nconst wholeIncrs = oneIncrs.filter(onlyWhole);\n\nconst numIncrs = decIncrs.concat(oneIncrs);\n\nconst NL = \"\\n\";\n\nconst yyyy    = \"{YYYY}\";\nconst NLyyyy  = NL + yyyy;\nconst md      = \"{M}/{D}\";\nconst NLmd    = NL + md;\nconst NLmdyy  = NLmd + \"/{YY}\";\n\nconst aa      = \"{aa}\";\nconst hmm     = \"{h}:{mm}\";\nconst hmmaa   = hmm + aa;\nconst NLhmmaa = NL + hmmaa;\nconst ss      = \":{ss}\";\n\nconst _ = null;\n\nfunction genTimeStuffs(ms) {\n\tlet\ts  = ms * 1e3,\n\t\tm  = s  * 60,\n\t\th  = m  * 60,\n\t\td  = h  * 24,\n\t\tmo = d  * 30,\n\t\ty  = d  * 365;\n\n\t// min of 1e-3 prevents setting a temporal x ticks too small since Date objects cannot advance ticks smaller than 1ms\n\tlet subSecIncrs = ms == 1 ? genIncrs(10, 0, 3, allMults).filter(onlyWhole) : genIncrs(10, -3, 0, allMults);\n\n\tlet timeIncrs = subSecIncrs.concat([\n\t\t// minute divisors (# of secs)\n\t\ts,\n\t\ts * 5,\n\t\ts * 10,\n\t\ts * 15,\n\t\ts * 30,\n\t\t// hour divisors (# of mins)\n\t\tm,\n\t\tm * 5,\n\t\tm * 10,\n\t\tm * 15,\n\t\tm * 30,\n\t\t// day divisors (# of hrs)\n\t\th,\n\t\th * 2,\n\t\th * 3,\n\t\th * 4,\n\t\th * 6,\n\t\th * 8,\n\t\th * 12,\n\t\t// month divisors TODO: need more?\n\t\td,\n\t\td * 2,\n\t\td * 3,\n\t\td * 4,\n\t\td * 5,\n\t\td * 6,\n\t\td * 7,\n\t\td * 8,\n\t\td * 9,\n\t\td * 10,\n\t\td * 15,\n\t\t// year divisors (# months, approx)\n\t\tmo,\n\t\tmo * 2,\n\t\tmo * 3,\n\t\tmo * 4,\n\t\tmo * 6,\n\t\t// century divisors\n\t\ty,\n\t\ty * 2,\n\t\ty * 5,\n\t\ty * 10,\n\t\ty * 25,\n\t\ty * 50,\n\t\ty * 100,\n\t]);\n\n\t// [0]:   minimum num secs in the tick incr\n\t// [1]:   default tick format\n\t// [2-7]: rollover tick formats\n\t// [8]:   mode: 0: replace [1] -> [2-7], 1: concat [1] + [2-7]\n\tconst _timeAxisStamps = [\n\t//   tick incr    default          year                    month   day                   hour    min       sec   mode\n\t\t[y,           yyyy,            _,                      _,      _,                    _,      _,        _,       1],\n\t\t[d * 28,      \"{MMM}\",         NLyyyy,                 _,      _,                    _,      _,        _,       1],\n\t\t[d,           md,              NLyyyy,                 _,      _,                    _,      _,        _,       1],\n\t\t[h,           \"{h}\" + aa,      NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],\n\t\t[m,           hmmaa,           NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],\n\t\t[s,           ss,              NLmdyy + \" \" + hmmaa,   _,      NLmd + \" \" + hmmaa,   _,      NLhmmaa,  _,       1],\n\t\t[ms,          ss + \".{fff}\",   NLmdyy + \" \" + hmmaa,   _,      NLmd + \" \" + hmmaa,   _,      NLhmmaa,  _,       1],\n\t];\n\n\t// the ensures that axis ticks, values & grid are aligned to logical temporal breakpoints and not an arbitrary timestamp\n\t// https://www.timeanddate.com/time/dst/\n\t// https://www.timeanddate.com/time/dst/2019.html\n\t// https://www.epochconverter.com/timezones\n\tfunction timeAxisSplits(tzDate) {\n\t\treturn (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {\n\t\t\tlet splits = [];\n\t\t\tlet isYr = foundIncr >= y;\n\t\t\tlet isMo = foundIncr >= mo && foundIncr < y;\n\n\t\t\t// get the timezone-adjusted date\n\t\t\tlet minDate = tzDate(scaleMin);\n\t\t\tlet minDateTs = roundDec(minDate * ms, 3);\n\n\t\t\t// get ts of 12am (this lands us at or before the original scaleMin)\n\t\t\tlet minMin = mkDate(minDate.getFullYear(), isYr ? 0 : minDate.getMonth(), isMo || isYr ? 1 : minDate.getDate());\n\t\t\tlet minMinTs = roundDec(minMin * ms, 3);\n\n\t\t\tif (isMo || isYr) {\n\t\t\t\tlet moIncr = isMo ? foundIncr / mo : 0;\n\t\t\t\tlet yrIncr = isYr ? foundIncr / y  : 0;\n\t\t\t//\tlet tzOffset = scaleMin - minDateTs;\t\t// needed?\n\t\t\t\tlet split = minDateTs == minMinTs ? minDateTs : roundDec(mkDate(minMin.getFullYear() + yrIncr, minMin.getMonth() + moIncr, 1) * ms, 3);\n\t\t\t\tlet splitDate = new Date(round(split / ms));\n\t\t\t\tlet baseYear = splitDate.getFullYear();\n\t\t\t\tlet baseMonth = splitDate.getMonth();\n\n\t\t\t\tfor (let i = 0; split <= scaleMax; i++) {\n\t\t\t\t\tlet next = mkDate(baseYear + yrIncr * i, baseMonth + moIncr * i, 1);\n\t\t\t\t\tlet offs = next - tzDate(roundDec(next * ms, 3));\n\n\t\t\t\t\tsplit = roundDec((+next + offs) * ms, 3);\n\n\t\t\t\t\tif (split <= scaleMax)\n\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet incr0 = foundIncr >= d ? d : foundIncr;\n\t\t\t\tlet tzOffset = floor(scaleMin) - floor(minDateTs);\n\t\t\t\tlet split = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);\n\t\t\t\tsplits.push(split);\n\n\t\t\t\tlet date0 = tzDate(split);\n\n\t\t\t\tlet prevHour = date0.getHours() + (date0.getMinutes() / m) + (date0.getSeconds() / h);\n\t\t\t\tlet incrHours = foundIncr / h;\n\n\t\t\t\tlet minSpace = self.axes[axisIdx]._space;\n\t\t\t\tlet pctSpace = foundSpace / minSpace;\n\n\t\t\t\twhile (1) {\n\t\t\t\t\tsplit = roundDec(split + foundIncr, ms == 1 ? 0 : 3);\n\n\t\t\t\t\tif (split > scaleMax)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (incrHours > 1) {\n\t\t\t\t\t\tlet expectedHour = floor(roundDec(prevHour + incrHours, 6)) % 24;\n\t\t\t\t\t\tlet splitDate = tzDate(split);\n\t\t\t\t\t\tlet actualHour = splitDate.getHours();\n\n\t\t\t\t\t\tlet dstShift = actualHour - expectedHour;\n\n\t\t\t\t\t\tif (dstShift > 1)\n\t\t\t\t\t\t\tdstShift = -1;\n\n\t\t\t\t\t\tsplit -= dstShift * h;\n\n\t\t\t\t\t\tprevHour = (prevHour + incrHours) % 24;\n\n\t\t\t\t\t\t// add a tick only if it's further than 70% of the min allowed label spacing\n\t\t\t\t\t\tlet prevSplit = splits[splits.length - 1];\n\t\t\t\t\t\tlet pctIncr = roundDec((split - prevSplit) / foundIncr, 3);\n\n\t\t\t\t\t\tif (pctIncr * pctSpace >= .7)\n\t\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsplits.push(split);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn splits;\n\t\t}\n\t}\n\n\treturn [\n\t\ttimeIncrs,\n\t\t_timeAxisStamps,\n\t\ttimeAxisSplits,\n\t];\n}\n\nconst [ timeIncrsMs, _timeAxisStampsMs, timeAxisSplitsMs ] = genTimeStuffs(1);\nconst [ timeIncrsS,  _timeAxisStampsS,  timeAxisSplitsS  ] = genTimeStuffs(1e-3);\n\n// base 2\ngenIncrs(2, -53, 53, [1]);\n\n/*\nconsole.log({\n\tdecIncrs,\n\toneIncrs,\n\twholeIncrs,\n\tnumIncrs,\n\ttimeIncrs,\n\tfixedDec,\n});\n*/\n\nfunction timeAxisStamps(stampCfg, fmtDate) {\n\treturn stampCfg.map(s => s.map((v, i) =>\n\t\ti == 0 || i == 8 || v == null ? v : fmtDate(i == 1 || s[8] == 0 ? v : s[1] + v)\n\t));\n}\n\n// TODO: will need to accept spaces[] and pull incr into the loop when grid will be non-uniform, eg for log scales.\n// currently we ignore this for months since they're *nearly* uniform and the added complexity is not worth it\nfunction timeAxisVals(tzDate, stamps) {\n\treturn (self, splits, axisIdx, foundSpace, foundIncr) => {\n\t\tlet s = stamps.find(s => foundIncr >= s[0]) || stamps[stamps.length - 1];\n\n\t\t// these track boundaries when a full label is needed again\n\t\tlet prevYear;\n\t\tlet prevMnth;\n\t\tlet prevDate;\n\t\tlet prevHour;\n\t\tlet prevMins;\n\t\tlet prevSecs;\n\n\t\treturn splits.map(split => {\n\t\t\tlet date = tzDate(split);\n\n\t\t\tlet newYear = date.getFullYear();\n\t\t\tlet newMnth = date.getMonth();\n\t\t\tlet newDate = date.getDate();\n\t\t\tlet newHour = date.getHours();\n\t\t\tlet newMins = date.getMinutes();\n\t\t\tlet newSecs = date.getSeconds();\n\n\t\t\tlet stamp = (\n\t\t\t\tnewYear != prevYear && s[2] ||\n\t\t\t\tnewMnth != prevMnth && s[3] ||\n\t\t\t\tnewDate != prevDate && s[4] ||\n\t\t\t\tnewHour != prevHour && s[5] ||\n\t\t\t\tnewMins != prevMins && s[6] ||\n\t\t\t\tnewSecs != prevSecs && s[7] ||\n\t\t\t\t                       s[1]\n\t\t\t);\n\n\t\t\tprevYear = newYear;\n\t\t\tprevMnth = newMnth;\n\t\t\tprevDate = newDate;\n\t\t\tprevHour = newHour;\n\t\t\tprevMins = newMins;\n\t\t\tprevSecs = newSecs;\n\n\t\t\treturn stamp(date);\n\t\t});\n\t}\n}\n\n// for when axis.values is defined as a static fmtDate template string\nfunction timeAxisVal(tzDate, dateTpl) {\n\tlet stamp = fmtDate(dateTpl);\n\treturn (self, splits, axisIdx, foundSpace, foundIncr) => splits.map(split => stamp(tzDate(split)));\n}\n\nfunction mkDate(y, m, d) {\n\treturn new Date(y, m, d);\n}\n\nfunction timeSeriesStamp(stampCfg, fmtDate) {\n\treturn fmtDate(stampCfg);\n}\nconst _timeSeriesStamp = '{YYYY}-{MM}-{DD} {h}:{mm}{aa}';\n\nfunction timeSeriesVal(tzDate, stamp) {\n\treturn (self, val, seriesIdx, dataIdx) => dataIdx == null ? LEGEND_DISP : stamp(tzDate(val));\n}\n\nfunction legendStroke(self, seriesIdx) {\n\tlet s = self.series[seriesIdx];\n\treturn s.width ? s.stroke(self, seriesIdx) : s.points.width ? s.points.stroke(self, seriesIdx) : null;\n}\n\nfunction legendFill(self, seriesIdx) {\n\treturn self.series[seriesIdx].fill(self, seriesIdx);\n}\n\nconst legendOpts = {\n\tshow: true,\n\tlive: true,\n\tisolate: false,\n\tmount: noop,\n\tmarkers: {\n\t\tshow: true,\n\t\twidth: 2,\n\t\tstroke: legendStroke,\n\t\tfill: legendFill,\n\t\tdash: \"solid\",\n\t},\n\tidx: null,\n\tidxs: null,\n\tvalues: [],\n};\n\nfunction cursorPointShow(self, si) {\n\tlet o = self.cursor.points;\n\n\tlet pt = placeDiv();\n\n\tlet size = o.size(self, si);\n\tsetStylePx(pt, WIDTH, size);\n\tsetStylePx(pt, HEIGHT, size);\n\n\tlet mar = size / -2;\n\tsetStylePx(pt, \"marginLeft\", mar);\n\tsetStylePx(pt, \"marginTop\", mar);\n\n\tlet width = o.width(self, si, size);\n\twidth && setStylePx(pt, \"borderWidth\", width);\n\n\treturn pt;\n}\n\nfunction cursorPointFill(self, si) {\n\tlet sp = self.series[si].points;\n\treturn sp._fill || sp._stroke;\n}\n\nfunction cursorPointStroke(self, si) {\n\tlet sp = self.series[si].points;\n\treturn sp._stroke || sp._fill;\n}\n\nfunction cursorPointSize(self, si) {\n\tlet sp = self.series[si].points;\n\treturn sp.size;\n}\n\nfunction dataIdx(self, seriesIdx, cursorIdx) {\n\treturn cursorIdx;\n}\n\nconst moveTuple = [0,0];\n\nfunction cursorMove(self, mouseLeft1, mouseTop1) {\n\tmoveTuple[0] = mouseLeft1;\n\tmoveTuple[1] = mouseTop1;\n\treturn moveTuple;\n}\n\nfunction filtBtn0(self, targ, handle, onlyTarg = true) {\n\treturn e => {\n\t\te.button == 0 && (!onlyTarg || e.target == targ) && handle(e);\n\t};\n}\n\nfunction filtTarg(self, targ, handle, onlyTarg = true) {\n\treturn e => {\n\t\t(!onlyTarg || e.target == targ) && handle(e);\n\t};\n}\n\nconst cursorOpts = {\n\tshow: true,\n\tx: true,\n\ty: true,\n\tlock: false,\n\tmove: cursorMove,\n\tpoints: {\n\t\tshow:   cursorPointShow,\n\t\tsize:   cursorPointSize,\n\t\twidth:  0,\n\t\tstroke: cursorPointStroke,\n\t\tfill:   cursorPointFill,\n\t},\n\n\tbind: {\n\t\tmousedown:   filtBtn0,\n\t\tmouseup:     filtBtn0,\n\t\tclick:       filtBtn0, // legend clicks, not .u-over clicks\n\t\tdblclick:    filtBtn0,\n\n\t\tmousemove:   filtTarg,\n\t\tmouseleave:  filtTarg,\n\t\tmouseenter:  filtTarg,\n\t},\n\n\tdrag: {\n\t\tsetScale: true,\n\t\tx: true,\n\t\ty: false,\n\t\tdist: 0,\n\t\tuni: null,\n\t\tclick: (self, e) => {\n\t\t//\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\te.stopImmediatePropagation();\n\t\t},\n\t\t_x: false,\n\t\t_y: false,\n\t},\n\n\tfocus: {\n\t\tprox: -1,\n\t\tbias: 0,\n\t},\n\n\tleft: -10,\n\ttop: -10,\n\tidx: null,\n\tdataIdx,\n\tidxs: null,\n\n\tevent: null,\n};\n\nconst axisLines = {\n\tshow: true,\n\tstroke: \"rgba(0,0,0,0.07)\",\n\twidth: 2,\n//\tdash: [],\n};\n\nconst grid = assign({}, axisLines, {\n\tfilter: retArg1,\n});\n\nconst ticks = assign({}, grid, {\n\tsize: 10,\n});\n\nconst border = assign({}, axisLines, {\n\tshow: false,\n});\n\nconst font      = '12px system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"';\nconst labelFont = \"bold \" + font;\nconst lineGap = 1.5;\t// font-size multiplier\n\nconst xAxisOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tstroke: hexBlack,\n\tspace: 50,\n\tgap: 5,\n\tsize: 50,\n\tlabelGap: 0,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 2,\n//\tclass: \"x-vals\",\n//\tincrs: timeIncrs,\n//\tvalues: timeVals,\n//\tfilter: retArg1,\n\tgrid,\n\tticks,\n\tborder,\n\tfont,\n\tlineGap,\n\trotate: 0,\n};\n\nconst numSeriesLabel = \"Value\";\nconst timeSeriesLabel = \"Time\";\n\nconst xSeriesOpts = {\n\tshow: true,\n\tscale: \"x\",\n\tauto: false,\n\tsorted: 1,\n//\tlabel: \"Time\",\n//\tvalue: v => stamp(new Date(v * 1e3)),\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n};\n\nfunction numAxisVals(self, splits, axisIdx, foundSpace, foundIncr) {\n\treturn splits.map(v => v == null ? \"\" : fmtNum(v));\n}\n\nfunction numAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tlet splits = [];\n\n\tlet numDec = fixedDec.get(foundIncr) || 0;\n\n\tscaleMin = forceMin ? scaleMin : roundDec(incrRoundUp(scaleMin, foundIncr), numDec);\n\n\tfor (let val = scaleMin; val <= scaleMax; val = roundDec(val + foundIncr, numDec))\n\t\tsplits.push(Object.is(val, -0) ? 0 : val);\t\t// coalesces -0\n\n\treturn splits;\n}\n\n// this doesnt work for sin, which needs to come off from 0 independently in pos and neg dirs\nfunction logAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tconst splits = [];\n\n\tconst logBase = self.scales[self.axes[axisIdx].scale].log;\n\n\tconst logFn = logBase == 10 ? log10 : log2;\n\n\tconst exp = floor(logFn(scaleMin));\n\n\tfoundIncr = pow(logBase, exp);\n\n\tif (logBase == 10 && exp < 0)\n\t\tfoundIncr = roundDec(foundIncr, -exp);\n\n\tlet split = scaleMin;\n\n\tdo {\n\t\tsplits.push(split);\n\t\tsplit = split + foundIncr;\n\n\t\tif (logBase == 10)\n\t\t\tsplit = roundDec(split, fixedDec.get(foundIncr));\n\n\t\tif (split >= foundIncr * logBase)\n\t\t\tfoundIncr = split;\n\n\t} while (split <= scaleMax);\n\n\treturn splits;\n}\n\nfunction asinhAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {\n\tlet sc = self.scales[self.axes[axisIdx].scale];\n\n\tlet linthresh = sc.asinh;\n\n\tlet posSplits = scaleMax > linthresh ? logAxisSplits(self, axisIdx, max(linthresh, scaleMin), scaleMax, foundIncr) : [linthresh];\n\tlet zero = scaleMax >= 0 && scaleMin <= 0 ? [0] : [];\n\tlet negSplits = scaleMin < -linthresh ? logAxisSplits(self, axisIdx, max(linthresh, -scaleMax), -scaleMin, foundIncr): [linthresh];\n\n\treturn negSplits.reverse().map(v => -v).concat(zero, posSplits);\n}\n\nconst RE_ALL   = /./;\nconst RE_12357 = /[12357]/;\nconst RE_125   = /[125]/;\nconst RE_1     = /1/;\n\nconst _filt = (splits, distr, re, keepMod) => splits.map((v, i) => ((distr == 4 && v == 0) || i % keepMod == 0 && re.test(v.toExponential()[v < 0 ? 1 : 0])) ? v : null);\n\nfunction log10AxisValsFilt(self, splits, axisIdx, foundSpace, foundIncr) {\n\tlet axis = self.axes[axisIdx];\n\tlet scaleKey = axis.scale;\n\tlet sc = self.scales[scaleKey];\n\n//\tif (sc.distr == 3 && sc.log == 2)\n//\t\treturn splits;\n\n\tlet valToPos = self.valToPos;\n\n\tlet minSpace = axis._space;\n\n\tlet _10 = valToPos(10, scaleKey);\n\n\tlet re = (\n\t\tvalToPos(9, scaleKey) - _10 >= minSpace ? RE_ALL :\n\t\tvalToPos(7, scaleKey) - _10 >= minSpace ? RE_12357 :\n\t\tvalToPos(5, scaleKey) - _10 >= minSpace ? RE_125 :\n\t\tRE_1\n\t);\n\n\tif (re == RE_1) {\n\t\tlet magSpace = abs(valToPos(1, scaleKey) - _10);\n\n\t\tif (magSpace < minSpace)\n\t\t\treturn _filt(splits.slice().reverse(), sc.distr, re, ceil(minSpace / magSpace)).reverse(); // max->min skip\n\t}\n\n\treturn _filt(splits, sc.distr, re, 1);\n}\n\nfunction log2AxisValsFilt(self, splits, axisIdx, foundSpace, foundIncr) {\n\tlet axis = self.axes[axisIdx];\n\tlet scaleKey = axis.scale;\n\tlet minSpace = axis._space;\n\tlet valToPos = self.valToPos;\n\n\tlet magSpace = abs(valToPos(1, scaleKey) - valToPos(2, scaleKey));\n\n\tif (magSpace < minSpace)\n\t\treturn _filt(splits.slice().reverse(), 3, RE_ALL, ceil(minSpace / magSpace)).reverse(); // max->min skip\n\n\treturn splits;\n}\n\nfunction numSeriesVal(self, val, seriesIdx, dataIdx) {\n\treturn dataIdx == null ? LEGEND_DISP : val == null ? \"\" : fmtNum(val);\n}\n\nconst yAxisOpts = {\n\tshow: true,\n\tscale: \"y\",\n\tstroke: hexBlack,\n\tspace: 30,\n\tgap: 5,\n\tsize: 50,\n\tlabelGap: 0,\n\tlabelSize: 30,\n\tlabelFont,\n\tside: 3,\n//\tclass: \"y-vals\",\n//\tincrs: numIncrs,\n//\tvalues: (vals, space) => vals,\n//\tfilter: retArg1,\n\tgrid,\n\tticks,\n\tborder,\n\tfont,\n\tlineGap,\n\trotate: 0,\n};\n\n// takes stroke width\nfunction ptDia(width, mult) {\n\tlet dia = 3 + (width || 1) * 2;\n\treturn roundDec(dia * mult, 3);\n}\n\nfunction seriesPointsShow(self, si) {\n\tlet { scale, idxs } = self.series[0];\n\tlet xData = self._data[0];\n\tlet p0 = self.valToPos(xData[idxs[0]], scale, true);\n\tlet p1 = self.valToPos(xData[idxs[1]], scale, true);\n\tlet dim = abs(p1 - p0);\n\n\tlet s = self.series[si];\n//\tconst dia = ptDia(s.width, pxRatio);\n\tlet maxPts = dim / (s.points.space * pxRatio);\n\treturn idxs[1] - idxs[0] <= maxPts;\n}\n\nconst facet = {\n\tscale: null,\n\tauto: true,\n\tsorted: 0,\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n};\n\nconst gaps = (self, seriesIdx, idx0, idx1, nullGaps) => nullGaps;\n\nconst xySeriesOpts = {\n\tshow: true,\n\tauto: true,\n\tsorted: 0,\n\tgaps,\n\talpha: 1,\n\tfacets: [\n\t\tassign({}, facet, {scale: 'x'}),\n\t\tassign({}, facet, {scale: 'y'}),\n\t],\n};\n\nconst ySeriesOpts = {\n\tscale: \"y\",\n\tauto: true,\n\tsorted: 0,\n\tshow: true,\n\tspanGaps: false,\n\tgaps,\n\talpha: 1,\n\tpoints: {\n\t\tshow: seriesPointsShow,\n\t\tfilter: null,\n\t//  paths:\n\t//\tstroke: \"#000\",\n\t//\tfill: \"#fff\",\n\t//\twidth: 1,\n\t//\tsize: 10,\n\t},\n//\tlabel: \"Value\",\n//\tvalue: v => v,\n\tvalues: null,\n\n\t// internal caches\n\tmin: inf,\n\tmax: -inf,\n\tidxs: [],\n\n\tpath: null,\n\tclip: null,\n};\n\nfunction clampScale(self, val, scaleMin, scaleMax, scaleKey) {\n/*\n\tif (val < 0) {\n\t\tlet cssHgt = self.bbox.height / pxRatio;\n\t\tlet absPos = self.valToPos(abs(val), scaleKey);\n\t\tlet fromBtm = cssHgt - absPos;\n\t\treturn self.posToVal(cssHgt + fromBtm, scaleKey);\n\t}\n*/\n\treturn scaleMin / 10;\n}\n\nconst xScaleOpts = {\n\ttime: FEAT_TIME,\n\tauto: true,\n\tdistr: 1,\n\tlog: 10,\n\tasinh: 1,\n\tmin: null,\n\tmax: null,\n\tdir: 1,\n\tori: 0,\n};\n\nconst yScaleOpts = assign({}, xScaleOpts, {\n\ttime: false,\n\tori: 1,\n});\n\nconst syncs = {};\n\nfunction _sync(key, opts) {\n\tlet s = syncs[key];\n\n\tif (!s) {\n\t\ts = {\n\t\t\tkey,\n\t\t\tplots: [],\n\t\t\tsub(plot) {\n\t\t\t\ts.plots.push(plot);\n\t\t\t},\n\t\t\tunsub(plot) {\n\t\t\t\ts.plots = s.plots.filter(c => c != plot);\n\t\t\t},\n\t\t\tpub(type, self, x, y, w, h, i) {\n\t\t\t\tfor (let j = 0; j < s.plots.length; j++)\n\t\t\t\t\ts.plots[j] != self && s.plots[j].pub(type, self, x, y, w, h, i);\n\t\t\t},\n\t\t};\n\n\t\tif (key != null)\n\t\t\tsyncs[key] = s;\n\t}\n\n\treturn s;\n}\n\nconst BAND_CLIP_FILL   = 1 << 0;\nconst BAND_CLIP_STROKE = 1 << 1;\n\nfunction orient(u, seriesIdx, cb) {\n\tconst mode = u.mode;\n\tconst series = u.series[seriesIdx];\n\tconst data = mode == 2 ? u._data[seriesIdx] : u._data;\n\tconst scales = u.scales;\n\tconst bbox   = u.bbox;\n\n\tlet dx = data[0],\n\t\tdy = mode == 2 ? data[1] : data[seriesIdx],\n\t\tsx = mode == 2 ? scales[series.facets[0].scale] : scales[u.series[0].scale],\n\t\tsy = mode == 2 ? scales[series.facets[1].scale] : scales[series.scale],\n\t\tl = bbox.left,\n\t\tt = bbox.top,\n\t\tw = bbox.width,\n\t\th = bbox.height,\n\t\tH = u.valToPosH,\n\t\tV = u.valToPosV;\n\n\treturn (sx.ori == 0\n\t\t? cb(\n\t\t\tseries,\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tsx,\n\t\t\tsy,\n\t\t\tH,\n\t\t\tV,\n\t\t\tl,\n\t\t\tt,\n\t\t\tw,\n\t\t\th,\n\t\t\tmoveToH,\n\t\t\tlineToH,\n\t\t\trectH,\n\t\t\tarcH,\n\t\t\tbezierCurveToH,\n\t\t)\n\t\t: cb(\n\t\t\tseries,\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tsx,\n\t\t\tsy,\n\t\t\tV,\n\t\t\tH,\n\t\t\tt,\n\t\t\tl,\n\t\t\th,\n\t\t\tw,\n\t\t\tmoveToV,\n\t\t\tlineToV,\n\t\t\trectV,\n\t\t\tarcV,\n\t\t\tbezierCurveToV,\n\t\t)\n\t);\n}\n\nfunction bandFillClipDirs(self, seriesIdx) {\n\tlet fillDir = 0;\n\n\t// 2 bits, -1 | 1\n\tlet clipDirs = 0;\n\n\tlet bands = ifNull(self.bands, EMPTY_ARR);\n\n\tfor (let i = 0; i < bands.length; i++) {\n\t\tlet b = bands[i];\n\n\t\t// is a \"from\" band edge\n\t\tif (b.series[0] == seriesIdx)\n\t\t\tfillDir = b.dir;\n\t\t// is a \"to\" band edge\n\t\telse if (b.series[1] == seriesIdx) {\n\t\t\tif (b.dir == 1)\n\t\t\t\tclipDirs |= 1;\n\t\t\telse\n\t\t\t\tclipDirs |= 2;\n\t\t}\n\t}\n\n\treturn [\n\t\tfillDir,\n\t\t(\n\t\t\tclipDirs == 1 ? -1 : // neg only\n\t\t\tclipDirs == 2 ?  1 : // pos only\n\t\t\tclipDirs == 3 ?  2 : // both\n\t\t\t                 0   // neither\n\t\t)\n\t];\n}\n\nfunction seriesFillTo(self, seriesIdx, dataMin, dataMax, bandFillDir) {\n\tlet mode = self.mode;\n\tlet series = self.series[seriesIdx];\n\tlet scaleKey = mode == 2 ? series.facets[1].scale : series.scale;\n\tlet scale = self.scales[scaleKey];\n\n\treturn (\n\t\tbandFillDir == -1 ? scale.min :\n\t\tbandFillDir ==  1 ? scale.max :\n\t\tscale.distr ==  3 ? (\n\t\t\tscale.dir == 1 ? scale.min :\n\t\t\tscale.max\n\t\t) : 0\n\t);\n}\n\n// creates inverted band clip path (from stroke path -> yMax || yMin)\n// clipDir is always inverse of fillDir\n// default clip dir is upwards (1), since default band fill is downwards/fillBelowTo (-1) (highIdx -> lowIdx)\nfunction clipBandLine(self, seriesIdx, idx0, idx1, strokePath, clipDir) {\n\treturn orient(self, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\tlet pxRound = series.pxRound;\n\n\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\t\tconst lineTo = scaleX.ori == 0 ? lineToH : lineToV;\n\n\t\tlet frIdx, toIdx;\n\n\t\tif (dir == 1) {\n\t\t\tfrIdx = idx0;\n\t\t\ttoIdx = idx1;\n\t\t}\n\t\telse {\n\t\t\tfrIdx = idx1;\n\t\t\ttoIdx = idx0;\n\t\t}\n\n\t\t// path start\n\t\tlet x0 = pxRound(valToPosX(dataX[frIdx], scaleX, xDim, xOff));\n\t\tlet y0 = pxRound(valToPosY(dataY[frIdx], scaleY, yDim, yOff));\n\t\t// path end x\n\t\tlet x1 = pxRound(valToPosX(dataX[toIdx], scaleX, xDim, xOff));\n\t\t// upper or lower y limit\n\t\tlet yLimit = pxRound(valToPosY(clipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));\n\n\t\tlet clip = new Path2D(strokePath);\n\n\t\tlineTo(clip, x1, yLimit);\n\t\tlineTo(clip, x0, yLimit);\n\t\tlineTo(clip, x0, y0);\n\n\t\treturn clip;\n\t});\n}\n\nfunction clipGaps(gaps, ori, plotLft, plotTop, plotWid, plotHgt) {\n\tlet clip = null;\n\n\t// create clip path (invert gaps and non-gaps)\n\tif (gaps.length > 0) {\n\t\tclip = new Path2D();\n\n\t\tconst rect = ori == 0 ? rectH : rectV;\n\n\t\tlet prevGapEnd = plotLft;\n\n\t\tfor (let i = 0; i < gaps.length; i++) {\n\t\t\tlet g = gaps[i];\n\n\t\t\tif (g[1] > g[0]) {\n\t\t\t\tlet w = g[0] - prevGapEnd;\n\n\t\t\t\tw > 0 && rect(clip, prevGapEnd, plotTop, w, plotTop + plotHgt);\n\n\t\t\t\tprevGapEnd = g[1];\n\t\t\t}\n\t\t}\n\n\t\tlet w = plotLft + plotWid - prevGapEnd;\n\n\t\t// hack to ensure we expand the clip enough to avoid cutting off strokes at edges\n\t\tlet maxStrokeWidth = 10;\n\n\t\tw > 0 && rect(clip, prevGapEnd, plotTop - maxStrokeWidth / 2, w, plotTop + plotHgt + maxStrokeWidth);\n\t}\n\n\treturn clip;\n}\n\nfunction addGap(gaps, fromX, toX) {\n\tlet prevGap = gaps[gaps.length - 1];\n\n\tif (prevGap && prevGap[0] == fromX)\t\t\t// TODO: gaps must be encoded at stroke widths?\n\t\tprevGap[1] = toX;\n\telse\n\t\tgaps.push([fromX, toX]);\n}\n\nfunction findGaps(xs, ys, idx0, idx1, dir, pixelForX, align) {\n\tlet gaps = [];\n\tlet len = xs.length;\n\n\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\tlet yVal = ys[i];\n\n\t\tif (yVal === null) {\n\t\t\tlet fr = i, to = i;\n\n\t\t\tif (dir == 1) {\n\t\t\t\twhile (++i <= idx1 && ys[i] === null)\n\t\t\t\t\tto = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (--i >= idx0 && ys[i] === null)\n\t\t\t\t\tto = i;\n\t\t\t}\n\n\t\t\tlet frPx = pixelForX(xs[fr]);\n\t\t\tlet toPx = to == fr ? frPx : pixelForX(xs[to]);\n\n\t\t\t// if value adjacent to edge null is same pixel, then it's partially\n\t\t\t// filled and gap should start at next pixel\n\t\t\tlet fri2 = fr - dir;\n\t\t\tlet frPx2 = align <= 0 && fri2 >= 0 && fri2 < len ? pixelForX(xs[fri2]) : frPx;\n\t\t//\tif (frPx2 == frPx)\n\t\t//\t\tfrPx++;\n\t\t//\telse\n\t\t\t\tfrPx = frPx2;\n\n\t\t\tlet toi2 = to + dir;\n\t\t\tlet toPx2 = align >= 0 && toi2 >= 0 && toi2 < len ? pixelForX(xs[toi2]) : toPx;\n\t\t//\tif (toPx2 == toPx)\n\t\t//\t\ttoPx--;\n\t\t//\telse\n\t\t\t\ttoPx = toPx2;\n\n\t\t\tif (toPx >= frPx)\n\t\t\t\tgaps.push([frPx, toPx]); // addGap\n\t\t}\n\t}\n\n\treturn gaps;\n}\n\nfunction pxRoundGen(pxAlign) {\n\treturn pxAlign == 0 ? retArg0 : pxAlign == 1 ? round : v => incrRound(v, pxAlign);\n}\n\nfunction rect(ori) {\n\tlet moveTo = ori == 0 ?\n\t\tmoveToH :\n\t\tmoveToV;\n\n\tlet arcTo = ori == 0 ?\n\t\t(p, x1, y1, x2, y2, r) => { p.arcTo(x1, y1, x2, y2, r); } :\n\t\t(p, y1, x1, y2, x2, r) => { p.arcTo(x1, y1, x2, y2, r); };\n\n\tlet rect = ori == 0 ?\n\t\t(p, x, y, w, h) => { p.rect(x, y, w, h); } :\n\t\t(p, y, x, h, w) => { p.rect(x, y, w, h); };\n\n\t// TODO (pending better browser support): https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/roundRect\n\treturn (p, x, y, w, h, endRad = 0, baseRad = 0) => {\n\t\tif (endRad == 0 && baseRad == 0)\n\t\t\trect(p, x, y, w, h);\n\t\telse {\n\t\t\tendRad  = min(endRad,  w / 2, h / 2);\n\t\t\tbaseRad = min(baseRad, w / 2, h / 2);\n\n\t\t\t// adapted from https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-using-html-canvas/7838871#7838871\n\t\t\tmoveTo(p, x + endRad, y);\n\t\t\tarcTo(p, x + w, y, x + w, y + h, endRad);\n\t\t\tarcTo(p, x + w, y + h, x, y + h, baseRad);\n\t\t\tarcTo(p, x, y + h, x, y, baseRad);\n\t\t\tarcTo(p, x, y, x + w, y, endRad);\n\t\t\tp.closePath();\n\t\t}\n\t};\n}\n\n// orientation-inverting canvas functions\nconst moveToH = (p, x, y) => { p.moveTo(x, y); };\nconst moveToV = (p, y, x) => { p.moveTo(x, y); };\nconst lineToH = (p, x, y) => { p.lineTo(x, y); };\nconst lineToV = (p, y, x) => { p.lineTo(x, y); };\nconst rectH = rect(0);\nconst rectV = rect(1);\nconst arcH = (p, x, y, r, startAngle, endAngle) => { p.arc(x, y, r, startAngle, endAngle); };\nconst arcV = (p, y, x, r, startAngle, endAngle) => { p.arc(x, y, r, startAngle, endAngle); };\nconst bezierCurveToH = (p, bp1x, bp1y, bp2x, bp2y, p2x, p2y) => { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); };\nconst bezierCurveToV = (p, bp1y, bp1x, bp2y, bp2x, p2y, p2x) => { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); };\n\n// TODO: drawWrap(seriesIdx, drawPoints) (save, restore, translate, clip)\nfunction points(opts) {\n\treturn (u, seriesIdx, idx0, idx1, filtIdxs) => {\n\t//\tlog(\"drawPoints()\", arguments);\n\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet { pxRound, points } = series;\n\n\t\t\tlet moveTo, arc;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tmoveTo = moveToH;\n\t\t\t\tarc = arcH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoveTo = moveToV;\n\t\t\t\tarc = arcV;\n\t\t\t}\n\n\t\t\tconst width = roundDec(points.width * pxRatio, 3);\n\n\t\t\tlet rad = (points.size - points.width) / 2 * pxRatio;\n\t\t\tlet dia = roundDec(rad * 2, 3);\n\n\t\t\tlet fill = new Path2D();\n\t\t\tlet clip = new Path2D();\n\n\t\t\tlet { left: lft, top: top, width: wid, height: hgt } = u.bbox;\n\n\t\t\trectH(clip,\n\t\t\t\tlft - dia,\n\t\t\t\ttop - dia,\n\t\t\t\twid + dia * 2,\n\t\t\t\thgt + dia * 2,\n\t\t\t);\n\n\t\t\tconst drawPoint = pi => {\n\t\t\t\tif (dataY[pi] != null) {\n\t\t\t\t\tlet x = pxRound(valToPosX(dataX[pi], scaleX, xDim, xOff));\n\t\t\t\t\tlet y = pxRound(valToPosY(dataY[pi], scaleY, yDim, yOff));\n\n\t\t\t\t\tmoveTo(fill, x + rad, y);\n\t\t\t\t\tarc(fill, x, y, rad, 0, PI * 2);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (filtIdxs)\n\t\t\t\tfiltIdxs.forEach(drawPoint);\n\t\t\telse {\n\t\t\t\tfor (let pi = idx0; pi <= idx1; pi++)\n\t\t\t\t\tdrawPoint(pi);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tstroke: width > 0 ? fill : null,\n\t\t\t\tfill,\n\t\t\t\tclip,\n\t\t\t\tflags: BAND_CLIP_FILL | BAND_CLIP_STROKE,\n\t\t\t};\n\t\t});\n\t};\n}\n\nfunction _drawAcc(lineTo) {\n\treturn (stroke, accX, minY, maxY, inY, outY) => {\n\t\tif (minY != maxY) {\n\t\t\tif (inY != minY && outY != minY)\n\t\t\t\tlineTo(stroke, accX, minY);\n\t\t\tif (inY != maxY && outY != maxY)\n\t\t\t\tlineTo(stroke, accX, maxY);\n\n\t\t\tlineTo(stroke, accX, outY);\n\t\t}\n\t};\n}\n\nconst drawAccH = _drawAcc(lineToH);\nconst drawAccV = _drawAcc(lineToV);\n\nfunction linear(opts) {\n\tconst alignGaps = ifNull(opts?.alignGaps, 0);\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));\n\t\t\tlet pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));\n\n\t\t\tlet lineTo, drawAcc;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tlineTo = lineToH;\n\t\t\t\tdrawAcc = drawAccH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlineTo = lineToV;\n\t\t\t\tdrawAcc = drawAccV;\n\t\t\t}\n\n\t\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tconst _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tlet minY = inf,\n\t\t\t\tmaxY = -inf,\n\t\t\t\tinY, outY, drawnAtX;\n\n\t\t\tlet accX = pixelForX(dataX[dir == 1 ? idx0 : idx1]);\n\n\t\t\t// data edges\n\t\t\tlet lftIdx = nonNullIdx(dataY, idx0, idx1,  1 * dir);\n\t\t\tlet rgtIdx = nonNullIdx(dataY, idx0, idx1, -1 * dir);\n\t\t\tlet lftX   =  pixelForX(dataX[lftIdx]);\n\t\t\tlet rgtX   =  pixelForX(dataX[rgtIdx]);\n\n\t\t\tlet hasGap = false;\n\n\t\t\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\t\t\tlet x = pixelForX(dataX[i]);\n\t\t\t\tlet yVal = dataY[i];\n\n\t\t\t\tif (x == accX) {\n\t\t\t\t\tif (yVal != null) {\n\t\t\t\t\t\toutY = pixelForY(yVal);\n\n\t\t\t\t\t\tif (minY == inf) {\n\t\t\t\t\t\t\tlineTo(stroke, x, outY);\n\t\t\t\t\t\t\tinY = outY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tminY = min(outY, minY);\n\t\t\t\t\t\tmaxY = max(outY, maxY);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (yVal === null)\n\t\t\t\t\t\t\thasGap = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (minY != inf) {\n\t\t\t\t\t\tdrawAcc(stroke, accX, minY, maxY, inY, outY);\n\t\t\t\t\t\tdrawnAtX = accX;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (yVal != null) {\n\t\t\t\t\t\toutY = pixelForY(yVal);\n\t\t\t\t\t\tlineTo(stroke, x, outY);\n\t\t\t\t\t\tminY = maxY = inY = outY;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tminY = inf;\n\t\t\t\t\t\tmaxY = -inf;\n\n\t\t\t\t\t\tif (yVal === null)\n\t\t\t\t\t\t\thasGap = true;\n\t\t\t\t\t}\n\n\t\t\t\t\taccX = x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minY != inf && minY != maxY && drawnAtX != accX)\n\t\t\t\tdrawAcc(stroke, accX, minY, maxY, inY, outY);\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t\tif (series.fill != null || bandFillDir != 0) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillToVal = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\t\tlet fillToY = pixelForY(fillToVal);\n\n\t\t\t\tlineTo(fill, rgtX, fillToY);\n\t\t\t\tlineTo(fill, lftX, fillToY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps) {\n\t\t\t//\tconsole.time('gaps');\n\t\t\t\tlet gaps = [];\n\n\t\t\t\thasGap && gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));\n\n\t\t\t//\tconsole.timeEnd('gaps');\n\n\t\t\t//\tconsole.log('gaps', JSON.stringify(gaps));\n\n\t\t\t\t_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);\n\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\t\t\t}\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = bandClipDir == 2 ? [\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),\n\t\t\t\t] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);\n\t\t\t}\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\n// BUG: align: -1 behaves like align: 1 when scale.dir: -1\nfunction stepped(opts) {\n\tconst align = ifNull(opts.align, 1);\n\t// whether to draw ascenders/descenders at null/gap bondaries\n\tconst ascDesc = ifNull(opts.ascDesc, false);\n\tconst alignGaps = ifNull(opts.alignGaps, 0);\n\tconst extend = ifNull(opts.extend, false);\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet { left, width } = u.bbox;\n\n\t\t\tlet pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));\n\t\t\tlet pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));\n\n\t\t\tlet lineTo = scaleX.ori == 0 ? lineToH : lineToV;\n\n\t\t\tconst _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tidx0 = nonNullIdx(dataY, idx0, idx1,  1);\n\t\t\tidx1 = nonNullIdx(dataY, idx0, idx1, -1);\n\n\t\t\tlet prevYPos  = pixelForY(dataY[dir == 1 ? idx0 : idx1]);\n\t\t\tlet firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);\n\t\t\tlet prevXPos = firstXPos;\n\n\t\t\tlet firstXPosExt = firstXPos;\n\n\t\t\tif (extend && align == -1) {\n\t\t\t\tfirstXPosExt = left;\n\t\t\t\tlineTo(stroke, firstXPosExt, prevYPos);\n\t\t\t}\n\n\t\t\tlineTo(stroke, firstXPos, prevYPos);\n\n\t\t\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\t\t\tlet yVal1 = dataY[i];\n\n\t\t\t\tif (yVal1 == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlet x1 = pixelForX(dataX[i]);\n\t\t\t\tlet y1 = pixelForY(yVal1);\n\n\t\t\t\tif (align == 1)\n\t\t\t\t\tlineTo(stroke, x1, prevYPos);\n\t\t\t\telse\n\t\t\t\t\tlineTo(stroke, prevXPos, y1);\n\n\t\t\t\tlineTo(stroke, x1, y1);\n\n\t\t\t\tprevYPos = y1;\n\t\t\t\tprevXPos = x1;\n\t\t\t}\n\n\t\t\tlet prevXPosExt = prevXPos;\n\n\t\t\tif (extend && align == 1) {\n\t\t\t\tprevXPosExt = left + width;\n\t\t\t\tlineTo(stroke, prevXPosExt, prevYPos);\n\t\t\t}\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t\tif (series.fill != null || bandFillDir != 0) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\t\tlet fillToY = pixelForY(fillTo);\n\n\t\t\t\tlineTo(fill, prevXPosExt, fillToY);\n\t\t\t\tlineTo(fill, firstXPosExt, fillToY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps) {\n\t\t\t//\tconsole.time('gaps');\n\t\t\t\tlet gaps = [];\n\n\t\t\t\tgaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));\n\n\t\t\t//\tconsole.timeEnd('gaps');\n\n\t\t\t//\tconsole.log('gaps', JSON.stringify(gaps));\n\n\t\t\t\t// expand/contract clips for ascenders/descenders\n\t\t\t\tlet halfStroke = (series.width * pxRatio) / 2;\n\t\t\t\tlet startsOffset = (ascDesc || align ==  1) ?  halfStroke : -halfStroke;\n\t\t\t\tlet endsOffset   = (ascDesc || align == -1) ? -halfStroke :  halfStroke;\n\n\t\t\t\tgaps.forEach(g => {\n\t\t\t\t\tg[0] += startsOffset;\n\t\t\t\t\tg[1] += endsOffset;\n\t\t\t\t});\n\n\t\t\t\t_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);\n\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\t\t\t}\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = bandClipDir == 2 ? [\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),\n\t\t\t\t] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);\n\t\t\t}\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction bars(opts) {\n\topts = opts || EMPTY_OBJ;\n\tconst size = ifNull(opts.size, [0.6, inf, 1]);\n\tconst align = opts.align || 0;\n\tconst extraGap = (opts.gap || 0) * pxRatio;\n\n\tlet ro = opts.radius;\n\n\tro =\n\t\t// [valueRadius, baselineRadius]\n\t\tro == null ? [0, 0] :\n\t\ttypeof ro == 'number' ? [ro, 0] : ro;\n\n\tconst radiusFn = fnOrSelf(ro);\n\n\tconst gapFactor = 1 - size[0];\n\tconst maxWidth  = ifNull(size[1], inf) * pxRatio;\n\tconst minWidth  = ifNull(size[2], 1) * pxRatio;\n\n\tconst disp = ifNull(opts.disp, EMPTY_OBJ);\n\tconst _each = ifNull(opts.each, _ => {});\n\n\tconst { fill: dispFills, stroke: dispStrokes } = disp;\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet valRadius, baseRadius;\n\n\t\t\tif (scaleX.ori == 0)\n\t\t\t\t[valRadius, baseRadius] = radiusFn(u, seriesIdx);\n\t\t\telse\n\t\t\t\t[baseRadius, valRadius] = radiusFn(u, seriesIdx);\n\n\t\t\tconst _dirX = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\t\t\tconst _dirY = scaleY.dir * (scaleY.ori == 1 ? 1 : -1);\n\n\t\t\tlet rect = scaleX.ori == 0 ? rectH : rectV;\n\n\t\t\tlet each = scaleX.ori == 0 ? _each : (u, seriesIdx, i, top, lft, hgt, wid) => {\n\t\t\t\t_each(u, seriesIdx, i, lft, top, wid, hgt);\n\t\t\t};\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t//\tlet fillToY = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\tlet fillToY = scaleY.distr == 3 ? (bandFillDir == 1 ? scaleY.max : scaleY.min) : 0;\n\n\t\t\tlet y0Pos = valToPosY(fillToY, scaleY, yDim, yOff);\n\n\t\t\t// barWid is to center of stroke\n\t\t\tlet xShift, barWid;\n\n\t\t\tlet strokeWidth = pxRound(series.width * pxRatio);\n\n\t\t\tlet multiPath = false;\n\n\t\t\tlet fillColors = null;\n\t\t\tlet fillPaths = null;\n\t\t\tlet strokeColors = null;\n\t\t\tlet strokePaths = null;\n\n\t\t\tif (dispFills != null && (strokeWidth == 0 || dispStrokes != null)) {\n\t\t\t\tmultiPath = true;\n\n\t\t\t\tfillColors = dispFills.values(u, seriesIdx, idx0, idx1);\n\t\t\t\tfillPaths = new Map();\n\t\t\t\t(new Set(fillColors)).forEach(color => {\n\t\t\t\t\tif (color != null)\n\t\t\t\t\t\tfillPaths.set(color, new Path2D());\n\t\t\t\t});\n\n\t\t\t\tif (strokeWidth > 0) {\n\t\t\t\t\tstrokeColors = dispStrokes.values(u, seriesIdx, idx0, idx1);\n\t\t\t\t\tstrokePaths = new Map();\n\t\t\t\t\t(new Set(strokeColors)).forEach(color => {\n\t\t\t\t\t\tif (color != null)\n\t\t\t\t\t\t\tstrokePaths.set(color, new Path2D());\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet { x0, size } = disp;\n\n\t\t\tlet bandClipNulls = true;\n\n\t\t\tif (x0 != null && size != null) {\n\t\t\t\tdataX = x0.values(u, seriesIdx, idx0, idx1);\n\n\t\t\t\tif (x0.unit == 2)\n\t\t\t\t\tdataX = dataX.map(pct => u.posToVal(xOff + pct * xDim, scaleX.key, true));\n\n\t\t\t\t// assumes uniform sizes, for now\n\t\t\t\tlet sizes = size.values(u, seriesIdx, idx0, idx1);\n\n\t\t\t\tif (size.unit == 2)\n\t\t\t\t\tbarWid = sizes[0] * xDim;\n\t\t\t\telse\n\t\t\t\t\tbarWid = valToPosX(sizes[0], scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff); // assumes linear scale (delta from 0)\n\n\t\t\t\tif (strokeWidth >= barWid / 2)\n\t\t\t\t\tstrokeWidth = 0;\n\n\t\t\t\t// for small gaps, disable pixel snapping since gap inconsistencies become noticible and annoying\n\t\t\t//\tif (gapWid + extraGap < 5)\n\t\t\t//\t\tpxRound = retArg0;\n\n\t\t\t\tbarWid = pxRound(clamp(barWid - strokeWidth, minWidth, maxWidth)); // TODO: extraGap?\n\n\t\t\t\txShift = (_dirX == 1 ? -strokeWidth / 2 : barWid + strokeWidth / 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet colWid = xDim;\n\n\t\t\t\tif (dataX.length > 1) {\n\t\t\t\t\t// prior index with non-undefined y data\n\t\t\t\t\tlet prevIdx = null;\n\n\t\t\t\t\t// scan full dataset for smallest adjacent delta\n\t\t\t\t\t// will not work properly for non-linear x scales, since does not do expensive valToPosX calcs till end\n\t\t\t\t\tfor (let i = 0, minDelta = Infinity; i < dataX.length; i++) {\n\t\t\t\t\t\tif (dataY[i] !== undefined) {\n\t\t\t\t\t\t\tif (prevIdx != null) {\n\t\t\t\t\t\t\t\tlet delta = abs(dataX[i] - dataX[prevIdx]);\n\n\t\t\t\t\t\t\t\tif (delta < minDelta) {\n\t\t\t\t\t\t\t\t\tminDelta = delta;\n\t\t\t\t\t\t\t\t\tcolWid = abs(valToPosX(dataX[i], scaleX, xDim, xOff) - valToPosX(dataX[prevIdx], scaleX, xDim, xOff));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprevIdx = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet gapWid = colWid * gapFactor;\n\n\t\t\t\tbarWid = colWid - gapWid - extraGap;\n\n\t\t\t\tif (strokeWidth >= barWid / 2)\n\t\t\t\t\tstrokeWidth = 0;\n\n\t\t\t\t// for small gaps, disable pixel snapping since gap inconsistencies become noticible and annoying\n\t\t\t\tif (gapWid + extraGap < 5)\n\t\t\t\t\tpxRound = retArg0;\n\n\t\t\t\tbarWid = pxRound(clamp(colWid - gapWid, minWidth, maxWidth) - strokeWidth - extraGap);\n\n\t\t\t\txShift = (align == 0 ? barWid / 2 : align == _dirX ? 0 : barWid) - align * _dirX * extraGap / 2;\n\n\t\t\t\t// when colWidth is smaller than [min-clamped] bar width (e.g. aligned data values are non-uniform)\n\t\t\t\t// disable clipping of null-valued band bars to avoid clip overlap / bleed into adjacent bars\n\t\t\t\t// (this could still bleed clips of adjacent band/stacked bars into each other, so is far from perfect)\n\t\t\t\tif (barWid + strokeWidth > colWid)\n\t\t\t\t\tbandClipNulls = false;\n\t\t\t}\n\n\t\t\tconst _paths = {stroke: null, fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL | BAND_CLIP_STROKE};  // disp, geom\n\n\t\t\tlet yLimit;\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = new Path2D();\n\t\t\t\tyLimit = pxRound(valToPosY(bandClipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));\n\t\t\t}\n\n\t\t\tconst stroke = multiPath ? null : new Path2D();\n\t\t\tconst band = _paths.band;\n\n\t\t\tlet { y0, y1 } = disp;\n\n\t\t\tlet dataY0 = null;\n\n\t\t\tif (y0 != null && y1 != null) {\n\t\t\t\tdataY = y1.values(u, seriesIdx, idx0, idx1);\n\t\t\t\tdataY0 = y0.values(u, seriesIdx, idx0, idx1);\n\t\t\t}\n\n\t\t\tlet radVal = valRadius * barWid;\n\t\t\tlet radBase = baseRadius * barWid;\n\n\t\t\tfor (let i = _dirX == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dirX) {\n\t\t\t\tlet yVal = dataY[i];\n\n\t\t\t\t// we can skip both, drawing and band clipping for alignment artifacts\n\t\t\t\tif (yVal === undefined)\n\t\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t\t// interpolate upwards band clips\n\t\t\t\tif (yVal == null) {\n\t\t\t\t//\tif (hasBands)\n\t\t\t\t//\t\tyVal = costlyLerp(i, idx0, idx1, _dirX, dataY);\n\t\t\t\t//\telse\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t*/\n\n\t\t\t\tlet xVal = scaleX.distr != 2 || disp != null ? dataX[i] : i;\n\n\t\t\t\t// TODO: all xPos can be pre-computed once for all series in aligned set\n\t\t\t\tlet xPos = valToPosX(xVal, scaleX, xDim, xOff);\n\t\t\t\tlet yPos = valToPosY(ifNull(yVal, fillToY), scaleY, yDim, yOff);\n\n\t\t\t\tif (dataY0 != null && yVal != null)\n\t\t\t\t\ty0Pos = valToPosY(dataY0[i], scaleY, yDim, yOff);\n\n\t\t\t\tlet lft = pxRound(xPos - xShift);\n\t\t\t\tlet btm = pxRound(max(yPos, y0Pos));\n\t\t\t\tlet top = pxRound(min(yPos, y0Pos));\n\t\t\t\t// this includes the stroke\n\t\t\t\tlet barHgt = btm - top;\n\n\t\t\t\tif (yVal != null) {  // && yVal != fillToY (0 height bar)\n\t\t\t\t\tlet rv = yVal < 0 ? radBase : radVal;\n\t\t\t\t\tlet rb = yVal < 0 ? radVal : radBase;\n\n\t\t\t\t\tif (multiPath) {\n\t\t\t\t\t\tif (strokeWidth > 0 && strokeColors[i] != null)\n\t\t\t\t\t\t\trect(strokePaths.get(strokeColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), rv, rb);\n\n\t\t\t\t\t\tif (fillColors[i] != null)\n\t\t\t\t\t\t\trect(fillPaths.get(fillColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), rv, rb);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trect(stroke, lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), rv, rb);\n\n\t\t\t\t\teach(u, seriesIdx, i,\n\t\t\t\t\t\tlft    - strokeWidth / 2,\n\t\t\t\t\t\ttop,\n\t\t\t\t\t\tbarWid + strokeWidth,\n\t\t\t\t\t\tbarHgt,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (bandClipDir != 0 && (yVal != null || bandClipNulls)) {\n\t\t\t\t\tif (_dirY * bandClipDir == 1) {\n\t\t\t\t\t\tbtm = top;\n\t\t\t\t\t\ttop = yLimit;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttop = btm;\n\t\t\t\t\t\tbtm = yLimit;\n\t\t\t\t\t}\n\n\t\t\t\t\tbarHgt = btm - top;\n\n\t\t\t\t\trect(band, lft - strokeWidth / 2, top, barWid + strokeWidth, max(0, barHgt), 0, 0);  // radius here?\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strokeWidth > 0)\n\t\t\t\t_paths.stroke = multiPath ? strokePaths : stroke;\n\t\t\telse if (!multiPath) {\n\t\t\t\t_paths._fill = series.width == 0 ? series._fill : series._stroke ?? series._fill;\n\t\t\t\t_paths.width = 0;\n\t\t\t}\n\n\t\t\t_paths.fill = multiPath ? fillPaths : stroke;\n\n\t\t\treturn _paths;\n\t\t});\n\t};\n}\n\nfunction splineInterp(interp, opts) {\n\tconst alignGaps = ifNull(opts?.alignGaps, 0);\n\n\treturn (u, seriesIdx, idx0, idx1) => {\n\t\treturn orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {\n\t\t\tlet pxRound = series.pxRound;\n\n\t\t\tlet pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));\n\t\t\tlet pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));\n\n\t\t\tlet moveTo, bezierCurveTo, lineTo;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tmoveTo = moveToH;\n\t\t\t\tlineTo = lineToH;\n\t\t\t\tbezierCurveTo = bezierCurveToH;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmoveTo = moveToV;\n\t\t\t\tlineTo = lineToV;\n\t\t\t\tbezierCurveTo = bezierCurveToV;\n\t\t\t}\n\n\t\t\tconst dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);\n\n\t\t\tidx0 = nonNullIdx(dataY, idx0, idx1,  1);\n\t\t\tidx1 = nonNullIdx(dataY, idx0, idx1, -1);\n\n\t\t\tlet firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);\n\t\t\tlet prevXPos = firstXPos;\n\n\t\t\tlet xCoords = [];\n\t\t\tlet yCoords = [];\n\n\t\t\tfor (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {\n\t\t\t\tlet yVal = dataY[i];\n\n\t\t\t\tif (yVal != null) {\n\t\t\t\t\tlet xVal = dataX[i];\n\t\t\t\t\tlet xPos = pixelForX(xVal);\n\n\t\t\t\t\txCoords.push(prevXPos = xPos);\n\t\t\t\t\tyCoords.push(pixelForY(dataY[i]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst _paths = {stroke: interp(xCoords, yCoords, moveTo, lineTo, bezierCurveTo, pxRound), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};\n\t\t\tconst stroke = _paths.stroke;\n\n\t\t\tlet [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);\n\n\t\t\tif (series.fill != null || bandFillDir != 0) {\n\t\t\t\tlet fill = _paths.fill = new Path2D(stroke);\n\n\t\t\t\tlet fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);\n\t\t\t\tlet fillToY = pixelForY(fillTo);\n\n\t\t\t\tlineTo(fill, prevXPos, fillToY);\n\t\t\t\tlineTo(fill, firstXPos, fillToY);\n\t\t\t}\n\n\t\t\tif (!series.spanGaps) {\n\t\t\t//\tconsole.time('gaps');\n\t\t\t\tlet gaps = [];\n\n\t\t\t\tgaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));\n\n\t\t\t//\tconsole.timeEnd('gaps');\n\n\t\t\t//\tconsole.log('gaps', JSON.stringify(gaps));\n\n\t\t\t\t_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);\n\n\t\t\t\t_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);\n\t\t\t}\n\n\t\t\tif (bandClipDir != 0) {\n\t\t\t\t_paths.band = bandClipDir == 2 ? [\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),\n\t\t\t\t\tclipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),\n\t\t\t\t] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);\n\t\t\t}\n\n\t\t\treturn _paths;\n\n\t\t\t//  if FEAT_PATHS: false in rollup.config.js\n\t\t\t//\tu.ctx.save();\n\t\t\t//\tu.ctx.beginPath();\n\t\t\t//\tu.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);\n\t\t\t//\tu.ctx.clip();\n\t\t\t//\tu.ctx.strokeStyle = u.series[sidx].stroke;\n\t\t\t//\tu.ctx.stroke(stroke);\n\t\t\t//\tu.ctx.fillStyle = u.series[sidx].fill;\n\t\t\t//\tu.ctx.fill(fill);\n\t\t\t//\tu.ctx.restore();\n\t\t\t//\treturn null;\n\t\t});\n\t};\n}\n\nfunction monotoneCubic(opts) {\n\treturn splineInterp(_monotoneCubic, opts);\n}\n\n// Monotone Cubic Spline interpolation, adapted from the Chartist.js implementation:\n// https://github.com/gionkunz/chartist-js/blob/e7e78201bffe9609915e5e53cfafa29a5d6c49f9/src/scripts/interpolation.js#L240-L369\nfunction _monotoneCubic(xs, ys, moveTo, lineTo, bezierCurveTo, pxRound) {\n\tconst n = xs.length;\n\n\tif (n < 2)\n\t\treturn null;\n\n\tconst path = new Path2D();\n\n\tmoveTo(path, xs[0], ys[0]);\n\n\tif (n == 2)\n\t\tlineTo(path, xs[1], ys[1]);\n\telse {\n\t\tlet ms  = Array(n),\n\t\t\tds  = Array(n - 1),\n\t\t\tdys = Array(n - 1),\n\t\t\tdxs = Array(n - 1);\n\n\t\t// calc deltas and derivative\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tdys[i] = ys[i + 1] - ys[i];\n\t\t\tdxs[i] = xs[i + 1] - xs[i];\n\t\t\tds[i]  = dys[i] / dxs[i];\n\t\t}\n\n\t\t// determine desired slope (m) at each point using Fritsch-Carlson method\n\t\t// http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation\n\t\tms[0] = ds[0];\n\n\t\tfor (let i = 1; i < n - 1; i++) {\n\t\t\tif (ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0))\n\t\t\t\tms[i] = 0;\n\t\t\telse {\n\t\t\t\tms[i] = 3 * (dxs[i - 1] + dxs[i]) / (\n\t\t\t\t\t(2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +\n\t\t\t\t\t(dxs[i] + 2 * dxs[i - 1]) / ds[i]\n\t\t\t\t);\n\n\t\t\t\tif (!isFinite(ms[i]))\n\t\t\t\t\tms[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tms[n - 1] = ds[n - 2];\n\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tbezierCurveTo(\n\t\t\t\tpath,\n\t\t\t\txs[i] + dxs[i] / 3,\n\t\t\t\tys[i] + ms[i] * dxs[i] / 3,\n\t\t\t\txs[i + 1] - dxs[i] / 3,\n\t\t\t\tys[i + 1] - ms[i + 1] * dxs[i] / 3,\n\t\t\t\txs[i + 1],\n\t\t\t\tys[i + 1],\n\t\t\t);\n\t\t}\n\t}\n\n\treturn path;\n}\n\nconst cursorPlots = new Set();\n\nfunction invalidateRects() {\n\tfor (let u of cursorPlots)\n\t\tu.syncRect(true);\n}\n\nif (domEnv) {\n\ton(resize, win, invalidateRects);\n\ton(scroll, win, invalidateRects, true);\n\ton(dppxchange, win, () => { uPlot.pxRatio = pxRatio; });\n}\n\nconst linearPath = linear() ;\nconst pointsPath = points() ;\n\nfunction setDefaults(d, xo, yo, initY) {\n\tlet d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));\n\treturn d2.map((o, i) => setDefault(o, i, xo, yo));\n}\n\nfunction setDefaults2(d, xyo) {\n\treturn d.map((o, i) => i == 0 ? null : assign({}, xyo, o));  // todo: assign() will not merge facet arrays\n}\n\nfunction setDefault(o, i, xo, yo) {\n\treturn assign({}, (i == 0 ? xo : yo), o);\n}\n\nfunction snapNumX(self, dataMin, dataMax) {\n\treturn dataMin == null ? nullNullTuple : [dataMin, dataMax];\n}\n\nconst snapTimeX = snapNumX;\n\n// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below\n// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value\nfunction snapNumY(self, dataMin, dataMax) {\n\treturn dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, rangePad, true);\n}\n\nfunction snapLogY(self, dataMin, dataMax, scale) {\n\treturn dataMin == null ? nullNullTuple : rangeLog(dataMin, dataMax, self.scales[scale].log, false);\n}\n\nconst snapLogX = snapLogY;\n\nfunction snapAsinhY(self, dataMin, dataMax, scale) {\n\treturn dataMin == null ? nullNullTuple : rangeAsinh(dataMin, dataMax, self.scales[scale].log, false);\n}\n\nconst snapAsinhX = snapAsinhY;\n\n// dim is logical (getClientBoundingRect) pixels, not canvas pixels\nfunction findIncr(minVal, maxVal, incrs, dim, minSpace) {\n\tlet intDigits = max(numIntDigits(minVal), numIntDigits(maxVal));\n\n\tlet delta = maxVal - minVal;\n\n\tlet incrIdx = closestIdx((minSpace / dim) * delta, incrs);\n\n\tdo {\n\t\tlet foundIncr = incrs[incrIdx];\n\t\tlet foundSpace = dim * foundIncr / delta;\n\n\t\tif (foundSpace >= minSpace && intDigits + (foundIncr < 5 ? fixedDec.get(foundIncr) : 0) <= 17)\n\t\t\treturn [foundIncr, foundSpace];\n\t} while (++incrIdx < incrs.length);\n\n\treturn [0, 0];\n}\n\nfunction pxRatioFont(font) {\n\tlet fontSize, fontSizeCss;\n\tfont = font.replace(/(\\d+)px/, (m, p1) => (fontSize = round((fontSizeCss = +p1) * pxRatio)) + 'px');\n\treturn [font, fontSize, fontSizeCss];\n}\n\nfunction syncFontSize(axis) {\n\tif (axis.show) {\n\t\t[axis.font, axis.labelFont].forEach(f => {\n\t\t\tlet size = roundDec(f[2] * pxRatio, 1);\n\t\t\tf[0] = f[0].replace(/[0-9.]+px/, size + 'px');\n\t\t\tf[1] = size;\n\t\t});\n\t}\n}\n\nfunction uPlot(opts, data, then) {\n\tconst self = {\n\t\tmode: ifNull(opts.mode, 1),\n\t};\n\n\tconst mode = self.mode;\n\n\t// TODO: cache denoms & mins scale.cache = {r, min, }\n\tfunction getValPct(val, scale) {\n\t\tlet _val = (\n\t\t\tscale.distr == 3 ? log10(val > 0 ? val : scale.clamp(self, val, scale.min, scale.max, scale.key)) :\n\t\t\tscale.distr == 4 ? asinh(val, scale.asinh) :\n\t\t\tval\n\t\t);\n\n\t\treturn (_val - scale._min) / (scale._max - scale._min);\n\t}\n\n\tfunction getHPos(val, scale, dim, off) {\n\t\tlet pct = getValPct(val, scale);\n\t\treturn off + dim * (scale.dir == -1 ? (1 - pct) : pct);\n\t}\n\n\tfunction getVPos(val, scale, dim, off) {\n\t\tlet pct = getValPct(val, scale);\n\t\treturn off + dim * (scale.dir == -1 ? pct : (1 - pct));\n\t}\n\n\tfunction getPos(val, scale, dim, off) {\n\t\treturn scale.ori == 0 ? getHPos(val, scale, dim, off) : getVPos(val, scale, dim, off);\n\t}\n\n\tself.valToPosH = getHPos;\n\tself.valToPosV = getVPos;\n\n\tlet ready = false;\n\tself.status = 0;\n\n\tconst root = self.root = placeDiv(UPLOT);\n\n\tif (opts.id != null)\n\t\troot.id = opts.id;\n\n\taddClass(root, opts.class);\n\n\tif (opts.title) {\n\t\tlet title = placeDiv(TITLE, root);\n\t\ttitle.textContent = opts.title;\n\t}\n\n\tconst can = placeTag(\"canvas\");\n\tconst ctx = self.ctx = can.getContext(\"2d\");\n\n\tconst wrap = placeDiv(WRAP, root);\n\n\ton(\"click\", wrap, e => {\n\t\tif (e.target === over) {\n\t\t\tlet didDrag = mouseLeft1 != mouseLeft0 || mouseTop1 != mouseTop0;\n\t\t\tdidDrag && drag.click(self, e);\n\t\t}\n\t}, true);\n\n\tconst under = self.under = placeDiv(UNDER, wrap);\n\twrap.appendChild(can);\n\tconst over = self.over = placeDiv(OVER, wrap);\n\n\topts = copy(opts);\n\n\tconst pxAlign = +ifNull(opts.pxAlign, 1);\n\n\tconst pxRound = pxRoundGen(pxAlign);\n\n\t(opts.plugins || []).forEach(p => {\n\t\tif (p.opts)\n\t\t\topts = p.opts(self, opts) || opts;\n\t});\n\n\tconst ms = opts.ms || 1e-3;\n\n\tconst series  = self.series = mode == 1 ?\n\t\tsetDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false) :\n\t\tsetDefaults2(opts.series || [null], xySeriesOpts);\n\tconst axes    = self.axes   = setDefaults(opts.axes   || [], xAxisOpts,   yAxisOpts,    true);\n\tconst scales  = self.scales = {};\n\tconst bands   = self.bands  = opts.bands || [];\n\n\tbands.forEach(b => {\n\t\tb.fill = fnOrSelf(b.fill || null);\n\t\tb.dir = ifNull(b.dir, -1);\n\t});\n\n\tconst xScaleKey = mode == 2 ? series[1].facets[0].scale : series[0].scale;\n\n\tconst drawOrderMap = {\n\t\taxes: drawAxesGrid,\n\t\tseries: drawSeries,\n\t};\n\n\tconst drawOrder = (opts.drawOrder || [\"axes\", \"series\"]).map(key => drawOrderMap[key]);\n\n\tfunction initScale(scaleKey) {\n\t\tlet sc = scales[scaleKey];\n\n\t\tif (sc == null) {\n\t\t\tlet scaleOpts = (opts.scales || EMPTY_OBJ)[scaleKey] || EMPTY_OBJ;\n\n\t\t\tif (scaleOpts.from != null) {\n\t\t\t\t// ensure parent is initialized\n\t\t\t\tinitScale(scaleOpts.from);\n\t\t\t\t// dependent scales inherit\n\t\t\t\tscales[scaleKey] = assign({}, scales[scaleOpts.from], scaleOpts, {key: scaleKey});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsc = scales[scaleKey] = assign({}, (scaleKey == xScaleKey ? xScaleOpts : yScaleOpts), scaleOpts);\n\n\t\t\t\tsc.key = scaleKey;\n\n\t\t\t\tlet isTime = sc.time;\n\n\t\t\t\tlet rn = sc.range;\n\n\t\t\t\tlet rangeIsArr = isArr(rn);\n\n\t\t\t\tif (scaleKey != xScaleKey || (mode == 2 && !isTime)) {\n\t\t\t\t\t// if range array has null limits, it should be auto\n\t\t\t\t\tif (rangeIsArr && (rn[0] == null || rn[1] == null)) {\n\t\t\t\t\t\trn = {\n\t\t\t\t\t\t\tmin: rn[0] == null ? autoRangePart : {\n\t\t\t\t\t\t\t\tmode: 1,\n\t\t\t\t\t\t\t\thard: rn[0],\n\t\t\t\t\t\t\t\tsoft: rn[0],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmax: rn[1] == null ? autoRangePart : {\n\t\t\t\t\t\t\t\tmode: 1,\n\t\t\t\t\t\t\t\thard: rn[1],\n\t\t\t\t\t\t\t\tsoft: rn[1],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t\trangeIsArr = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!rangeIsArr && isObj(rn)) {\n\t\t\t\t\t\tlet cfg = rn;\n\t\t\t\t\t\t// this is similar to snapNumY\n\t\t\t\t\t\trn = (self, dataMin, dataMax) => dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, cfg);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsc.range = fnOrSelf(rn || (isTime ? snapTimeX : scaleKey == xScaleKey ?\n\t\t\t\t\t(sc.distr == 3 ? snapLogX : sc.distr == 4 ? snapAsinhX : snapNumX) :\n\t\t\t\t\t(sc.distr == 3 ? snapLogY : sc.distr == 4 ? snapAsinhY : snapNumY)\n\t\t\t\t));\n\n\t\t\t\tsc.auto = fnOrSelf(rangeIsArr ? false : sc.auto);\n\n\t\t\t\tsc.clamp = fnOrSelf(sc.clamp || clampScale);\n\n\t\t\t\t// caches for expensive ops like asinh() & log()\n\t\t\t\tsc._min = sc._max = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tinitScale(\"x\");\n\tinitScale(\"y\");\n\n\t// TODO: init scales from facets in mode: 2\n\tif (mode == 1) {\n\t\tseries.forEach(s => {\n\t\t\tinitScale(s.scale);\n\t\t});\n\t}\n\n\taxes.forEach(a => {\n\t\tinitScale(a.scale);\n\t});\n\n\tfor (let k in opts.scales)\n\t\tinitScale(k);\n\n\tconst scaleX = scales[xScaleKey];\n\n\tconst xScaleDistr = scaleX.distr;\n\n\tlet valToPosX, valToPosY;\n\n\tif (scaleX.ori == 0) {\n\t\taddClass(root, ORI_HZ);\n\t\tvalToPosX = getHPos;\n\t\tvalToPosY = getVPos;\n\t\t/*\n\t\tupdOriDims = () => {\n\t\t\txDimCan = plotWid;\n\t\t\txOffCan = plotLft;\n\t\t\tyDimCan = plotHgt;\n\t\t\tyOffCan = plotTop;\n\n\t\t\txDimCss = plotWidCss;\n\t\t\txOffCss = plotLftCss;\n\t\t\tyDimCss = plotHgtCss;\n\t\t\tyOffCss = plotTopCss;\n\t\t};\n\t\t*/\n\t}\n\telse {\n\t\taddClass(root, ORI_VT);\n\t\tvalToPosX = getVPos;\n\t\tvalToPosY = getHPos;\n\t\t/*\n\t\tupdOriDims = () => {\n\t\t\txDimCan = plotHgt;\n\t\t\txOffCan = plotTop;\n\t\t\tyDimCan = plotWid;\n\t\t\tyOffCan = plotLft;\n\n\t\t\txDimCss = plotHgtCss;\n\t\t\txOffCss = plotTopCss;\n\t\t\tyDimCss = plotWidCss;\n\t\t\tyOffCss = plotLftCss;\n\t\t};\n\t\t*/\n\t}\n\n\tconst pendScales = {};\n\n\t// explicitly-set initial scales\n\tfor (let k in scales) {\n\t\tlet sc = scales[k];\n\n\t\tif (sc.min != null || sc.max != null) {\n\t\t\tpendScales[k] = {min: sc.min, max: sc.max};\n\t\t\tsc.min = sc.max = null;\n\t\t}\n\t}\n\n//\tself.tz = opts.tz || Intl.DateTimeFormat().resolvedOptions().timeZone;\n\tconst _tzDate  = (opts.tzDate || (ts => new Date(round(ts / ms))));\n\tconst _fmtDate = (opts.fmtDate || fmtDate);\n\n\tconst _timeAxisSplits = (ms == 1 ? timeAxisSplitsMs(_tzDate) : timeAxisSplitsS(_tzDate));\n\tconst _timeAxisVals   = timeAxisVals(_tzDate, timeAxisStamps((ms == 1 ? _timeAxisStampsMs : _timeAxisStampsS), _fmtDate));\n\tconst _timeSeriesVal  = timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));\n\n\tconst activeIdxs = [];\n\n\tconst legend     = (self.legend = assign({}, legendOpts, opts.legend));\n\tconst showLegend = legend.show;\n\tconst markers    = legend.markers;\n\n\t{\n\t\tlegend.idxs = activeIdxs;\n\n\t\tmarkers.width  = fnOrSelf(markers.width);\n\t\tmarkers.dash   = fnOrSelf(markers.dash);\n\t\tmarkers.stroke = fnOrSelf(markers.stroke);\n\t\tmarkers.fill   = fnOrSelf(markers.fill);\n\t}\n\n\tlet legendTable;\n\tlet legendHead;\n\tlet legendBody;\n\tlet legendRows = [];\n\tlet legendCells = [];\n\tlet legendCols;\n\tlet multiValLegend = false;\n\tlet NULL_LEGEND_VALUES = {};\n\n\tif (legend.live) {\n\t\tconst getMultiVals = series[1] ? series[1].values : null;\n\t\tmultiValLegend = getMultiVals != null;\n\t\tlegendCols = multiValLegend ? getMultiVals(self, 1, 0) : {_: 0};\n\n\t\tfor (let k in legendCols)\n\t\t\tNULL_LEGEND_VALUES[k] = LEGEND_DISP;\n\t}\n\n\tif (showLegend) {\n\t\tlegendTable = placeTag(\"table\", LEGEND, root);\n\t\tlegendBody = placeTag(\"tbody\", null, legendTable);\n\n\t\t// allows legend to be moved out of root\n\t\tlegend.mount(self, legendTable);\n\n\t\tif (multiValLegend) {\n\t\t\tlegendHead = placeTag(\"thead\", null, legendTable, legendBody);\n\n\t\t\tlet head = placeTag(\"tr\", null, legendHead);\n\t\t\tplaceTag(\"th\", null, head);\n\n\t\t\tfor (var key in legendCols)\n\t\t\t\tplaceTag(\"th\", LEGEND_LABEL, head).textContent = key;\n\t\t}\n\t\telse {\n\t\t\taddClass(legendTable, LEGEND_INLINE);\n\t\t\tlegend.live && addClass(legendTable, LEGEND_LIVE);\n\t\t}\n\t}\n\n\tconst son  = {show: true};\n\tconst soff = {show: false};\n\n\tfunction initLegendRow(s, i) {\n\t\tif (i == 0 && (multiValLegend || !legend.live || mode == 2))\n\t\t\treturn nullNullTuple;\n\n\t\tlet cells = [];\n\n\t\tlet row = placeTag(\"tr\", LEGEND_SERIES, legendBody, legendBody.childNodes[i]);\n\n\t\taddClass(row, s.class);\n\n\t\tif (!s.show)\n\t\t\taddClass(row, OFF);\n\n\t\tlet label = placeTag(\"th\", null, row);\n\n\t\tif (markers.show) {\n\t\t\tlet indic = placeDiv(LEGEND_MARKER, label);\n\n\t\t\tif (i > 0) {\n\t\t\t\tlet width  = markers.width(self, i);\n\n\t\t\t\tif (width)\n\t\t\t\t\tindic.style.border = width + \"px \" + markers.dash(self, i) + \" \" + markers.stroke(self, i);\n\n\t\t\t\tindic.style.background = markers.fill(self, i);\n\t\t\t}\n\t\t}\n\n\t\tlet text = placeDiv(LEGEND_LABEL, label);\n\t\ttext.textContent = s.label;\n\n\t\tif (i > 0) {\n\t\t\tif (!markers.show)\n\t\t\t\ttext.style.color = s.width > 0 ? markers.stroke(self, i) : markers.fill(self, i);\n\n\t\t\tonMouse(\"click\", label, e => {\n\t\t\t\tif (cursor._lock)\n\t\t\t\t\treturn;\n\n\t\t\t\tsetCursorEvent(e);\n\n\t\t\t\tlet seriesIdx = series.indexOf(s);\n\n\t\t\t\tif ((e.ctrlKey || e.metaKey) != legend.isolate) {\n\t\t\t\t\t// if any other series is shown, isolate this one. else show all\n\t\t\t\t\tlet isolate = series.some((s, i) => i > 0 && i != seriesIdx && s.show);\n\n\t\t\t\t\tseries.forEach((s, i) => {\n\t\t\t\t\t\ti > 0 && setSeries(i, isolate ? (i == seriesIdx ? son : soff) : son, true, syncOpts.setSeries);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsetSeries(seriesIdx, {show: !s.show}, true, syncOpts.setSeries);\n\t\t\t}, false);\n\n\t\t\tif (cursorFocus) {\n\t\t\t\tonMouse(mouseenter, label, e => {\n\t\t\t\t\tif (cursor._lock)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tsetCursorEvent(e);\n\n\t\t\t\t\tsetSeries(series.indexOf(s), FOCUS_TRUE, true, syncOpts.setSeries);\n\t\t\t\t}, false);\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in legendCols) {\n\t\t\tlet v = placeTag(\"td\", LEGEND_VALUE, row);\n\t\t\tv.textContent = \"--\";\n\t\t\tcells.push(v);\n\t\t}\n\n\t\treturn [row, cells];\n\t}\n\n\tconst mouseListeners = new Map();\n\n\tfunction onMouse(ev, targ, fn, onlyTarg = true) {\n\t\tconst targListeners = mouseListeners.get(targ) || {};\n\t\tconst listener = cursor.bind[ev](self, targ, fn, onlyTarg);\n\n\t\tif (listener) {\n\t\t\ton(ev, targ, targListeners[ev] = listener);\n\t\t\tmouseListeners.set(targ, targListeners);\n\t\t}\n\t}\n\n\tfunction offMouse(ev, targ, fn) {\n\t\tconst targListeners = mouseListeners.get(targ) || {};\n\n\t\tfor (let k in targListeners) {\n\t\t\tif (ev == null || k == ev) {\n\t\t\t\toff(k, targ, targListeners[k]);\n\t\t\t\tdelete targListeners[k];\n\t\t\t}\n\t\t}\n\n\t\tif (ev == null)\n\t\t\tmouseListeners.delete(targ);\n\t}\n\n\tlet fullWidCss = 0;\n\tlet fullHgtCss = 0;\n\n\tlet plotWidCss = 0;\n\tlet plotHgtCss = 0;\n\n\t// plot margins to account for axes\n\tlet plotLftCss = 0;\n\tlet plotTopCss = 0;\n\n\tlet plotLft = 0;\n\tlet plotTop = 0;\n\tlet plotWid = 0;\n\tlet plotHgt = 0;\n\n\tself.bbox = {};\n\n\tlet shouldSetScales = false;\n\tlet shouldSetSize = false;\n\tlet shouldConvergeSize = false;\n\tlet shouldSetCursor = false;\n\tlet shouldSetSelect = false;\n\tlet shouldSetLegend = false;\n\n\tfunction _setSize(width, height, force) {\n\t\tif (force || (width != self.width || height != self.height))\n\t\t\tcalcSize(width, height);\n\n\t\tresetYSeries(false);\n\n\t\tshouldConvergeSize = true;\n\t\tshouldSetSize = true;\n\n\t\tif (cursor.left >= 0)\n\t\t\tshouldSetCursor = shouldSetLegend = true;\n\n\t\tcommit();\n\t}\n\n\tfunction calcSize(width, height) {\n\t//\tlog(\"calcSize()\", arguments);\n\n\t\tself.width  = fullWidCss = plotWidCss = width;\n\t\tself.height = fullHgtCss = plotHgtCss = height;\n\t\tplotLftCss  = plotTopCss = 0;\n\n\t\tcalcPlotRect();\n\t\tcalcAxesRects();\n\n\t\tlet bb = self.bbox;\n\n\t\tplotLft = bb.left   = incrRound(plotLftCss * pxRatio, 0.5);\n\t\tplotTop = bb.top    = incrRound(plotTopCss * pxRatio, 0.5);\n\t\tplotWid = bb.width  = incrRound(plotWidCss * pxRatio, 0.5);\n\t\tplotHgt = bb.height = incrRound(plotHgtCss * pxRatio, 0.5);\n\n\t//\tupdOriDims();\n\t}\n\n\t// ensures size calc convergence\n\tconst CYCLE_LIMIT = 3;\n\n\tfunction convergeSize() {\n\t\tlet converged = false;\n\n\t\tlet cycleNum = 0;\n\n\t\twhile (!converged) {\n\t\t\tcycleNum++;\n\n\t\t\tlet axesConverged = axesCalc(cycleNum);\n\t\t\tlet paddingConverged = paddingCalc(cycleNum);\n\n\t\t\tconverged = cycleNum == CYCLE_LIMIT || (axesConverged && paddingConverged);\n\n\t\t\tif (!converged) {\n\t\t\t\tcalcSize(self.width, self.height);\n\t\t\t\tshouldSetSize = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setSize({width, height}) {\n\t\t_setSize(width, height);\n\t}\n\n\tself.setSize = setSize;\n\n\t// accumulate axis offsets, reduce canvas width\n\tfunction calcPlotRect() {\n\t\t// easements for edge labels\n\t\tlet hasTopAxis = false;\n\t\tlet hasBtmAxis = false;\n\t\tlet hasRgtAxis = false;\n\t\tlet hasLftAxis = false;\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (axis.show && axis._show) {\n\t\t\t\tlet {side, _size} = axis;\n\t\t\t\tlet isVt = side % 2;\n\t\t\t\tlet labelSize = axis.label != null ? axis.labelSize : 0;\n\n\t\t\t\tlet fullSize = _size + labelSize;\n\n\t\t\t\tif (fullSize > 0) {\n\t\t\t\t\tif (isVt) {\n\t\t\t\t\t\tplotWidCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 3) {\n\t\t\t\t\t\t\tplotLftCss += fullSize;\n\t\t\t\t\t\t\thasLftAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasRgtAxis = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tplotHgtCss -= fullSize;\n\n\t\t\t\t\t\tif (side == 0) {\n\t\t\t\t\t\t\tplotTopCss += fullSize;\n\t\t\t\t\t\t\thasTopAxis = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thasBtmAxis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsidesWithAxes[0] = hasTopAxis;\n\t\tsidesWithAxes[1] = hasRgtAxis;\n\t\tsidesWithAxes[2] = hasBtmAxis;\n\t\tsidesWithAxes[3] = hasLftAxis;\n\n\t\t// hz padding\n\t\tplotWidCss -= _padding[1] + _padding[3];\n\t\tplotLftCss += _padding[3];\n\n\t\t// vt padding\n\t\tplotHgtCss -= _padding[2] + _padding[0];\n\t\tplotTopCss += _padding[0];\n\t}\n\n\tfunction calcAxesRects() {\n\t\t// will accum +\n\t\tlet off1 = plotLftCss + plotWidCss;\n\t\tlet off2 = plotTopCss + plotHgtCss;\n\t\t// will accum -\n\t\tlet off3 = plotLftCss;\n\t\tlet off0 = plotTopCss;\n\n\t\tfunction incrOffset(side, size) {\n\t\t\tswitch (side) {\n\t\t\t\tcase 1: off1 += size; return off1 - size;\n\t\t\t\tcase 2: off2 += size; return off2 - size;\n\t\t\t\tcase 3: off3 -= size; return off3 + size;\n\t\t\t\tcase 0: off0 -= size; return off0 + size;\n\t\t\t}\n\t\t}\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (axis.show && axis._show) {\n\t\t\t\tlet side = axis.side;\n\n\t\t\t\taxis._pos = incrOffset(side, axis._size);\n\n\t\t\t\tif (axis.label != null)\n\t\t\t\t\taxis._lpos = incrOffset(side, axis.labelSize);\n\t\t\t}\n\t\t});\n\t}\n\n\tconst cursor = self.cursor = assign({}, cursorOpts, {drag: {y: mode == 2}}, opts.cursor);\n\tconst setCursorEvent = e => { cursor.event = e; };\n\n\tcursor.idxs = activeIdxs;\n\n\tcursor._lock = false;\n\n\tlet points = cursor.points;\n\n\tpoints.show   = fnOrSelf(points.show);\n\tpoints.size   = fnOrSelf(points.size);\n\tpoints.stroke = fnOrSelf(points.stroke);\n\tpoints.width  = fnOrSelf(points.width);\n\tpoints.fill   = fnOrSelf(points.fill);\n\n\tconst focus = self.focus = assign({}, opts.focus || {alpha: 0.3}, cursor.focus);\n\n\tconst cursorFocus = focus.prox >= 0;\n\n\t// series-intersection markers\n\tlet cursorPts = [null];\n\n\tfunction initCursorPt(s, si) {\n\t\tif (si > 0) {\n\t\t\tlet pt = cursor.points.show(self, si);\n\n\t\t\tif (pt) {\n\t\t\t\taddClass(pt, CURSOR_PT);\n\t\t\t\taddClass(pt, s.class);\n\t\t\t\telTrans(pt, -10, -10, plotWidCss, plotHgtCss);\n\t\t\t\tover.insertBefore(pt, cursorPts[si]);\n\n\t\t\t\treturn pt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction initSeries(s, i) {\n\t\tif (mode == 1 || i > 0) {\n\t\t\tlet isTime = mode == 1 && scales[s.scale].time;\n\n\t\t\tlet sv = s.value;\n\t\t\ts.value = isTime ? (isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal) : sv || numSeriesVal;\n\t\t\ts.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);\n\t\t}\n\n\t\tif (i > 0) {\n\t\t\ts.width  = s.width == null ? 1 : s.width;\n\t\t\ts.paths  = s.paths || linearPath || retNull;\n\t\t\ts.fillTo = fnOrSelf(s.fillTo || seriesFillTo);\n\t\t\ts.pxAlign = +ifNull(s.pxAlign, pxAlign);\n\t\t\ts.pxRound = pxRoundGen(s.pxAlign);\n\n\t\t\ts.stroke = fnOrSelf(s.stroke || null);\n\t\t\ts.fill   = fnOrSelf(s.fill || null);\n\t\t\ts._stroke = s._fill = s._paths = s._focus = null;\n\n\t\t\tlet _ptDia = ptDia(max(1, s.width), 1);\n\t\t\tlet points = s.points = assign({}, {\n\t\t\t\tsize: _ptDia,\n\t\t\t\twidth: max(1, _ptDia * .2),\n\t\t\t\tstroke: s.stroke,\n\t\t\t\tspace: _ptDia * 2,\n\t\t\t\tpaths: pointsPath,\n\t\t\t\t_stroke: null,\n\t\t\t\t_fill: null,\n\t\t\t}, s.points);\n\t\t\tpoints.show   = fnOrSelf(points.show);\n\t\t\tpoints.filter = fnOrSelf(points.filter);\n\t\t\tpoints.fill   = fnOrSelf(points.fill);\n\t\t\tpoints.stroke = fnOrSelf(points.stroke);\n\t\t\tpoints.paths  = fnOrSelf(points.paths);\n\t\t\tpoints.pxAlign = s.pxAlign;\n\t\t}\n\n\t\tif (showLegend) {\n\t\t\tlet rowCells = initLegendRow(s, i);\n\t\t\tlegendRows.splice(i, 0, rowCells[0]);\n\t\t\tlegendCells.splice(i, 0, rowCells[1]);\n\t\t\tlegend.values.push(null);\t// NULL_LEGEND_VALS not yet avil here :(\n\t\t}\n\n\t\tif (cursor.show) {\n\t\t\tactiveIdxs.splice(i, 0, null);\n\n\t\t\tlet pt = initCursorPt(s, i);\n\t\t\tpt && cursorPts.splice(i, 0, pt);\n\t\t}\n\n\t\tfire(\"addSeries\", i);\n\t}\n\n\tfunction addSeries(opts, si) {\n\t\tsi = si == null ? series.length : si;\n\n\t\topts = mode == 1 ? setDefault(opts, si, xSeriesOpts, ySeriesOpts) : setDefault(opts, si, null, xySeriesOpts);\n\n\t\tseries.splice(si, 0, opts);\n\t\tinitSeries(series[si], si);\n\t}\n\n\tself.addSeries = addSeries;\n\n\tfunction delSeries(i) {\n\t\tseries.splice(i, 1);\n\n\t\tif (showLegend) {\n\t\t\tlegend.values.splice(i, 1);\n\n\t\t\tlegendCells.splice(i, 1);\n\t\t\tlet tr = legendRows.splice(i, 1)[0];\n\t\t\toffMouse(null, tr.firstChild);\n\t\t\ttr.remove();\n\t\t}\n\n\t\tif (cursor.show) {\n\t\t\tactiveIdxs.splice(i, 1);\n\n\t\t\tcursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();\n\t\t}\n\n\t\t// TODO: de-init no-longer-needed scales?\n\n\t\tfire(\"delSeries\", i);\n\t}\n\n\tself.delSeries = delSeries;\n\n\tconst sidesWithAxes = [false, false, false, false];\n\n\tfunction initAxis(axis, i) {\n\t\taxis._show = axis.show;\n\n\t\tif (axis.show) {\n\t\t\tlet isVt = axis.side % 2;\n\n\t\t\tlet sc = scales[axis.scale];\n\n\t\t\t// this can occur if all series specify non-default scales\n\t\t\tif (sc == null) {\n\t\t\t\taxis.scale = isVt ? series[1].scale : xScaleKey;\n\t\t\t\tsc = scales[axis.scale];\n\t\t\t}\n\n\t\t\t// also set defaults for incrs & values based on axis distr\n\t\t\tlet isTime = sc.time;\n\n\t\t\taxis.size   = fnOrSelf(axis.size);\n\t\t\taxis.space  = fnOrSelf(axis.space);\n\t\t\taxis.rotate = fnOrSelf(axis.rotate);\n\n\t\t\tif (isArr(axis.incrs)) {\n\t\t\t\taxis.incrs.forEach(incr => {\n\t\t\t\t\t!fixedDec.has(incr) && fixedDec.set(incr, guessDec(incr));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\taxis.incrs  = fnOrSelf(axis.incrs  || (          sc.distr == 2 ? wholeIncrs : (isTime ? (ms == 1 ? timeIncrsMs : timeIncrsS) : numIncrs)));\n\t\t\taxis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : sc.distr == 4 ? asinhAxisSplits : numAxisSplits));\n\n\t\t\taxis.stroke        = fnOrSelf(axis.stroke);\n\t\t\taxis.grid.stroke   = fnOrSelf(axis.grid.stroke);\n\t\t\taxis.ticks.stroke  = fnOrSelf(axis.ticks.stroke);\n\t\t\taxis.border.stroke = fnOrSelf(axis.border.stroke);\n\n\t\t\tlet av = axis.values;\n\n\t\t\taxis.values = (\n\t\t\t\t// static array of tick values\n\t\t\t\tisArr(av) && !isArr(av[0]) ? fnOrSelf(av) :\n\t\t\t\t// temporal\n\t\t\t\tisTime ? (\n\t\t\t\t\t// config array of fmtDate string tpls\n\t\t\t\t\tisArr(av) ?\n\t\t\t\t\t\ttimeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) :\n\t\t\t\t\t// fmtDate string tpl\n\t\t\t\t\tisStr(av) ?\n\t\t\t\t\t\ttimeAxisVal(_tzDate, av) :\n\t\t\t\t\tav || _timeAxisVals\n\t\t\t\t) : av || numAxisVals\n\t\t\t);\n\n\t\t\taxis.filter = fnOrSelf(axis.filter || (          sc.distr >= 3 && sc.log == 10 ? log10AxisValsFilt : sc.distr == 3 && sc.log == 2 ? log2AxisValsFilt : retArg1));\n\n\t\t\taxis.font      = pxRatioFont(axis.font);\n\t\t\taxis.labelFont = pxRatioFont(axis.labelFont);\n\n\t\t\taxis._size   = axis.size(self, null, i, 0);\n\n\t\t\taxis._space  =\n\t\t\taxis._rotate =\n\t\t\taxis._incrs  =\n\t\t\taxis._found  =\t// foundIncrSpace\n\t\t\taxis._splits =\n\t\t\taxis._values = null;\n\n\t\t\tif (axis._size > 0) {\n\t\t\t\tsidesWithAxes[i] = true;\n\t\t\t\taxis._el = placeDiv(AXIS, wrap);\n\t\t\t}\n\n\t\t\t// debug\n\t\t//\taxis._el.style.background = \"#\"  + Math.floor(Math.random()*16777215).toString(16) + '80';\n\t\t}\n\t}\n\n\tfunction autoPadSide(self, side, sidesWithAxes, cycleNum) {\n\t\tlet [hasTopAxis, hasRgtAxis, hasBtmAxis, hasLftAxis] = sidesWithAxes;\n\n\t\tlet ori = side % 2;\n\t\tlet size = 0;\n\n\t\tif (ori == 0 && (hasLftAxis || hasRgtAxis))\n\t\t\tsize = (side == 0 && !hasTopAxis || side == 2 && !hasBtmAxis ? round(xAxisOpts.size / 3) : 0);\n\t\tif (ori == 1 && (hasTopAxis || hasBtmAxis))\n\t\t\tsize = (side == 1 && !hasRgtAxis || side == 3 && !hasLftAxis ? round(yAxisOpts.size / 2) : 0);\n\n\t\treturn size;\n\t}\n\n\tconst padding = self.padding = (opts.padding || [autoPadSide,autoPadSide,autoPadSide,autoPadSide]).map(p => fnOrSelf(ifNull(p, autoPadSide)));\n\tconst _padding = self._padding = padding.map((p, i) => p(self, i, sidesWithAxes, 0));\n\n\tlet dataLen;\n\n\t// rendered data window\n\tlet i0 = null;\n\tlet i1 = null;\n\tconst idxs = mode == 1 ? series[0].idxs : null;\n\n\tlet data0 = null;\n\n\tlet viaAutoScaleX = false;\n\n\tfunction setData(_data, _resetScales) {\n\t\tdata = _data == null ? [] : copy(_data, fastIsObj);\n\n\t\tif (mode == 2) {\n\t\t\tdataLen = 0;\n\t\t\tfor (let i = 1; i < series.length; i++)\n\t\t\t\tdataLen += data[i][0].length;\n\t\t\tself.data = data = _data;\n\t\t}\n\t\telse {\n\t\t\tif (data[0] == null)\n\t\t\t\tdata[0] = [];\n\n\t\t\tself.data = data.slice();\n\n\t\t\tdata0 = data[0];\n\t\t\tdataLen = data0.length;\n\n\t\t\tif (xScaleDistr == 2) {\n\t\t\t\tdata[0] = Array(dataLen);\n\t\t\t\tfor (let i = 0; i < dataLen; i++)\n\t\t\t\t\tdata[0][i] = i;\n\t\t\t}\n\t\t}\n\n\t\tself._data = data;\n\n\t\tresetYSeries(true);\n\n\t\tfire(\"setData\");\n\n\t\t// forces x axis tick values to re-generate when neither x scale nor y scale changes\n\t\t// in ordinal mode, scale range is by index, so will not change if new data has same length, but tick values are from data\n\t\tif (xScaleDistr == 2) {\n\t\t\tshouldConvergeSize = true;\n\n\t\t\t/* or somewhat cheaper, and uglier:\n\t\t\tif (ready) {\n\t\t\t\t// logic extracted from axesCalc()\n\t\t\t\tlet i = 0;\n\t\t\t\tlet axis = axes[i];\n\t\t\t\tlet _splits = axis._splits.map(i => data0[i]);\n\t\t\t\tlet [_incr, _space] = axis._found;\n\t\t\t\tlet incr = data0[_splits[1]] - data0[_splits[0]];\n\t\t\t\taxis._values = axis.values(self, axis.filter(self, _splits, i, _space, incr), i, _space, incr);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\tif (_resetScales !== false) {\n\t\t\tlet xsc = scaleX;\n\n\t\t\tif (xsc.auto(self, viaAutoScaleX))\n\t\t\t\tautoScaleX();\n\t\t\telse\n\t\t\t\t_setScale(xScaleKey, xsc.min, xsc.max);\n\n\t\t\tshouldSetCursor = shouldSetCursor || cursor.left >= 0;\n\t\t\tshouldSetLegend = true;\n\t\t\tcommit();\n\t\t}\n\t}\n\n\tself.setData = setData;\n\n\tfunction autoScaleX() {\n\t\tviaAutoScaleX = true;\n\n\t\tlet _min, _max;\n\n\t\tif (mode == 1) {\n\t\t\tif (dataLen > 0) {\n\t\t\t\ti0 = idxs[0] = 0;\n\t\t\t\ti1 = idxs[1] = dataLen - 1;\n\n\t\t\t\t_min = data[0][i0];\n\t\t\t\t_max = data[0][i1];\n\n\t\t\t\tif (xScaleDistr == 2) {\n\t\t\t\t\t_min = i0;\n\t\t\t\t\t_max = i1;\n\t\t\t\t}\n\t\t\t\telse if (_min == _max) {\n\t\t\t\t\tif (xScaleDistr == 3)\n\t\t\t\t\t\t[_min, _max] = rangeLog(_min, _min, scaleX.log, false);\n\t\t\t\t\telse if (xScaleDistr == 4)\n\t\t\t\t\t\t[_min, _max] = rangeAsinh(_min, _min, scaleX.log, false);\n\t\t\t\t\telse if (scaleX.time)\n\t\t\t\t\t\t_max = _min + round(86400 / ms);\n\t\t\t\t\telse\n\t\t\t\t\t\t[_min, _max] = rangeNum(_min, _max, rangePad, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti0 = idxs[0] = _min = null;\n\t\t\t\ti1 = idxs[1] = _max = null;\n\t\t\t}\n\t\t}\n\n\t\t_setScale(xScaleKey, _min, _max);\n\t}\n\n\tlet ctxStroke, ctxFill, ctxWidth, ctxDash, ctxJoin, ctxCap, ctxFont, ctxAlign, ctxBaseline;\n\tlet ctxAlpha;\n\n\tfunction setCtxStyle(stroke, width, dash, cap, fill, join) {\n\t\tstroke ??= transparent;\n\t\tdash   ??= EMPTY_ARR;\n\t\tcap    ??= \"butt\"; // (\u203F|\u203F)\n\t\tfill   ??= transparent;\n\t\tjoin   ??= \"round\";\n\n\t\tif (stroke != ctxStroke)\n\t\t\tctx.strokeStyle = ctxStroke = stroke;\n\t\tif (fill != ctxFill)\n\t\t\tctx.fillStyle = ctxFill = fill;\n\t\tif (width != ctxWidth)\n\t\t\tctx.lineWidth = ctxWidth = width;\n\t\tif (join != ctxJoin)\n\t\t\tctx.lineJoin = ctxJoin = join;\n\t\tif (cap != ctxCap)\n\t\t\tctx.lineCap = ctxCap = cap;\n\t\tif (dash != ctxDash)\n\t\t\tctx.setLineDash(ctxDash = dash);\n\t}\n\n\tfunction setFontStyle(font, fill, align, baseline) {\n\t\tif (fill != ctxFill)\n\t\t\tctx.fillStyle = ctxFill = fill;\n\t\tif (font != ctxFont)\n\t\t\tctx.font = ctxFont = font;\n\t\tif (align != ctxAlign)\n\t\t\tctx.textAlign = ctxAlign = align;\n\t\tif (baseline != ctxBaseline)\n\t\t\tctx.textBaseline = ctxBaseline = baseline;\n\t}\n\n\tfunction accScale(wsc, psc, facet, data, sorted = 0) {\n\t\tif (data.length > 0 && wsc.auto(self, viaAutoScaleX) && (psc == null || psc.min == null)) {\n\t\t\tlet _i0 = ifNull(i0, 0);\n\t\t\tlet _i1 = ifNull(i1, data.length - 1);\n\n\t\t\t// only run getMinMax() for invalidated series data, else reuse\n\t\t\tlet minMax = facet.min == null ? (wsc.distr == 3 ? getMinMaxLog(data, _i0, _i1) : getMinMax(data, _i0, _i1, sorted)) : [facet.min, facet.max];\n\n\t\t\t// initial min/max\n\t\t\twsc.min = min(wsc.min, facet.min = minMax[0]);\n\t\t\twsc.max = max(wsc.max, facet.max = minMax[1]);\n\t\t}\n\t}\n\n\tfunction setScales() {\n\t//\tlog(\"setScales()\", arguments);\n\n\t\t// wip scales\n\t\tlet wipScales = copy(scales, fastIsObj);\n\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\t\t\tlet psc = pendScales[k];\n\n\t\t\tif (psc != null && psc.min != null) {\n\t\t\t\tassign(wsc, psc);\n\n\t\t\t\t// explicitly setting the x-scale invalidates everything (acts as redraw)\n\t\t\t\tif (k == xScaleKey)\n\t\t\t\t\tresetYSeries(true);\n\t\t\t}\n\t\t\telse if (k != xScaleKey || mode == 2) {\n\t\t\t\tif (dataLen == 0 && wsc.from == null) {\n\t\t\t\t\tlet minMax = wsc.range(self, null, null, k);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twsc.min = inf;\n\t\t\t\t\twsc.max = -inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dataLen > 0) {\n\t\t\t// pre-range y-scales from y series' data values\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (mode == 1) {\n\t\t\t\t\tlet k = s.scale;\n\t\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\t\tlet psc = pendScales[k];\n\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\tlet minMax = wsc.range(self, wsc.min, wsc.max, k);\n\n\t\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\t\twsc.max = minMax[1];\n\n\t\t\t\t\t\ti0 = closestIdx(wsc.min, data[0]);\n\t\t\t\t\t\ti1 = closestIdx(wsc.max, data[0]);\n\n\t\t\t\t\t\t// don't try to contract same or adjacent idxs\n\t\t\t\t\t\tif (i1 - i0 > 1) {\n\t\t\t\t\t\t\t// closest indices can be outside of view\n\t\t\t\t\t\t\tif (data[0][i0] < wsc.min)\n\t\t\t\t\t\t\t\ti0++;\n\t\t\t\t\t\t\tif (data[0][i1] > wsc.max)\n\t\t\t\t\t\t\t\ti1--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.min = data0[i0];\n\t\t\t\t\t\ts.max = data0[i1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (s.show && s.auto)\n\t\t\t\t\t\taccScale(wsc, psc, s, data[i], s.sorted);\n\n\t\t\t\t\ts.idxs[0] = i0;\n\t\t\t\t\ts.idxs[1] = i1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tif (s.show && s.auto) {\n\t\t\t\t\t\t\t// TODO: only handles, assumes and requires facets[0] / 'x' scale, and facets[1] / 'y' scale\n\t\t\t\t\t\t\tlet [ xFacet, yFacet ] = s.facets;\n\t\t\t\t\t\t\tlet xScaleKey = xFacet.scale;\n\t\t\t\t\t\t\tlet yScaleKey = yFacet.scale;\n\t\t\t\t\t\t\tlet [ xData, yData ] = data[i];\n\n\t\t\t\t\t\t\taccScale(wipScales[xScaleKey], pendScales[xScaleKey], xFacet, xData, xFacet.sorted);\n\t\t\t\t\t\t\taccScale(wipScales[yScaleKey], pendScales[yScaleKey], yFacet, yData, yFacet.sorted);\n\n\t\t\t\t\t\t\t// temp\n\t\t\t\t\t\t\ts.min = yFacet.min;\n\t\t\t\t\t\t\ts.max = yFacet.max;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// range independent scales\n\t\t\tfor (let k in wipScales) {\n\t\t\t\tlet wsc = wipScales[k];\n\t\t\t\tlet psc = pendScales[k];\n\n\t\t\t\tif (wsc.from == null && (psc == null || psc.min == null)) {\n\t\t\t\t\tlet minMax = wsc.range(\n\t\t\t\t\t\tself,\n\t\t\t\t\t\twsc.min ==  inf ? null : wsc.min,\n\t\t\t\t\t\twsc.max == -inf ? null : wsc.max,\n\t\t\t\t\t\tk\n\t\t\t\t\t);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// range dependent scales\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\n\t\t\tif (wsc.from != null) {\n\t\t\t\tlet base = wipScales[wsc.from];\n\n\t\t\t\tif (base.min == null)\n\t\t\t\t\twsc.min = wsc.max = null;\n\t\t\t\telse {\n\t\t\t\t\tlet minMax = wsc.range(self, base.min, base.max, k);\n\t\t\t\t\twsc.min = minMax[0];\n\t\t\t\t\twsc.max = minMax[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet changed = {};\n\t\tlet anyChanged = false;\n\n\t\tfor (let k in wipScales) {\n\t\t\tlet wsc = wipScales[k];\n\t\t\tlet sc = scales[k];\n\n\t\t\tif (sc.min != wsc.min || sc.max != wsc.max) {\n\t\t\t\tsc.min = wsc.min;\n\t\t\t\tsc.max = wsc.max;\n\n\t\t\t\tlet distr = sc.distr;\n\n\t\t\t\tsc._min = distr == 3 ? log10(sc.min) : distr == 4 ? asinh(sc.min, sc.asinh) : sc.min;\n\t\t\t\tsc._max = distr == 3 ? log10(sc.max) : distr == 4 ? asinh(sc.max, sc.asinh) : sc.max;\n\n\t\t\t\tchanged[k] = anyChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (anyChanged) {\n\t\t\t// invalidate paths of all series on changed scales\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (mode == 2) {\n\t\t\t\t\tif (i > 0 && changed.y)\n\t\t\t\t\t\ts._paths = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (changed[s.scale])\n\t\t\t\t\t\ts._paths = null;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (let k in changed) {\n\t\t\t\tshouldConvergeSize = true;\n\t\t\t\tfire(\"setScale\", k);\n\t\t\t}\n\n\t\t\tif (cursor.show && cursor.left >= 0)\n\t\t\t\tshouldSetCursor = shouldSetLegend = true;\n\t\t}\n\n\t\tfor (let k in pendScales)\n\t\t\tpendScales[k] = null;\n\t}\n\n\t// grabs the nearest indices with y data outside of x-scale limits\n\tfunction getOuterIdxs(ydata) {\n\t\tlet _i0 = clamp(i0 - 1, 0, dataLen - 1);\n\t\tlet _i1 = clamp(i1 + 1, 0, dataLen - 1);\n\n\t\twhile (ydata[_i0] == null && _i0 > 0)\n\t\t\t_i0--;\n\n\t\twhile (ydata[_i1] == null && _i1 < dataLen - 1)\n\t\t\t_i1++;\n\n\t\treturn [_i0, _i1];\n\t}\n\n\tfunction drawSeries() {\n\t\tif (dataLen > 0) {\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tcacheStrokeFill(i, false);\n\t\t\t\t\tcacheStrokeFill(i, true);\n\n\t\t\t\t\tif (s._paths == null) {\n\t\t\t\t\t\tlet _idxs = mode == 2 ? [0, data[i][0].length - 1] : getOuterIdxs(data[i]);\n\t\t\t\t\t\ts._paths = s.paths(self, i, _idxs[0], _idxs[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tseries.forEach((s, i) => {\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tif (ctxAlpha != s.alpha)\n\t\t\t\t\t\tctx.globalAlpha = ctxAlpha = s.alpha;\n\n\t\t\t\t\ts._paths != null && drawPath(i, false);\n\n\t\t\t\t\t{\n\t\t\t\t\t\tlet _gaps = s._paths != null ? s._paths.gaps : null;\n\n\t\t\t\t\t\tlet show = s.points.show(self, i, i0, i1, _gaps);\n\t\t\t\t\t\tlet idxs = s.points.filter(self, i, show, _gaps);\n\n\t\t\t\t\t\tif (show || idxs) {\n\t\t\t\t\t\t\ts.points._paths = s.points.paths(self, i, i0, i1, idxs);\n\t\t\t\t\t\t\tdrawPath(i, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ctxAlpha != 1)\n\t\t\t\t\t\tctx.globalAlpha = ctxAlpha = 1;\n\n\t\t\t\t\tfire(\"drawSeries\", i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction cacheStrokeFill(si, _points) {\n\t\tlet s = _points ? series[si].points : series[si];\n\n\t\ts._stroke = s.stroke(self, si);\n\t\ts._fill   = s.fill(self, si);\n\t}\n\n\tfunction drawPath(si, _points) {\n\t\tlet s = _points ? series[si].points : series[si];\n\n\t\tlet {\n\t\t\tstroke,\n\t\t\tfill,\n\t\t\tclip: gapsClip,\n\t\t\tflags,\n\n\t\t\t_stroke: strokeStyle = s._stroke,\n\t\t\t_fill:   fillStyle   = s._fill,\n\t\t\t_width:  width       = s.width,\n\t\t} = s._paths;\n\n\t\twidth = roundDec(width * pxRatio, 3);\n\n\t\tlet boundsClip = null;\n\t\tlet offset = (width % 2) / 2;\n\n\t\tif (_points && fillStyle == null)\n\t\t\tfillStyle = width > 0 ? \"#fff\" : strokeStyle;\n\n\t\tlet _pxAlign = s.pxAlign == 1 && offset > 0;\n\n\t\t_pxAlign && ctx.translate(offset, offset);\n\n\t\tif (!_points) {\n\t\t\tlet lft = plotLft - width / 2,\n\t\t\t\ttop = plotTop - width / 2,\n\t\t\t\twid = plotWid + width,\n\t\t\t\thgt = plotHgt + width;\n\n\t\t\tboundsClip = new Path2D();\n\t\t\tboundsClip.rect(lft, top, wid, hgt);\n\t\t}\n\n\t\t// the points pathbuilder's gapsClip is its boundsClip, since points dont need gaps clipping, and bounds depend on point size\n\t\tif (_points)\n\t\t\tstrokeFill(strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, gapsClip);\n\t\telse\n\t\t\tfillStroke(si, strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, boundsClip, gapsClip);\n\n\t\t_pxAlign && ctx.translate(-offset, -offset);\n\t}\n\n\tfunction fillStroke(si, strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip) {\n\t\tlet didStrokeFill = false;\n\n\t\t// for all bands where this series is the top edge, create upwards clips using the bottom edges\n\t\t// and apply clips + fill with band fill or dfltFill\n\t\tbands.forEach((b, bi) => {\n\t\t\t// isUpperEdge?\n\t\t\tif (b.series[0] == si) {\n\t\t\t\tlet lowerEdge = series[b.series[1]];\n\t\t\t\tlet lowerData = data[b.series[1]];\n\n\t\t\t\tlet bandClip = (lowerEdge._paths || EMPTY_OBJ).band;\n\n\t\t\t\tif (isArr(bandClip))\n\t\t\t\t\tbandClip = b.dir == 1 ? bandClip[0] : bandClip[1];\n\n\t\t\t\tlet gapsClip2;\n\n\t\t\t\tlet _fillStyle = null;\n\n\t\t\t\t// hasLowerEdge?\n\t\t\t\tif (lowerEdge.show && bandClip && hasData(lowerData, i0, i1)) {\n\t\t\t\t\t_fillStyle = b.fill(self, bi) || fillStyle;\n\t\t\t\t\tgapsClip2 = lowerEdge._paths.clip;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbandClip = null;\n\n\t\t\t\tstrokeFill(strokeStyle, lineWidth, lineDash, lineCap, _fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip);\n\n\t\t\t\tdidStrokeFill = true;\n\t\t\t}\n\t\t});\n\n\t\tif (!didStrokeFill)\n\t\t\tstrokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip);\n\t}\n\n\tconst CLIP_FILL_STROKE = BAND_CLIP_FILL | BAND_CLIP_STROKE;\n\n\tfunction strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip) {\n\t\tsetCtxStyle(strokeStyle, lineWidth, lineDash, lineCap, fillStyle);\n\n\t\tif (boundsClip || gapsClip || bandClip) {\n\t\t\tctx.save();\n\t\t\tboundsClip && ctx.clip(boundsClip);\n\t\t\tgapsClip && ctx.clip(gapsClip);\n\t\t}\n\n\t\tif (bandClip) {\n\t\t\tif ((flags & CLIP_FILL_STROKE) == CLIP_FILL_STROKE) {\n\t\t\t\tctx.clip(bandClip);\n\t\t\t\tgapsClip2 && ctx.clip(gapsClip2);\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t\telse if (flags & BAND_CLIP_STROKE) {\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tctx.clip(bandClip);\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t\telse if (flags & BAND_CLIP_FILL) {\n\t\t\t\tctx.save();\n\t\t\t\tctx.clip(bandClip);\n\t\t\t\tgapsClip2 && ctx.clip(gapsClip2);\n\t\t\t\tdoFill(fillStyle, fillPath);\n\t\t\t\tctx.restore();\n\t\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdoFill(fillStyle, fillPath);\n\t\t\tdoStroke(strokeStyle, strokePath, lineWidth);\n\t\t}\n\n\t\tif (boundsClip || gapsClip || bandClip)\n\t\t\tctx.restore();\n\t}\n\n\tfunction doStroke(strokeStyle, strokePath, lineWidth) {\n\t\tif (lineWidth > 0) {\n\t\t\tif (strokePath instanceof Map) {\n\t\t\t\tstrokePath.forEach((strokePath, strokeStyle) => {\n\t\t\t\t\tctx.strokeStyle = ctxStroke = strokeStyle;\n\t\t\t\t\tctx.stroke(strokePath);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t\tstrokePath != null && strokeStyle && ctx.stroke(strokePath);\n\t\t}\n\t}\n\n\tfunction doFill(fillStyle, fillPath) {\n\t\tif (fillPath instanceof Map) {\n\t\t\tfillPath.forEach((fillPath, fillStyle) => {\n\t\t\t\tctx.fillStyle = ctxFill = fillStyle;\n\t\t\t\tctx.fill(fillPath);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t\tfillPath != null && fillStyle && ctx.fill(fillPath);\n\t}\n\n\tfunction getIncrSpace(axisIdx, min, max, fullDim) {\n\t\tlet axis = axes[axisIdx];\n\n\t\tlet incrSpace;\n\n\t\tif (fullDim <= 0)\n\t\t\tincrSpace = [0, 0];\n\t\telse {\n\t\t\tlet minSpace = axis._space = axis.space(self, axisIdx, min, max, fullDim);\n\t\t\tlet incrs    = axis._incrs = axis.incrs(self, axisIdx, min, max, fullDim, minSpace);\n\t\t\tincrSpace    = findIncr(min, max, incrs, fullDim, minSpace);\n\t\t}\n\n\t\treturn (axis._found = incrSpace);\n\t}\n\n\tfunction drawOrthoLines(offs, filts, ori, side, pos0, len, width, stroke, dash, cap) {\n\t\tlet offset = (width % 2) / 2;\n\n\t\tpxAlign == 1 && ctx.translate(offset, offset);\n\n\t\tsetCtxStyle(stroke, width, dash, cap, stroke);\n\n\t\tctx.beginPath();\n\n\t\tlet x0, y0, x1, y1, pos1 = pos0 + (side == 0 || side == 3 ? -len : len);\n\n\t\tif (ori == 0) {\n\t\t\ty0 = pos0;\n\t\t\ty1 = pos1;\n\t\t}\n\t\telse {\n\t\t\tx0 = pos0;\n\t\t\tx1 = pos1;\n\t\t}\n\n\t\tfor (let i = 0; i < offs.length; i++) {\n\t\t\tif (filts[i] != null) {\n\t\t\t\tif (ori == 0)\n\t\t\t\t\tx0 = x1 = offs[i];\n\t\t\t\telse\n\t\t\t\t\ty0 = y1 = offs[i];\n\n\t\t\t\tctx.moveTo(x0, y0);\n\t\t\t\tctx.lineTo(x1, y1);\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\n\t\tpxAlign == 1 && ctx.translate(-offset, -offset);\n\t}\n\n\tfunction axesCalc(cycleNum) {\n\t//\tlog(\"axesCalc()\", arguments);\n\n\t\tlet converged = true;\n\n\t\taxes.forEach((axis, i) => {\n\t\t\tif (!axis.show)\n\t\t\t\treturn;\n\n\t\t\tlet scale = scales[axis.scale];\n\n\t\t\tif (scale.min == null) {\n\t\t\t\tif (axis._show) {\n\t\t\t\t\tconverged = false;\n\t\t\t\t\taxis._show = false;\n\t\t\t\t\tresetYSeries(false);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!axis._show) {\n\t\t\t\t\tconverged = false;\n\t\t\t\t\taxis._show = true;\n\t\t\t\t\tresetYSeries(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet side = axis.side;\n\t\t\tlet ori = side % 2;\n\n\t\t\tlet {min, max} = scale;\t\t// \t\t// should this toggle them ._show = false\n\n\t\t\tlet [_incr, _space] = getIncrSpace(i, min, max, ori == 0 ? plotWidCss : plotHgtCss);\n\n\t\t\tif (_space == 0)\n\t\t\t\treturn;\n\n\t\t\t// if we're using index positions, force first tick to match passed index\n\t\t\tlet forceMin = scale.distr == 2;\n\n\t\t\tlet _splits = axis._splits = axis.splits(self, i, min, max, _incr, _space, forceMin);\n\n\t\t\t// tick labels\n\t\t\t// BOO this assumes a specific data/series\n\t\t\tlet splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;\n\t\t\tlet incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;\n\n\t\t\tlet values = axis._values = axis.values(self, axis.filter(self, splits, i, _space, incr), i, _space, incr);\n\n\t\t\t// rotating of labels only supported on bottom x axis\n\t\t\taxis._rotate = side == 2 ? axis.rotate(self, values, i, _space) : 0;\n\n\t\t\tlet oldSize = axis._size;\n\n\t\t\taxis._size = ceil(axis.size(self, values, i, cycleNum));\n\n\t\t\tif (oldSize != null && axis._size != oldSize)\t\t\t// ready && ?\n\t\t\t\tconverged = false;\n\t\t});\n\n\t\treturn converged;\n\t}\n\n\tfunction paddingCalc(cycleNum) {\n\t\tlet converged = true;\n\n\t\tpadding.forEach((p, i) => {\n\t\t\tlet _p = p(self, i, sidesWithAxes, cycleNum);\n\n\t\t\tif (_p != _padding[i])\n\t\t\t\tconverged = false;\n\n\t\t\t_padding[i] = _p;\n\t\t});\n\n\t\treturn converged;\n\t}\n\n\tfunction drawAxesGrid() {\n\t\tfor (let i = 0; i < axes.length; i++) {\n\t\t\tlet axis = axes[i];\n\n\t\t\tif (!axis.show || !axis._show)\n\t\t\t\tcontinue;\n\n\t\t\tlet side = axis.side;\n\t\t\tlet ori = side % 2;\n\n\t\t\tlet x, y;\n\n\t\t\tlet fillStyle = axis.stroke(self, i);\n\n\t\t\tlet shiftDir = side == 0 || side == 3 ? -1 : 1;\n\n\t\t\t// axis label\n\t\t\tif (axis.label) {\n\t\t\t\tlet shiftAmt = axis.labelGap * shiftDir;\n\t\t\t\tlet baseLpos = round((axis._lpos + shiftAmt) * pxRatio);\n\n\t\t\t\tsetFontStyle(axis.labelFont[0], fillStyle, \"center\", side == 2 ? TOP : BOTTOM);\n\n\t\t\t\tctx.save();\n\n\t\t\t\tif (ori == 1) {\n\t\t\t\t\tx = y = 0;\n\n\t\t\t\t\tctx.translate(\n\t\t\t\t\t\tbaseLpos,\n\t\t\t\t\t\tround(plotTop + plotHgt / 2),\n\t\t\t\t\t);\n\t\t\t\t\tctx.rotate((side == 3 ? -PI : PI) / 2);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx = round(plotLft + plotWid / 2);\n\t\t\t\t\ty = baseLpos;\n\t\t\t\t}\n\n\t\t\t\tctx.fillText(axis.label, x, y);\n\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\tlet [_incr, _space] = axis._found;\n\n\t\t\tif (_space == 0)\n\t\t\t\tcontinue;\n\n\t\t\tlet scale = scales[axis.scale];\n\n\t\t\tlet plotDim = ori == 0 ? plotWid : plotHgt;\n\t\t\tlet plotOff = ori == 0 ? plotLft : plotTop;\n\n\t\t\tlet axisGap = round(axis.gap * pxRatio);\n\n\t\t\tlet _splits = axis._splits;\n\n\t\t\t// tick labels\n\t\t\t// BOO this assumes a specific data/series\n\t\t\tlet splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;\n\t\t\tlet incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;\n\n\t\t\tlet ticks = axis.ticks;\n\t\t\tlet border = axis.border;\n\t\t\tlet tickSize = ticks.show ? round(ticks.size * pxRatio) : 0;\n\n\t\t\t// rotating of labels only supported on bottom x axis\n\t\t\tlet angle = axis._rotate * -PI/180;\n\n\t\t\tlet basePos  = pxRound(axis._pos * pxRatio);\n\t\t\tlet shiftAmt = (tickSize + axisGap) * shiftDir;\n\t\t\tlet finalPos = basePos + shiftAmt;\n\t\t\t    y        = ori == 0 ? finalPos : 0;\n\t\t\t    x        = ori == 1 ? finalPos : 0;\n\n\t\t\tlet font         = axis.font[0];\n\t\t\tlet textAlign    = axis.align == 1 ? LEFT :\n\t\t\t                   axis.align == 2 ? RIGHT :\n\t\t\t                   angle > 0 ? LEFT :\n\t\t\t                   angle < 0 ? RIGHT :\n\t\t\t                   ori == 0 ? \"center\" : side == 3 ? RIGHT : LEFT;\n\t\t\tlet textBaseline = angle ||\n\t\t\t                   ori == 1 ? \"middle\" : side == 2 ? TOP   : BOTTOM;\n\n\t\t\tsetFontStyle(font, fillStyle, textAlign, textBaseline);\n\n\t\t\tlet lineHeight = axis.font[1] * axis.lineGap;\n\n\t\t\tlet canOffs = _splits.map(val => pxRound(getPos(val, scale, plotDim, plotOff)));\n\n\t\t\tlet _values = axis._values;\n\n\t\t\tfor (let i = 0; i < _values.length; i++) {\n\t\t\t\tlet val = _values[i];\n\n\t\t\t\tif (val != null) {\n\t\t\t\t\tif (ori == 0)\n\t\t\t\t\t\tx = canOffs[i];\n\t\t\t\t\telse\n\t\t\t\t\t\ty = canOffs[i];\n\n\t\t\t\t\tval = \"\" + val;\n\n\t\t\t\t\tlet _parts = val.indexOf(\"\\n\") == -1 ? [val] : val.split(/\\n/gm);\n\n\t\t\t\t\tfor (let j = 0; j < _parts.length; j++) {\n\t\t\t\t\t\tlet text = _parts[j];\n\n\t\t\t\t\t\tif (angle) {\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(x, y + j * lineHeight); // can this be replaced with position math?\n\t\t\t\t\t\t\tctx.rotate(angle); // can this be done once?\n\t\t\t\t\t\t\tctx.fillText(text, 0, 0);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tctx.fillText(text, x, y + j * lineHeight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ticks\n\t\t\tif (ticks.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tticks.filter(self, splits, i, _space, incr),\n\t\t\t\t\tori,\n\t\t\t\t\tside,\n\t\t\t\t\tbasePos,\n\t\t\t\t\ttickSize,\n\t\t\t\t\troundDec(ticks.width * pxRatio, 3),\n\t\t\t\t\tticks.stroke(self, i),\n\t\t\t\t\tticks.dash,\n\t\t\t\t\tticks.cap,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// grid\n\t\t\tlet grid = axis.grid;\n\n\t\t\tif (grid.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\tcanOffs,\n\t\t\t\t\tgrid.filter(self, splits, i, _space, incr),\n\t\t\t\t\tori,\n\t\t\t\t\tori == 0 ? 2 : 1,\n\t\t\t\t\tori == 0 ? plotTop : plotLft,\n\t\t\t\t\tori == 0 ? plotHgt : plotWid,\n\t\t\t\t\troundDec(grid.width * pxRatio, 3),\n\t\t\t\t\tgrid.stroke(self, i),\n\t\t\t\t\tgrid.dash,\n\t\t\t\t\tgrid.cap,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (border.show) {\n\t\t\t\tdrawOrthoLines(\n\t\t\t\t\t[basePos],\n\t\t\t\t\t[1],\n\t\t\t\t\tori == 0 ? 1 : 0,\n\t\t\t\t\tori == 0 ? 1 : 2,\n\t\t\t\t\tori == 1 ? plotTop : plotLft,\n\t\t\t\t\tori == 1 ? plotHgt : plotWid,\n\t\t\t\t\troundDec(border.width * pxRatio, 3),\n\t\t\t\t\tborder.stroke(self, i),\n\t\t\t\t\tborder.dash,\n\t\t\t\t\tborder.cap,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfire(\"drawAxes\");\n\t}\n\n\tfunction resetYSeries(minMax) {\n\t//\tlog(\"resetYSeries()\", arguments);\n\n\t\tseries.forEach((s, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\ts._paths = null;\n\n\t\t\t\tif (minMax) {\n\t\t\t\t\tif (mode == 1) {\n\t\t\t\t\t\ts.min = null;\n\t\t\t\t\t\ts.max = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ts.facets.forEach(f => {\n\t\t\t\t\t\t\tf.min = null;\n\t\t\t\t\t\t\tf.max = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tlet queuedCommit = false;\n\n\tfunction commit() {\n\t\tif (!queuedCommit) {\n\t\t\tmicroTask(_commit);\n\t\t\tqueuedCommit = true;\n\t\t}\n\t}\n\n\tfunction _commit() {\n\t//\tlog(\"_commit()\", arguments);\n\n\t\tif (shouldSetScales) {\n\t\t\tsetScales();\n\t\t\tshouldSetScales = false;\n\t\t}\n\n\t\tif (shouldConvergeSize) {\n\t\t\tconvergeSize();\n\t\t\tshouldConvergeSize = false;\n\t\t}\n\n\t\tif (shouldSetSize) {\n\t\t\tsetStylePx(under, LEFT,   plotLftCss);\n\t\t\tsetStylePx(under, TOP,    plotTopCss);\n\t\t\tsetStylePx(under, WIDTH,  plotWidCss);\n\t\t\tsetStylePx(under, HEIGHT, plotHgtCss);\n\n\t\t\tsetStylePx(over, LEFT,    plotLftCss);\n\t\t\tsetStylePx(over, TOP,     plotTopCss);\n\t\t\tsetStylePx(over, WIDTH,   plotWidCss);\n\t\t\tsetStylePx(over, HEIGHT,  plotHgtCss);\n\n\t\t\tsetStylePx(wrap, WIDTH,   fullWidCss);\n\t\t\tsetStylePx(wrap, HEIGHT,  fullHgtCss);\n\n\t\t\t// NOTE: mutating this during print preview in Chrome forces transparent\n\t\t\t// canvas pixels to white, even when followed up with clearRect() below\n\t\t\tcan.width  = round(fullWidCss * pxRatio);\n\t\t\tcan.height = round(fullHgtCss * pxRatio);\n\n\t\t\taxes.forEach(({ _el, _show, _size, _pos, side }) => {\n\t\t\t\tif (_el != null) {\n\t\t\t\t\tif (_show) {\n\t\t\t\t\t\tlet posOffset = (side === 3 || side === 0 ? _size : 0);\n\t\t\t\t\t\tlet isVt = side % 2 == 1;\n\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"left\"   : \"top\",    _pos - posOffset);\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"width\"  : \"height\", _size);\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"top\"    : \"left\",   isVt ? plotTopCss : plotLftCss);\n\t\t\t\t\t\tsetStylePx(_el, isVt ? \"height\" : \"width\",  isVt ? plotHgtCss : plotWidCss);\n\n\t\t\t\t\t\tremClass(_el, OFF);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\taddClass(_el, OFF);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// invalidate ctx style cache\n\t\t\tctxStroke = ctxFill = ctxWidth = ctxJoin = ctxCap = ctxFont = ctxAlign = ctxBaseline = ctxDash = null;\n\t\t\tctxAlpha = 1;\n\n\t\t\tsyncRect(true);\n\n\t\t\tfire(\"setSize\");\n\n\t\t\tshouldSetSize = false;\n\t\t}\n\n\t\tif (fullWidCss > 0 && fullHgtCss > 0) {\n\t\t\tctx.clearRect(0, 0, can.width, can.height);\n\t\t\tfire(\"drawClear\");\n\t\t\tdrawOrder.forEach(fn => fn());\n\t\t\tfire(\"draw\");\n\t\t}\n\n\t\tif (select.show && shouldSetSelect) {\n\t\t\tsetSelect(select);\n\t\t\tshouldSetSelect = false;\n\t\t}\n\n\t\tif (cursor.show && shouldSetCursor) {\n\t\t\tupdateCursor(null, true, false);\n\t\t\tshouldSetCursor = false;\n\t\t}\n\n\t\tif (legend.show && legend.live && shouldSetLegend) {\n\t\t\tsetLegend();\n\t\t\tshouldSetLegend = false; // redundant currently\n\t\t}\n\n\t\tif (!ready) {\n\t\t\tready = true;\n\t\t\tself.status = 1;\n\n\t\t\tfire(\"ready\");\n\t\t}\n\n\t\tviaAutoScaleX = false;\n\n\t\tqueuedCommit = false;\n\t}\n\n\tself.redraw = (rebuildPaths, recalcAxes) => {\n\t\tshouldConvergeSize = recalcAxes || false;\n\n\t\tif (rebuildPaths !== false)\n\t\t\t_setScale(xScaleKey, scaleX.min, scaleX.max);\n\t\telse\n\t\t\tcommit();\n\t};\n\n\t// redraw() => setScale('x', scales.x.min, scales.x.max);\n\n\t// explicit, never re-ranged (is this actually true? for x and y)\n\tfunction setScale(key, opts) {\n\t\tlet sc = scales[key];\n\n\t\tif (sc.from == null) {\n\t\t\tif (dataLen == 0) {\n\t\t\t\tlet minMax = sc.range(self, opts.min, opts.max, key);\n\t\t\t\topts.min = minMax[0];\n\t\t\t\topts.max = minMax[1];\n\t\t\t}\n\n\t\t\tif (opts.min > opts.max) {\n\t\t\t\tlet _min = opts.min;\n\t\t\t\topts.min = opts.max;\n\t\t\t\topts.max = _min;\n\t\t\t}\n\n\t\t\tif (dataLen > 1 && opts.min != null && opts.max != null && opts.max - opts.min < 1e-16)\n\t\t\t\treturn;\n\n\t\t\tif (key == xScaleKey) {\n\t\t\t\tif (sc.distr == 2 && dataLen > 0) {\n\t\t\t\t\topts.min = closestIdx(opts.min, data[0]);\n\t\t\t\t\topts.max = closestIdx(opts.max, data[0]);\n\n\t\t\t\t\tif (opts.min == opts.max)\n\t\t\t\t\t\topts.max++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t//\tlog(\"setScale()\", arguments);\n\n\t\t\tpendScales[key] = opts;\n\n\t\t\tshouldSetScales = true;\n\t\t\tcommit();\n\t\t}\n\t}\n\n\tself.setScale = setScale;\n\n//\tINTERACTION\n\n\tlet xCursor;\n\tlet yCursor;\n\tlet vCursor;\n\tlet hCursor;\n\n\t// starting position before cursor.move\n\tlet rawMouseLeft0;\n\tlet rawMouseTop0;\n\n\t// starting position\n\tlet mouseLeft0;\n\tlet mouseTop0;\n\n\t// current position before cursor.move\n\tlet rawMouseLeft1;\n\tlet rawMouseTop1;\n\n\t// current position\n\tlet mouseLeft1;\n\tlet mouseTop1;\n\n\tlet dragging = false;\n\n\tconst drag = cursor.drag;\n\n\tlet dragX = drag.x;\n\tlet dragY = drag.y;\n\n\tif (cursor.show) {\n\t\tif (cursor.x)\n\t\t\txCursor = placeDiv(CURSOR_X, over);\n\t\tif (cursor.y)\n\t\t\tyCursor = placeDiv(CURSOR_Y, over);\n\n\t\tif (scaleX.ori == 0) {\n\t\t\tvCursor = xCursor;\n\t\t\thCursor = yCursor;\n\t\t}\n\t\telse {\n\t\t\tvCursor = yCursor;\n\t\t\thCursor = xCursor;\n\t\t}\n\n\t\tmouseLeft1 = cursor.left;\n\t\tmouseTop1 = cursor.top;\n\t}\n\n\tconst select = self.select = assign({\n\t\tshow:   true,\n\t\tover:   true,\n\t\tleft:   0,\n\t\twidth:  0,\n\t\ttop:    0,\n\t\theight: 0,\n\t}, opts.select);\n\n\tconst selectDiv = select.show ? placeDiv(SELECT, select.over ? over : under) : null;\n\n\tfunction setSelect(opts, _fire) {\n\t\tif (select.show) {\n\t\t\tfor (let prop in opts) {\n\t\t\t\tselect[prop] = opts[prop];\n\n\t\t\t\tif (prop in _hideProps)\n\t\t\t\t\tsetStylePx(selectDiv, prop, opts[prop]);\n\t\t\t}\n\n\t\t\t_fire !== false && fire(\"setSelect\");\n\t\t}\n\t}\n\n\tself.setSelect = setSelect;\n\n\tfunction toggleDOM(i, onOff) {\n\t\tlet s = series[i];\n\t\tlet label = showLegend ? legendRows[i] : null;\n\n\t\tif (s.show)\n\t\t\tlabel && remClass(label, OFF);\n\t\telse {\n\t\t\tlabel && addClass(label, OFF);\n\t\t\tcursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);\n\t\t}\n\t}\n\n\tfunction _setScale(key, min, max) {\n\t\tsetScale(key, {min, max});\n\t}\n\n\tfunction setSeries(i, opts, _fire, _pub) {\n\t//\tlog(\"setSeries()\", arguments);\n\n\t\tif (opts.focus != null)\n\t\t\tsetFocus(i);\n\n\t\tif (opts.show != null) {\n\t\t\tseries.forEach((s, si) => {\n\t\t\t\tif (si > 0 && (i == si || i == null)) {\n\t\t\t\t\ts.show = opts.show;\n\t\t\t\t\ttoggleDOM(si, opts.show);\n\n\t\t\t\t\t_setScale(mode == 2 ? s.facets[1].scale : s.scale, null, null);\n\t\t\t\t\tcommit();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t_fire !== false && fire(\"setSeries\", i, opts);\n\n\t\t_pub && pubSync(\"setSeries\", self, i, opts);\n\t}\n\n\tself.setSeries = setSeries;\n\n\tfunction setBand(bi, opts) {\n\t\tassign(bands[bi], opts);\n\t}\n\n\tfunction addBand(opts, bi) {\n\t\topts.fill = fnOrSelf(opts.fill || null);\n\t\topts.dir = ifNull(opts.dir, -1);\n\t\tbi = bi == null ? bands.length : bi;\n\t\tbands.splice(bi, 0, opts);\n\t}\n\n\tfunction delBand(bi) {\n\t\tif (bi == null)\n\t\t\tbands.length = 0;\n\t\telse\n\t\t\tbands.splice(bi, 1);\n\t}\n\n\tself.addBand = addBand;\n\tself.setBand = setBand;\n\tself.delBand = delBand;\n\n\tfunction setAlpha(i, value) {\n\t\tseries[i].alpha = value;\n\n\t\tif (cursor.show && cursorPts[i])\n\t\t\tcursorPts[i].style.opacity = value;\n\n\t\tif (showLegend && legendRows[i])\n\t\t\tlegendRows[i].style.opacity = value;\n\t}\n\n\t// y-distance\n\tlet closestDist;\n\tlet closestSeries;\n\tlet focusedSeries;\n\tconst FOCUS_TRUE  = {focus: true};\n\n\tfunction setFocus(i) {\n\t\tif (i != focusedSeries) {\n\t\t//\tlog(\"setFocus()\", arguments);\n\n\t\t\tlet allFocused = i == null;\n\n\t\t\tlet _setAlpha = focus.alpha != 1;\n\n\t\t\tseries.forEach((s, i2) => {\n\t\t\t\tlet isFocused = allFocused || i2 == 0 || i2 == i;\n\t\t\t\ts._focus = allFocused ? null : isFocused;\n\t\t\t\t_setAlpha && setAlpha(i2, isFocused ? 1 : focus.alpha);\n\t\t\t});\n\n\t\t\tfocusedSeries = i;\n\t\t\t_setAlpha && commit();\n\t\t}\n\t}\n\n\tif (showLegend && cursorFocus) {\n\t\tonMouse(mouseleave, legendTable, e => {\n\t\t\tif (cursor._lock)\n\t\t\t\treturn;\n\n\t\t\tsetCursorEvent(e);\n\n\t\t\tif (focusedSeries != null)\n\t\t\t\tsetSeries(null, FOCUS_TRUE, true, syncOpts.setSeries);\n\t\t});\n\t}\n\n\tfunction posToVal(pos, scale, can) {\n\t\tlet sc = scales[scale];\n\n\t\tif (can)\n\t\t\tpos = pos / pxRatio - (sc.ori == 1 ? plotTopCss : plotLftCss);\n\n\t\tlet dim = plotWidCss;\n\n\t\tif (sc.ori == 1) {\n\t\t\tdim = plotHgtCss;\n\t\t\tpos = dim - pos;\n\t\t}\n\n\t\tif (sc.dir == -1)\n\t\t\tpos = dim - pos;\n\n\t\tlet _min = sc._min,\n\t\t\t_max = sc._max,\n\t\t\tpct = pos / dim;\n\n\t\tlet sv = _min + (_max - _min) * pct;\n\n\t\tlet distr = sc.distr;\n\n\t\treturn (\n\t\t\tdistr == 3 ? pow(10, sv) :\n\t\t\tdistr == 4 ? sinh(sv, sc.asinh) :\n\t\t\tsv\n\t\t);\n\t}\n\n\tfunction closestIdxFromXpos(pos, can) {\n\t\tlet v = posToVal(pos, xScaleKey, can);\n\t\treturn closestIdx(v, data[0], i0, i1);\n\t}\n\n\tself.valToIdx = val => closestIdx(val, data[0]);\n\tself.posToIdx = closestIdxFromXpos;\n\tself.posToVal = posToVal;\n\tself.valToPos = (val, scale, can) => (\n\t\tscales[scale].ori == 0 ?\n\t\tgetHPos(val, scales[scale],\n\t\t\tcan ? plotWid : plotWidCss,\n\t\t\tcan ? plotLft : 0,\n\t\t) :\n\t\tgetVPos(val, scales[scale],\n\t\t\tcan ? plotHgt : plotHgtCss,\n\t\t\tcan ? plotTop : 0,\n\t\t)\n\t);\n\n\t// defers calling expensive functions\n\tfunction batch(fn) {\n\t\tfn(self);\n\t\tcommit();\n\t}\n\n\tself.batch = batch;\n\n\tself.setCursor = (opts, _fire, _pub) => {\n\t\tmouseLeft1 = opts.left;\n\t\tmouseTop1 = opts.top;\n\t//\tassign(cursor, opts);\n\t\tupdateCursor(null, _fire, _pub);\n\t};\n\n\tfunction setSelH(off, dim) {\n\t\tsetStylePx(selectDiv, LEFT,  select.left = off);\n\t\tsetStylePx(selectDiv, WIDTH, select.width = dim);\n\t}\n\n\tfunction setSelV(off, dim) {\n\t\tsetStylePx(selectDiv, TOP,    select.top = off);\n\t\tsetStylePx(selectDiv, HEIGHT, select.height = dim);\n\t}\n\n\tlet setSelX = scaleX.ori == 0 ? setSelH : setSelV;\n\tlet setSelY = scaleX.ori == 1 ? setSelH : setSelV;\n\n\tfunction syncLegend() {\n\t\tif (showLegend && legend.live) {\n\t\t\tfor (let i = mode == 2 ? 1 : 0; i < series.length; i++) {\n\t\t\t\tif (i == 0 && multiValLegend)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlet vals = legend.values[i];\n\n\t\t\t\tlet j = 0;\n\n\t\t\t\tfor (let k in vals)\n\t\t\t\t\tlegendCells[i][j++].firstChild.nodeValue = vals[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setLegend(opts, _fire) {\n\t\tif (opts != null) {\n\t\t\tif (opts.idxs) {\n\t\t\t\topts.idxs.forEach((didx, sidx) => {\n\t\t\t\t\tactiveIdxs[sidx] = didx;\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (!isUndef(opts.idx))\n\t\t\t\tactiveIdxs.fill(opts.idx);\n\n\t\t\tlegend.idx = activeIdxs[0];\n\t\t}\n\n\t\tfor (let sidx = 0; sidx < series.length; sidx++) {\n\t\t\tif (sidx > 0 || mode == 1 && !multiValLegend)\n\t\t\t\tsetLegendValues(sidx, activeIdxs[sidx]);\n\t\t}\n\n\t\tif (showLegend && legend.live)\n\t\t\tsyncLegend();\n\n\t\tshouldSetLegend = false;\n\n\t\t_fire !== false && fire(\"setLegend\");\n\t}\n\n\tself.setLegend = setLegend;\n\n\tfunction setLegendValues(sidx, idx) {\n\t\tlet s = series[sidx];\n\t\tlet src = sidx == 0 && xScaleDistr == 2 ? data0 : data[sidx];\n\t\tlet val;\n\n\t\tif (multiValLegend)\n\t\t\tval = s.values(self, sidx, idx) ?? NULL_LEGEND_VALUES;\n\t\telse {\n\t\t\tval = s.value(self, idx == null ? null : src[idx], sidx, idx);\n\t\t\tval = val == null ? NULL_LEGEND_VALUES : {_: val};\n\t\t}\n\n\t\tlegend.values[sidx] = val;\n\t}\n\n\tfunction updateCursor(src, _fire, _pub) {\n\t//\tts == null && log(\"updateCursor()\", arguments);\n\n\t\trawMouseLeft1 = mouseLeft1;\n\t\trawMouseTop1 = mouseTop1;\n\n\t\t[mouseLeft1, mouseTop1] = cursor.move(self, mouseLeft1, mouseTop1);\n\n\t\tif (cursor.show) {\n\t\t\tvCursor && elTrans(vCursor, round(mouseLeft1), 0, plotWidCss, plotHgtCss);\n\t\t\thCursor && elTrans(hCursor, 0, round(mouseTop1), plotWidCss, plotHgtCss);\n\t\t}\n\n\t\tlet idx;\n\n\t\t// when zooming to an x scale range between datapoints the binary search\n\t\t// for nearest min/max indices results in this condition. cheap hack :D\n\t\tlet noDataInRange = i0 > i1; // works for mode 1 only\n\n\t\tclosestDist = inf;\n\n\t\t// TODO: extract\n\t\tlet xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss;\n\t\tlet yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss;\n\n\t\t// if cursor hidden, hide points & clear legend vals\n\t\tif (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {\n\t\t\tidx = null;\n\n\t\t\tfor (let i = 0; i < series.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cursorFocus)\n\t\t\t\tsetSeries(null, FOCUS_TRUE, true, src == null && syncOpts.setSeries);\n\n\t\t\tif (legend.live) {\n\t\t\t\tactiveIdxs.fill(idx);\n\t\t\t\tshouldSetLegend = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t//\tlet pctY = 1 - (y / rect.height);\n\n\t\t\tlet mouseXPos, valAtPosX, xPos;\n\n\t\t\tif (mode == 1) {\n\t\t\t\tmouseXPos = scaleX.ori == 0 ? mouseLeft1 : mouseTop1;\n\t\t\t\tvalAtPosX = posToVal(mouseXPos, xScaleKey);\n\t\t\t\tidx = closestIdx(valAtPosX, data[0], i0, i1);\n\t\t\t\txPos = valToPosX(data[0][idx], scaleX, xDim, 0);\n\t\t\t}\n\n\t\t\tfor (let i = mode == 2 ? 1 : 0; i < series.length; i++) {\n\t\t\t\tlet s = series[i];\n\n\t\t\t\tlet idx1  = activeIdxs[i];\n\t\t\t\tlet yVal1 = mode == 1 ? data[i][idx1] : data[i][1][idx1];\n\n\t\t\t\tlet idx2  = cursor.dataIdx(self, i, idx, valAtPosX);\n\t\t\t\tlet yVal2 = mode == 1 ? data[i][idx2] : data[i][1][idx2];\n\n\t\t\t\tshouldSetLegend = shouldSetLegend || yVal2 != yVal1 || idx2 != idx1;\n\n\t\t\t\tactiveIdxs[i] = idx2;\n\n\t\t\t\tlet xPos2 = incrRoundUp(idx2 == idx ? xPos : valToPosX(mode == 1 ? data[0][idx2] : data[i][0][idx2], scaleX, xDim, 0), 1);\n\n\t\t\t\tif (i > 0 && s.show) {\n\t\t\t\t\tlet yPos = yVal2 == null ? -10 : incrRoundUp(valToPosY(yVal2, mode == 1 ? scales[s.scale] : scales[s.facets[1].scale], yDim, 0), 1);\n\n\t\t\t\t\tif (cursorFocus && yPos >= 0 && mode == 1) {\n\t\t\t\t\t\tlet dist = abs(yPos - mouseTop1);\n\n\t\t\t\t\t\tif (dist < closestDist) {\n\t\t\t\t\t\t\tlet bias = focus.bias;\n\n\t\t\t\t\t\t\tif (bias != 0) {\n\t\t\t\t\t\t\t\tlet mouseYPos = scaleX.ori == 1 ? mouseLeft1 : mouseTop1;\n\t\t\t\t\t\t\t\tlet mouseYVal = posToVal(mouseYPos, s.scale);\n\n\t\t\t\t\t\t\t\tlet seriesYValSign = yVal2     >= 0 ? 1 : -1;\n\t\t\t\t\t\t\t\tlet mouseYValSign  = mouseYVal >= 0 ? 1 : -1;\n\n\t\t\t\t\t\t\t\t// with a focus bias, we will never cross zero when prox testing\n\t\t\t\t\t\t\t\t// it's either closest towards zero, or closest away from zero\n\t\t\t\t\t\t\t\tif (mouseYValSign == seriesYValSign && (\n\t\t\t\t\t\t\t\t\tmouseYValSign == 1 ?\n\t\t\t\t\t\t\t\t\t\t(bias == 1 ? yVal2 >= mouseYVal : yVal2 <= mouseYVal) :  // >= 0\n\t\t\t\t\t\t\t\t\t\t(bias == 1 ? yVal2 <= mouseYVal : yVal2 >= mouseYVal)    //  < 0\n\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\tclosestDist = dist;\n\t\t\t\t\t\t\t\t\tclosestSeries = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tclosestDist = dist;\n\t\t\t\t\t\t\t\tclosestSeries = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet hPos, vPos;\n\n\t\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\t\thPos = xPos2;\n\t\t\t\t\t\tvPos = yPos;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thPos = yPos;\n\t\t\t\t\t\tvPos = xPos2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shouldSetLegend && cursorPts.length > 1) {\n\t\t\t\t\t\telColor(cursorPts[i], cursor.points.fill(self, i), cursor.points.stroke(self, i));\n\n\t\t\t\t\t\tlet ptWid, ptHgt, ptLft, ptTop,\n\t\t\t\t\t\t\tcentered = true,\n\t\t\t\t\t\t\tgetBBox = cursor.points.bbox;\n\n\t\t\t\t\t\tif (getBBox != null) {\n\t\t\t\t\t\t\tcentered = false;\n\n\t\t\t\t\t\t\tlet bbox = getBBox(self, i);\n\n\t\t\t\t\t\t\tptLft = bbox.left;\n\t\t\t\t\t\t\tptTop = bbox.top;\n\t\t\t\t\t\t\tptWid = bbox.width;\n\t\t\t\t\t\t\tptHgt = bbox.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tptLft = hPos;\n\t\t\t\t\t\t\tptTop = vPos;\n\t\t\t\t\t\t\tptWid = ptHgt = cursor.points.size(self, i);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telSize(cursorPts[i], ptWid, ptHgt, centered);\n\t\t\t\t\t\telTrans(cursorPts[i], ptLft, ptTop, plotWidCss, plotHgtCss);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcursor.idx = idx;\n\t\tcursor.left = mouseLeft1;\n\t\tcursor.top = mouseTop1;\n\n\t\tif (shouldSetLegend) {\n\t\t\tlegend.idx = idx;\n\t\t\tsetLegend();\n\t\t}\n\n\t\t// nit: cursor.drag.setSelect is assumed always true\n\t\tif (select.show && dragging) {\n\t\t\tif (src != null) {\n\t\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\t\t\t\tlet [matchXKeys, matchYKeys] = syncOpts.match;\n\t\t\t\tlet [xKeySrc, yKeySrc] = src.cursor.sync.scales;\n\n\t\t\t\t// match the dragX/dragY implicitness/explicitness of src\n\t\t\t\tlet sdrag = src.cursor.drag;\n\t\t\t\tdragX = sdrag._x;\n\t\t\t\tdragY = sdrag._y;\n\n\t\t\t\tif (dragX || dragY) {\n\t\t\t\t\tlet { left, top, width, height } = src.select;\n\n\t\t\t\t\tlet sori = src.scales[xKey].ori;\n\t\t\t\t\tlet sPosToVal = src.posToVal;\n\n\t\t\t\t\tlet sOff, sDim, sc, a, b;\n\n\t\t\t\t\tlet matchingX = xKey != null && matchXKeys(xKey, xKeySrc);\n\t\t\t\t\tlet matchingY = yKey != null && matchYKeys(yKey, yKeySrc);\n\n\t\t\t\t\tif (matchingX && dragX) {\n\t\t\t\t\t\tif (sori == 0) {\n\t\t\t\t\t\t\tsOff = left;\n\t\t\t\t\t\t\tsDim = width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsOff = top;\n\t\t\t\t\t\t\tsDim = height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsc = scales[xKey];\n\n\t\t\t\t\t\ta = valToPosX(sPosToVal(sOff, xKeySrc),        sc, xDim, 0);\n\t\t\t\t\t\tb = valToPosX(sPosToVal(sOff + sDim, xKeySrc), sc, xDim, 0);\n\n\t\t\t\t\t\tsetSelX(min(a,b), abs(b-a));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsetSelX(0, xDim);\n\n\t\t\t\t\tif (matchingY && dragY) {\n\t\t\t\t\t\tif (sori == 1) {\n\t\t\t\t\t\t\tsOff = left;\n\t\t\t\t\t\t\tsDim = width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsOff = top;\n\t\t\t\t\t\t\tsDim = height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsc = scales[yKey];\n\n\t\t\t\t\t\ta = valToPosY(sPosToVal(sOff, yKeySrc),        sc, yDim, 0);\n\t\t\t\t\t\tb = valToPosY(sPosToVal(sOff + sDim, yKeySrc), sc, yDim, 0);\n\n\t\t\t\t\t\tsetSelY(min(a,b), abs(b-a));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tsetSelY(0, yDim);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thideSelect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet rawDX = abs(rawMouseLeft1 - rawMouseLeft0);\n\t\t\t\tlet rawDY = abs(rawMouseTop1 - rawMouseTop0);\n\n\t\t\t\tif (scaleX.ori == 1) {\n\t\t\t\t\tlet _rawDX = rawDX;\n\t\t\t\t\trawDX = rawDY;\n\t\t\t\t\trawDY = _rawDX;\n\t\t\t\t}\n\n\t\t\t\tdragX = drag.x && rawDX >= drag.dist;\n\t\t\t\tdragY = drag.y && rawDY >= drag.dist;\n\n\t\t\t\tlet uni = drag.uni;\n\n\t\t\t\tif (uni != null) {\n\t\t\t\t\t// only calc drag status if they pass the dist thresh\n\t\t\t\t\tif (dragX && dragY) {\n\t\t\t\t\t\tdragX = rawDX >= uni;\n\t\t\t\t\t\tdragY = rawDY >= uni;\n\n\t\t\t\t\t\t// force unidirectionality when both are under uni limit\n\t\t\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\t\t\tif (rawDY > rawDX)\n\t\t\t\t\t\t\t\tdragY = true;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdragX = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (drag.x && drag.y && (dragX || dragY))\n\t\t\t\t\t// if omni with no uni then both dragX / dragY should be true if either is true\n\t\t\t\t\tdragX = dragY = true;\n\n\t\t\t\tlet p0, p1;\n\n\t\t\t\tif (dragX) {\n\t\t\t\t\tif (scaleX.ori == 0) {\n\t\t\t\t\t\tp0 = mouseLeft0;\n\t\t\t\t\t\tp1 = mouseLeft1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp0 = mouseTop0;\n\t\t\t\t\t\tp1 = mouseTop1;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetSelX(min(p0, p1), abs(p1 - p0));\n\n\t\t\t\t\tif (!dragY)\n\t\t\t\t\t\tsetSelY(0, yDim);\n\t\t\t\t}\n\n\t\t\t\tif (dragY) {\n\t\t\t\t\tif (scaleX.ori == 1) {\n\t\t\t\t\t\tp0 = mouseLeft0;\n\t\t\t\t\t\tp1 = mouseLeft1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp0 = mouseTop0;\n\t\t\t\t\t\tp1 = mouseTop1;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetSelY(min(p0, p1), abs(p1 - p0));\n\n\t\t\t\t\tif (!dragX)\n\t\t\t\t\t\tsetSelX(0, xDim);\n\t\t\t\t}\n\n\t\t\t\t// the drag didn't pass the dist requirement\n\t\t\t\tif (!dragX && !dragY) {\n\t\t\t\t\tsetSelX(0, 0);\n\t\t\t\t\tsetSelY(0, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdrag._x = dragX;\n\t\tdrag._y = dragY;\n\n\t\tif (src == null) {\n\t\t\tif (_pub) {\n\t\t\t\tif (syncKey != null) {\n\t\t\t\t\tlet [xSyncKey, ySyncKey] = syncOpts.scales;\n\n\t\t\t\t\tsyncOpts.values[0] = xSyncKey != null ? posToVal(scaleX.ori == 0 ? mouseLeft1 : mouseTop1, xSyncKey) : null;\n\t\t\t\t\tsyncOpts.values[1] = ySyncKey != null ? posToVal(scaleX.ori == 1 ? mouseLeft1 : mouseTop1, ySyncKey) : null;\n\t\t\t\t}\n\n\t\t\t\tpubSync(mousemove, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);\n\t\t\t}\n\n\t\t\tif (cursorFocus) {\n\t\t\t\tlet shouldPub = _pub && syncOpts.setSeries;\n\t\t\t\tlet p = focus.prox;\n\n\t\t\t\tif (focusedSeries == null) {\n\t\t\t\t\tif (closestDist <= p)\n\t\t\t\t\t\tsetSeries(closestSeries, FOCUS_TRUE, true, shouldPub);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (closestDist > p)\n\t\t\t\t\t\tsetSeries(null, FOCUS_TRUE, true, shouldPub);\n\t\t\t\t\telse if (closestSeries != focusedSeries)\n\t\t\t\t\t\tsetSeries(closestSeries, FOCUS_TRUE, true, shouldPub);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_fire !== false && fire(\"setCursor\");\n\t}\n\n\tlet rect = null;\n\n\tObject.defineProperty(self, 'rect', {\n\t\tget() {\n\t\t\tif (rect == null)\n\t\t\t\tsyncRect(false);\n\n\t\t\treturn rect;\n\t\t},\n\t});\n\n\tfunction syncRect(defer = false) {\n\t\tif (defer)\n\t\t\trect = null;\n\t\telse {\n\t\t\trect = over.getBoundingClientRect();\n\t\t\tfire(\"syncRect\", rect);\n\t\t}\n\t}\n\n\tfunction mouseMove(e, src, _l, _t, _w, _h, _i) {\n\t\tif (cursor._lock)\n\t\t\treturn;\n\n\t\t// Chrome on Windows has a bug which triggers a stray mousemove event after an initial mousedown event\n\t\t// when clicking into a plot as part of re-focusing the browser window.\n\t\t// we gotta ignore it to avoid triggering a phantom drag / setSelect\n\t\t// However, on touch-only devices Chrome-based browsers trigger a 0-distance mousemove before mousedown\n\t\t// so we don't ignore it when mousedown has set the dragging flag\n\t\tif (dragging && e != null && e.movementX == 0 && e.movementY == 0)\n\t\t\treturn;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, false, e != null);\n\n\t\tif (e != null)\n\t\t\tupdateCursor(null, true, true);\n\t\telse\n\t\t\tupdateCursor(src, true, false);\n\t}\n\n\tfunction cacheMouse(e, src, _l, _t, _w, _h, _i, initial, snap) {\n\t\tif (rect == null)\n\t\t\tsyncRect(false);\n\n\t\tsetCursorEvent(e);\n\n\t\tif (e != null) {\n\t\t\t_l = e.clientX - rect.left;\n\t\t\t_t = e.clientY - rect.top;\n\t\t}\n\t\telse {\n\t\t\tif (_l < 0 || _t < 0) {\n\t\t\t\tmouseLeft1 = -10;\n\t\t\t\tmouseTop1 = -10;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet [xKey, yKey] = syncOpts.scales;\n\n\t\t\tlet syncOptsSrc = src.cursor.sync;\n\t\t\tlet [xValSrc, yValSrc] = syncOptsSrc.values;\n\t\t\tlet [xKeySrc, yKeySrc] = syncOptsSrc.scales;\n\t\t\tlet [matchXKeys, matchYKeys] = syncOpts.match;\n\n\t\t\tlet rotSrc = src.axes[0].side % 2 == 1;\n\n\t\t\tlet xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss,\n\t\t\t\tyDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss,\n\t\t\t\t_xDim = rotSrc ? _h : _w,\n\t\t\t\t_yDim = rotSrc ? _w : _h,\n\t\t\t\t_xPos = rotSrc ? _t : _l,\n\t\t\t\t_yPos = rotSrc ? _l : _t;\n\n\t\t\tif (xKeySrc != null)\n\t\t\t\t_l = matchXKeys(xKey, xKeySrc) ? getPos(xValSrc, scales[xKey], xDim, 0) : -10;\n\t\t\telse\n\t\t\t\t_l = xDim * (_xPos/_xDim);\n\n\t\t\tif (yKeySrc != null)\n\t\t\t\t_t = matchYKeys(yKey, yKeySrc) ? getPos(yValSrc, scales[yKey], yDim, 0) : -10;\n\t\t\telse\n\t\t\t\t_t = yDim * (_yPos/_yDim);\n\n\t\t\tif (scaleX.ori == 1) {\n\t\t\t\tlet __l = _l;\n\t\t\t\t_l = _t;\n\t\t\t\t_t = __l;\n\t\t\t}\n\t\t}\n\n\t\tif (snap) {\n\t\t\tif (_l <= 1 || _l >= plotWidCss - 1)\n\t\t\t\t_l = incrRound(_l, plotWidCss);\n\n\t\t\tif (_t <= 1 || _t >= plotHgtCss - 1)\n\t\t\t\t_t = incrRound(_t, plotHgtCss);\n\t\t}\n\n\t\tif (initial) {\n\t\t\trawMouseLeft0 = _l;\n\t\t\trawMouseTop0 = _t;\n\n\t\t\t[mouseLeft0, mouseTop0] = cursor.move(self, _l, _t);\n\t\t}\n\t\telse {\n\t\t\tmouseLeft1 = _l;\n\t\t\tmouseTop1 = _t;\n\t\t}\n\t}\n\n\tconst _hideProps = {\n\t\twidth: 0,\n\t\theight: 0,\n\t\tleft: 0,\n\t\ttop: 0,\n\t};\n\n\tfunction hideSelect() {\n\t\tsetSelect(_hideProps, false);\n\t}\n\n\tlet downSelectLeft;\n\tlet downSelectTop;\n\tlet downSelectWidth;\n\tlet downSelectHeight;\n\n\tfunction mouseDown(e, src, _l, _t, _w, _h, _i) {\n\t\tdragging = true;\n\t\tdragX = dragY = drag._x = drag._y = false;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, true, false);\n\n\t\tif (e != null) {\n\t\t\tonMouse(mouseup, doc, mouseUp, false);\n\t\t\tpubSync(mousedown, self, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);\n\t\t}\n\n\t\tlet { left, top, width, height } = select;\n\n\t\tdownSelectLeft   = left;\n\t\tdownSelectTop    = top;\n\t\tdownSelectWidth  = width;\n\t\tdownSelectHeight = height;\n\n\t\thideSelect();\n\t}\n\n\tfunction mouseUp(e, src, _l, _t, _w, _h, _i) {\n\t\tdragging = drag._x = drag._y = false;\n\n\t\tcacheMouse(e, src, _l, _t, _w, _h, _i, false, true);\n\n\t\tlet { left, top, width, height } = select;\n\n\t\tlet hasSelect = width > 0 || height > 0;\n\t\tlet chgSelect = (\n\t\t\tdownSelectLeft   != left   ||\n\t\t\tdownSelectTop    != top    ||\n\t\t\tdownSelectWidth  != width  ||\n\t\t\tdownSelectHeight != height\n\t\t);\n\n\t\thasSelect && chgSelect && setSelect(select);\n\n\t\tif (drag.setScale && hasSelect && chgSelect) {\n\t\t//\tif (syncKey != null) {\n\t\t//\t\tdragX = drag.x;\n\t\t//\t\tdragY = drag.y;\n\t\t//\t}\n\n\t\t\tlet xOff = left,\n\t\t\t\txDim = width,\n\t\t\t\tyOff = top,\n\t\t\t\tyDim = height;\n\n\t\t\tif (scaleX.ori == 1) {\n\t\t\t\txOff = top,\n\t\t\t\txDim = height,\n\t\t\t\tyOff = left,\n\t\t\t\tyDim = width;\n\t\t\t}\n\n\t\t\tif (dragX) {\n\t\t\t\t_setScale(xScaleKey,\n\t\t\t\t\tposToVal(xOff, xScaleKey),\n\t\t\t\t\tposToVal(xOff + xDim, xScaleKey)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (dragY) {\n\t\t\t\tfor (let k in scales) {\n\t\t\t\t\tlet sc = scales[k];\n\n\t\t\t\t\tif (k != xScaleKey && sc.from == null && sc.min != inf) {\n\t\t\t\t\t\t_setScale(k,\n\t\t\t\t\t\t\tposToVal(yOff + yDim, k),\n\t\t\t\t\t\t\tposToVal(yOff, k)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thideSelect();\n\t\t}\n\t\telse if (cursor.lock) {\n\t\t\tcursor._lock = !cursor._lock;\n\n\t\t\tif (!cursor._lock)\n\t\t\t\tupdateCursor(null, true, false);\n\t\t}\n\n\t\tif (e != null) {\n\t\t\toffMouse(mouseup, doc);\n\t\t\tpubSync(mouseup, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t\t}\n\t}\n\n\tfunction mouseLeave(e, src, _l, _t, _w, _h, _i) {\n\t\tif (cursor._lock)\n\t\t\treturn;\n\n\t\tsetCursorEvent(e);\n\n\t\tlet _dragging = dragging;\n\n\t\tif (dragging) {\n\t\t\t// handle case when mousemove aren't fired all the way to edges by browser\n\t\t\tlet snapH = true;\n\t\t\tlet snapV = true;\n\t\t\tlet snapProx = 10;\n\n\t\t\tlet dragH, dragV;\n\n\t\t\tif (scaleX.ori == 0) {\n\t\t\t\tdragH = dragX;\n\t\t\t\tdragV = dragY;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdragH = dragY;\n\t\t\t\tdragV = dragX;\n\t\t\t}\n\n\t\t\tif (dragH && dragV) {\n\t\t\t\t// maybe omni corner snap\n\t\t\t\tsnapH = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;\n\t\t\t\tsnapV = mouseTop1  <= snapProx || mouseTop1  >= plotHgtCss - snapProx;\n\t\t\t}\n\n\t\t\tif (dragH && snapH)\n\t\t\t\tmouseLeft1 = mouseLeft1 < mouseLeft0 ? 0 : plotWidCss;\n\n\t\t\tif (dragV && snapV)\n\t\t\t\tmouseTop1 = mouseTop1 < mouseTop0 ? 0 : plotHgtCss;\n\n\t\t\tupdateCursor(null, true, true);\n\n\t\t\tdragging = false;\n\t\t}\n\n\t\tmouseLeft1 = -10;\n\t\tmouseTop1 = -10;\n\n\t\t// passing a non-null timestamp to force sync/mousemove event\n\t\tupdateCursor(null, true, true);\n\n\t\tif (_dragging)\n\t\t\tdragging = _dragging;\n\t}\n\n\tfunction dblClick(e, src, _l, _t, _w, _h, _i) {\n\t\tif (cursor._lock)\n\t\t\treturn;\n\n\t\tsetCursorEvent(e);\n\n\t\tautoScaleX();\n\n\t\thideSelect();\n\n\t\tif (e != null)\n\t\t\tpubSync(dblclick, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);\n\t}\n\n\tfunction syncPxRatio() {\n\t\taxes.forEach(syncFontSize);\n\t\t_setSize(self.width, self.height, true);\n\t}\n\n\ton(dppxchange, win, syncPxRatio);\n\n\t// internal pub/sub\n\tconst events = {};\n\n\tevents.mousedown = mouseDown;\n\tevents.mousemove = mouseMove;\n\tevents.mouseup = mouseUp;\n\tevents.dblclick = dblClick;\n\tevents[\"setSeries\"] = (e, src, idx, opts) => {\n\t\tlet seriesIdxMatcher = syncOpts.match[2];\n\t\tidx = seriesIdxMatcher(self, src, idx);\n\t\tidx != -1 && setSeries(idx, opts, true, false);\n\t};\n\n\tif (cursor.show) {\n\t\tonMouse(mousedown,  over, mouseDown);\n\t\tonMouse(mousemove,  over, mouseMove);\n\t\tonMouse(mouseenter, over, e => {\n\t\t\tsetCursorEvent(e);\n\t\t\tsyncRect(false);\n\t\t});\n\t\tonMouse(mouseleave, over, mouseLeave);\n\n\t\tonMouse(dblclick, over, dblClick);\n\n\t\tcursorPlots.add(self);\n\n\t\tself.syncRect = syncRect;\n\t}\n\n\t// external on/off\n\tconst hooks = self.hooks = opts.hooks || {};\n\n\tfunction fire(evName, a1, a2) {\n\t\tif (evName in hooks) {\n\t\t\thooks[evName].forEach(fn => {\n\t\t\t\tfn.call(null, self, a1, a2);\n\t\t\t});\n\t\t}\n\t}\n\n\t(opts.plugins || []).forEach(p => {\n\t\tfor (let evName in p.hooks)\n\t\t\thooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]);\n\t});\n\n\tconst seriesIdxMatcher = (self, src, srcSeriesIdx) => srcSeriesIdx;\n\n\tconst syncOpts = assign({\n\t\tkey: null,\n\t\tsetSeries: false,\n\t\tfilters: {\n\t\t\tpub: retTrue,\n\t\t\tsub: retTrue,\n\t\t},\n\t\tscales: [xScaleKey, series[1] ? series[1].scale : null],\n\t\tmatch: [retEq, retEq, seriesIdxMatcher],\n\t\tvalues: [null, null],\n\t}, cursor.sync);\n\n\tif (syncOpts.match.length == 2)\n\t\tsyncOpts.match.push(seriesIdxMatcher);\n\n\tcursor.sync = syncOpts;\n\n\tconst syncKey = syncOpts.key;\n\n\tconst sync = _sync(syncKey);\n\n\tfunction pubSync(type, src, x, y, w, h, i) {\n\t\tif (syncOpts.filters.pub(type, src, x, y, w, h, i))\n\t\t\tsync.pub(type, src, x, y, w, h, i);\n\t}\n\n\tsync.sub(self);\n\n\tfunction pub(type, src, x, y, w, h, i) {\n\t\tif (syncOpts.filters.sub(type, src, x, y, w, h, i))\n\t\t\tevents[type](null, src, x, y, w, h, i);\n\t}\n\n\tself.pub = pub;\n\n\tfunction destroy() {\n\t\tsync.unsub(self);\n\t\tcursorPlots.delete(self);\n\t\tmouseListeners.clear();\n\t\toff(dppxchange, win, syncPxRatio);\n\t\troot.remove();\n\t\tlegendTable?.remove(); // in case mounted outside of root\n\t\tfire(\"destroy\");\n\t}\n\n\tself.destroy = destroy;\n\n\tfunction _init() {\n\t\tfire(\"init\", opts, data);\n\n\t\tsetData(data || opts.data, false);\n\n\t\tif (pendScales[xScaleKey])\n\t\t\tsetScale(xScaleKey, pendScales[xScaleKey]);\n\t\telse\n\t\t\tautoScaleX();\n\n\t\tshouldSetSelect = select.show && (select.width > 0 || select.height > 0);\n\t\tshouldSetCursor = shouldSetLegend = true;\n\n\t\t_setSize(opts.width, opts.height);\n\t}\n\n\tseries.forEach(initSeries);\n\n\taxes.forEach(initAxis);\n\n\tif (then) {\n\t\tif (then instanceof HTMLElement) {\n\t\t\tthen.appendChild(root);\n\t\t\t_init();\n\t\t}\n\t\telse\n\t\t\tthen(self, _init);\n\t}\n\telse\n\t\t_init();\n\n\treturn self;\n}\n\nuPlot.assign = assign;\nuPlot.fmtNum = fmtNum;\nuPlot.rangeNum = rangeNum;\nuPlot.rangeLog = rangeLog;\nuPlot.rangeAsinh = rangeAsinh;\nuPlot.orient   = orient;\nuPlot.pxRatio = pxRatio;\n\n{\n\tuPlot.join = join;\n}\n\n{\n\tuPlot.fmtDate = fmtDate;\n\tuPlot.tzDate  = tzDate;\n}\n\nuPlot.sync = _sync;\n\n{\n\tuPlot.addGap = addGap;\n\tuPlot.clipGaps = clipGaps;\n\n\tlet paths = uPlot.paths = {\n\t\tpoints,\n\t};\n\n\t(paths.linear  = linear);\n\t(paths.stepped = stepped);\n\t(paths.bars    = bars);\n\t(paths.spline  = monotoneCubic);\n}\n\nexport { uPlot as default };\n", "const LOCALIZATIONS: Record<string, Record<string, string>> = {\n    ru: {\n        'hide-all': '\u0421\u043A\u0440\u044B\u0442\u044C \u0432\u0441\u0435',\n        'show-all': '\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0432\u0441\u0435',\n        sum: '\u0421\u0443\u043C\u043C\u0430',\n        scale: '\u0428\u043A\u0430\u043B\u0430',\n        series: '\u041B\u0438\u043D\u0438\u044F',\n        weekend: '\u0412\u044B\u0445\u043E\u0434\u043D\u043E\u0439',\n        nodata: '\u041D\u0435\u0442 \u0434\u0430\u043D\u043D\u044B\u0445',\n    },\n    en: {\n        'hide-all': 'Hide all',\n        'show-all': 'Show all',\n        sum: 'Total',\n        scale: 'Scale',\n        series: 'Series',\n        weekend: 'Weekend',\n        nodata: 'No data',\n    },\n};\n\nexport default (locale: keyof typeof LOCALIZATIONS | Record<string, string> = 'en') => {\n    if (typeof locale !== 'string') {\n        LOCALIZATIONS.custom = locale;\n        locale = 'custom';\n    }\n\n    return (key: string) => {\n        return LOCALIZATIONS[locale as string][key] || key;\n    };\n};\n", "import {px} from '../../utils/common';\n\nconst NAMES = {\n    size: ['height', 'width'],\n    clientSize: ['clientHeight', 'clientWidth'],\n    offsetSize: ['offsetHeight', 'offsetWidth'],\n    maxSize: ['maxHeight', 'maxWidth'],\n    before: ['top', 'left'],\n    marginBefore: ['marginTop', 'marginLeft'],\n    after: ['bottom', 'right'],\n    marginAfter: ['marginBottom', 'marginRight'],\n    scrollOffset: ['pageYOffset', 'pageXOffset'],\n    offset: ['offsetY', 'offsetY'],\n    offsetOpt: ['yOffset', 'xOffset'],\n};\n\ninterface Props {\n    size: 'height' | 'width';\n    clientSize: 'clientHeight' | 'clientWidth';\n    offsetSize: 'offsetHeight' | 'offsetWidth';\n    maxSize: 'maxHeight' | 'maxWidth';\n    before: 'top' | 'left';\n    marginBefore: 'marginTop' | 'marginLeft';\n    after: 'bottom' | 'right';\n    marginAfter: 'marginBottom' | 'marginRight';\n    scrollOffset: 'pageYOffset' | 'pageXOffset';\n    offset: 'offsetY' | 'offsetY';\n    offsetOpt: 'yOffset' | 'xOffset';\n}\n\ntype Side = 'top' | 'bottom' | 'left' | 'right';\n\ntype Coordinates = {\n    top?: number;\n    bottom?: number;\n    left?: number;\n    right?: number;\n};\n\ntype Options = {\n    bound?: Element | Range | Coordinates;\n    xOffset?: number;\n    yOffset?: number;\n};\n\nfunction normalizeRect(rect: DOMRect | ClientRect): Coordinates {\n    return {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right,\n    };\n}\n\n// eslint-disable-next-line complexity\nexport default function (\n    elem: HTMLElement,\n    initialAnchor: Element | Range | Coordinates,\n    side: Side = 'bottom',\n    options: Options = {},\n) {\n    let anchor;\n\n    if (initialAnchor instanceof Element || initialAnchor instanceof Range) {\n        anchor = normalizeRect(elem.getBoundingClientRect());\n    } else {\n        anchor = initialAnchor;\n    }\n\n    const anchorRect = Object.assign(\n        {\n            top: anchor.bottom || 0,\n            bottom: anchor.top || 0,\n            left: anchor.right || 0,\n            right: anchor.left || 0,\n        },\n        anchor,\n    );\n\n    const boundRect = {\n        top: 0,\n        left: 0,\n        bottom: window.innerHeight,\n        right: window.innerWidth,\n    };\n\n    if (options.bound) {\n        if (options.bound instanceof Element || options.bound instanceof Range) {\n            options.bound = normalizeRect(options.bound.getBoundingClientRect());\n        }\n        Object.assign(boundRect, options.bound);\n    }\n\n    const elemStyle = getComputedStyle(elem);\n\n    const {primary, secondary} = Object.entries(NAMES).reduce(\n        (acc, [key, value]) => ({\n            primary: {...acc.primary, [key]: value[side === 'top' || side === 'bottom' ? 0 : 1]},\n            secondary: {...acc.secondary, [key]: value[side === 'top' || side === 'bottom' ? 1 : 0]},\n        }),\n        {primary: {}, secondary: {}},\n    ) as {\n        primary: Props;\n        secondary: Props;\n    };\n\n    elem.style.position = 'absolute';\n    elem.style.maxWidth = '';\n    elem.style.maxHeight = '';\n\n    const offset = options[primary.offsetOpt] || 0;\n\n    // Constrain the maximum size of the popup along the secondary axis.\n    const secondaryMarginBefore = parseInt(elemStyle[secondary.marginBefore], 10);\n    const secondaryMarginAfter = parseInt(elemStyle[secondary.marginAfter], 10);\n    const secondaryMargin = secondaryMarginBefore + secondaryMarginAfter;\n\n    const secondaryMaxSize = boundRect[secondary.after] - boundRect[secondary.before] - secondaryMargin;\n    const styledSecondaryMaxSize = parseInt(elemStyle[secondary.maxSize], 10);\n\n    if (!styledSecondaryMaxSize || secondaryMaxSize < styledSecondaryMaxSize) {\n        elem.style[secondary.maxSize] = px(secondaryMaxSize);\n    }\n\n    // Calculate the available room on either side of the anchor element. If\n    // the size of the popup is more than is available on the given side, then we\n    // will switch to the side with more room.\n    const margin = parseInt(elemStyle[primary.marginBefore], 10) + parseInt(elemStyle[primary.marginAfter], 10);\n    const roomBefore = anchorRect[primary.before] - boundRect[primary.before] - margin;\n    const roomAfter = boundRect[primary.after] - anchorRect[primary.after] - margin - offset;\n\n    if (\n        (side === primary.before && elem[primary.offsetSize] > roomBefore) ||\n        (side === primary.after && elem[primary.offsetSize] > roomAfter)\n    ) {\n        side = roomBefore > roomAfter ? primary.before : primary.after;\n    }\n\n    // If the size of the popup exceeds the room available on this side, then\n    // we will give the popup an explicit size so that it doesn't go off-screen.\n    const primaryMaxSize = side === primary.before ? roomBefore : roomAfter;\n    const styledPrimaryMaxSize = parseInt(elemStyle[primary.maxSize], 10);\n\n    if (!styledPrimaryMaxSize || primaryMaxSize < styledPrimaryMaxSize) {\n        elem.style[primary.maxSize] = px(primaryMaxSize);\n    }\n\n    // Set the position of the popup element along the primary axis using the\n    // anchor's bounding rect. If we are working in the context of position:\n    // absolute, then we will need to add the window's scroll position as well.\n    const scrollOffset = window[primary.scrollOffset] as unknown as number;\n\n    const boundPrimaryPos = (pos: number) => {\n        return Math.max(\n            boundRect[primary.before],\n            Math.min(pos, boundRect[primary.after] - elem[primary.offsetSize] - margin),\n        );\n    };\n\n    const boundSecondaryPos = (pos: number) => {\n        return Math.max(\n            boundRect[secondary.before],\n            Math.min(pos, boundRect[secondary.after] - elem[secondary.offsetSize] - secondaryMargin),\n        );\n    };\n\n    if (side === primary.before) {\n        // top or left\n        elem.style[primary.before] =\n            scrollOffset +\n            boundPrimaryPos(anchorRect[primary.before] - elem[primary.offsetSize] - margin) -\n            offset +\n            'px';\n        elem.style[primary.after] = 'auto';\n    } else {\n        // bottom or right\n        elem.style[primary.before] = px(scrollOffset + boundPrimaryPos(anchorRect[primary.after]) + offset);\n        elem.style[primary.after] = 'auto';\n    }\n\n    // Set the position of the popup element along the secondary axis.\n    const secondaryScrollOffset = window[secondary.scrollOffset] as unknown as number;\n\n    elem.style[secondary.before] = px(\n        secondaryScrollOffset + boundSecondaryPos(anchorRect[secondary.before] - secondaryMarginBefore),\n    );\n    elem.style[secondary.after] = 'auto';\n\n    elem.dataset.side = side;\n\n    return {\n        side,\n        anchorRect,\n        boundRect,\n    };\n}\n", "export function getOptionValue<T>(option: T | {[key in string]: T}, scale: string): T {\n    return (typeof option === 'object' ? (option as {[key in string]: T})[scale] : option) as T;\n}\n\nexport function escapeHTML(html: string) {\n    const elem = document.createElement('span');\n\n    elem.innerText = html;\n    return elem.innerHTML;\n}\n", "/* eslint-disable complexity, no-nested-ternary */\nimport {TooltipRenderOptions, TooltipRow} from './types';\nimport {getOptionValue, escapeHTML} from './utils';\n\nfunction renderItems(rows: TooltipRow[], opts: TooltipRenderOptions['options'], scale: string) {\n    const rowsMax = rows.slice(0, getOptionValue(opts.maxLines, scale));\n\n    return (\n        rowsMax\n            .map(({value, name = 'unnamed', color, active, transformed, seriesIdx}, i) => {\n                const val = `\n<span class=\"yagr-tooltip__val\">${value}</span>\n    ${typeof transformed === 'number' ? `<span class=\"yagr-tooltip__tf\">${transformed.toFixed(2)}</span>` : ''}\n`;\n                return `\n<div class=\"yagr-tooltip__item ${active ? '_active' : ''}\" data-series=\"${seriesIdx}\">\n    ${opts.showIndicies ? `<span class=\"yagr-tooltip__idx\">${rows.length - i}</span>` : ''}\n    <span class=\"yagr-tooltip__mark\" style=\"background-color: ${color}\"></span>${escapeHTML(name)}&nbsp;&nbsp;${val}\n</div>`;\n            })\n            .join('') +\n        (rows.length > rowsMax.length\n            ? `<div class=\"yagr-tooltip__item _more\">+${rows.length - rowsMax.length}</div>`\n            : '')\n    );\n}\n\nexport function renderTooltip(data: TooltipRenderOptions) {\n    if (data.scales.length === 0) {\n        return data.yagr.utils.i18n('nodata');\n    }\n\n    const [allTitle, sectionTitle] = data.options.title\n        ? typeof data.options.title === 'string'\n            ? [data.options.title, false]\n            : ['', true]\n        : ['', false];\n\n    const sections = data.scales.map((x) => {\n        const sectionTitleBody = getOptionValue(data.options.title, x.scale);\n        const scaleBody =\n            data.scales.length > 1\n                ? data.options.scales\n                    ? `${getOptionValue(data.options.scales, x.scale) || ''}`\n                    : `${data.yagr.utils.i18n('scale')}: ${x.scale}`\n                : '';\n        return `\n<div class=\"__section\" data-scale=${x.scale}>\n    ${sectionTitle && sectionTitleBody ? `<div class=\"_section_title\">${sectionTitleBody}</div>` : ''}\n    ${scaleBody ? `<div class=\"__section_scale\">${scaleBody}</div>` : ''}\n    <div class=\"__section_body\">${renderItems(x.rows, data.options, x.scale)}</div>\n    ${\n        getOptionValue(data.options.sum, x.scale)\n            ? `\n        <div class=\"__section_sum\">\n            ${data.yagr.utils.i18n('sum')}: ${x.sum}\n        </div>\n    `\n            : ''\n    }\n</div>`;\n    });\n\n    return `${allTitle ? `<div class=\"__title\">${allTitle}</div>` : ''}${sections.join('')}`;\n}\n", "/* eslint-disable complexity, no-nested-ternary */\n\nimport uPlot, {Series} from 'uplot';\n\nimport {CursorOptions} from '../cursor/cursor';\nimport placementFn from './placement';\n\nimport Yagr from '../../index';\nimport {DataSeries, ProcessingInterpolation, YagrPlugin} from '../../types';\n\nimport {TOOLTIP_Y_OFFSET, TOOLTIP_X_OFFSET, TOOLTIP_DEFAULT_MAX_LINES, DEFAULT_Y_SCALE} from '../../defaults';\n\nimport {findInRange, findDataIdx, findSticky, px, isNil, inBetween} from '../../utils/common';\nimport {\n    TooltipOptions,\n    TooltipRow,\n    TrackingOptions,\n    ValueFormatter,\n    TooltipSection,\n    TooltipHandler,\n    TooltipData,\n    TooltipState,\n    TooltipAction,\n    SelectionRange,\n} from './types';\n\nimport {renderTooltip} from './render';\nimport {getOptionValue} from './utils';\n\n// eslint-disable-next-line complexity\nconst findValue = (\n    cursor: CursorOptions,\n    data: DataSeries,\n    serie: Series,\n    idx: number,\n    interpolation?: ProcessingInterpolation,\n) => {\n    const source = Array.isArray(serie.$c) ? serie.$c : data;\n    let value = source[idx];\n\n    if (interpolation && value === interpolation.value) {\n        const snapTo = interpolation.snapToValues ?? 'closest';\n        const nonNullIdx = findDataIdx(source, serie, idx, snapTo, interpolation.value);\n        value = source[nonNullIdx];\n    } else if (value === null) {\n        const cursorSnapToValues = cursor.snapToValues ?? 'closest';\n        const snapTo = serie.snapToValues ?? cursorSnapToValues;\n        const nonNullIdx = findDataIdx(source, serie, idx, snapTo, null);\n        value = source[nonNullIdx];\n    }\n\n    return value;\n};\n\nconst DEFAULT_TOOLTIP_OPTIONS = {\n    maxLines: TOOLTIP_DEFAULT_MAX_LINES,\n    highlight: true,\n    sum: false,\n    render: renderTooltip,\n    pinable: true,\n    strategy: 'pin',\n    sort: undefined,\n    showIndicies: false,\n    hideNoData: false,\n    className: 'yagr-tooltip_default',\n    xOffset: TOOLTIP_X_OFFSET,\n    yOffset: TOOLTIP_Y_OFFSET,\n    virtual: false,\n    showEmpty: false,\n    onUpdate: 'reset',\n} as const;\n\nexport type TooltipPlugin = YagrPlugin<\n    {\n        state: TooltipState;\n        pin(pinState: boolean, position?: {x: number; y: number}): void;\n        show(): void;\n        hide(): void;\n        updateOptions: (o: Partial<TooltipOptions>) => void;\n        on: (event: TooltipAction, handler: TooltipHandler) => void;\n        off: (event: TooltipAction, handler: TooltipHandler) => void;\n        display: (props: {left: number; top: number; idx: number}) => void;\n        tooltip: YagrTooltip;\n        dispose: () => void;\n        reInit: (u: uPlot) => void;\n        reset: () => void;\n    },\n    [Partial<TooltipOptions>]\n>;\n\nclass YagrTooltip {\n    handlers: Record<TooltipAction, TooltipHandler[]> = {\n        init: [],\n        mount: [],\n        show: [],\n        pin: [],\n        unpin: [],\n        hide: [],\n        render: [],\n        destroy: [],\n        reset: [],\n    };\n\n    private placement: Function = placementFn;\n    private renderTooltipCloses = () => {};\n\n    private tOverlay: HTMLDivElement;\n    private bound: HTMLElement;\n    private renderNode: HTMLElement;\n    /**\n     * Flag to skip next mouseup event, used for unpinning\n     * tooltip on any mousedown, but continiously pinning on drag\n     */\n    private skipNextMouseUp = false;\n\n    yagr: Yagr;\n    opts: TooltipOptions;\n    state: TooltipState;\n    over: HTMLDivElement;\n\n    private bLeft: number;\n    private bTop: number;\n    private bWidth: number;\n\n    constructor(yagr: Yagr, options: Partial<TooltipOptions> = {}) {\n        this.yagr = yagr;\n        this.over = yagr?.uplot?.over;\n        this.opts = {\n            ...DEFAULT_TOOLTIP_OPTIONS,\n            strategy: options.pinable ? 'pin' : DEFAULT_TOOLTIP_OPTIONS.strategy,\n            tracking: yagr.config.chart.series?.type === 'area' ? 'area' : 'sticky',\n            value: this.defaultTooltipValueFormatter,\n            ...options,\n        };\n\n        this.bound = this.opts.boundClassName\n            ? document.querySelector(this.opts.boundClassName) || document.body\n            : document.body;\n        this.renderNode = this.opts.renderClassName\n            ? document.querySelector(this.opts.renderClassName) || document.body\n            : document.body;\n        this.tOverlay = document.createElement('div');\n\n        this.tOverlay.id = `${yagr.id}_tooltip`;\n        this.tOverlay.className = `yagr-tooltip ${this.opts.className || ''}`;\n        this.tOverlay.style.display = 'none';\n\n        this.state = {\n            mounted: false,\n            pinned: false,\n            visible: false,\n            range: null,\n            focusedSeries: null,\n        };\n\n        this.bLeft = 0;\n        this.bTop = 0;\n        this.bWidth = 0;\n\n        if (this.opts.virtual) {\n            this.placement = () => {};\n        } else {\n            this.renderNode.appendChild(this.tOverlay);\n            this.state.mounted = true;\n            this.emit('mount');\n        }\n    }\n\n    emit = (action: TooltipAction, data?: TooltipData) => {\n        this.handlers[action].forEach((handler) => {\n            handler(this.tOverlay, {\n                state: this.state,\n                actions: {\n                    pin: this.pin,\n                    show: this.show,\n                    hide: this.hide,\n                    dispose: this.dispose,\n                    reset: this.reset,\n                },\n                data,\n                yagr: this.yagr,\n                event: action,\n            });\n        });\n    };\n\n    reset = () => {\n        if (this.opts.onUpdate === 'none') {\n            this.yagr.plugins.cursor?.pin(false);\n            return;\n        }\n\n        if (this.state.visible) {\n            this.hide();\n        }\n\n        if (this.state.pinned) {\n            this.pin(false);\n        }\n        this.emit('reset');\n    };\n\n    show = () => {\n        const shouldEmit = !this.state.visible;\n        this.state.visible = true;\n        this.tOverlay.style.display = 'block';\n        shouldEmit && this.emit('show');\n    };\n\n    hide = () => {\n        const shouldEmit = this.state.visible;\n        this.state.visible = false;\n        this.tOverlay.style.display = 'none';\n        this.emit('hide');\n        shouldEmit && this.emit('show');\n    };\n\n    pin = (pinState: boolean, position?: {x: number; y: number}) => {\n        this.state.pinned = pinState;\n        const range = this.state.range || [];\n\n        this.yagr.plugins.cursor?.pin(pinState && (range[1] === null || range.length < 2));\n\n        if (this.opts.virtual) {\n            return this.emit(pinState ? 'pin' : 'unpin');\n        }\n\n        if (position) {\n            this.placement(\n                this.tOverlay,\n                {\n                    left: position.x + this.bLeft,\n                    top: this.bTop + position.y - (this.opts.yOffset || 0),\n                },\n                'right',\n                {\n                    bound: this.bound,\n                    xOffset: this.opts.xOffset,\n                    yOffset: this.opts.yOffset,\n                },\n            );\n        }\n\n        const list = this.tOverlay.querySelector('._tooltip-list') as HTMLElement;\n\n        if (pinState) {\n            if (!this.state.visible) {\n                this.show();\n            }\n\n            this.tOverlay.classList.add('yagr-tooltip_pinned');\n            if (list && list?.clientHeight) {\n                list.style.height = px(list.clientHeight);\n            }\n\n            if (this.opts.render === renderTooltip) {\n                document.addEventListener('mousemove', this.checkFocus);\n                document.addEventListener('mousedown', this.detectClickOutside);\n            }\n        } else {\n            this.tOverlay.classList.remove('yagr-tooltip_pinned');\n\n            if (this.opts.render === renderTooltip) {\n                document.removeEventListener('mousemove', this.checkFocus);\n                document.removeEventListener('mousedown', this.detectClickOutside);\n            }\n        }\n\n        this.emit(pinState ? 'pin' : 'unpin');\n    };\n\n    checkFocus = (event: MouseEvent) => {\n        const target = event.target as HTMLElement | null;\n        let serieIdx: string | undefined;\n\n        if (target && this.tOverlay.contains(target) && target.classList.contains('yagr-tooltip__item')) {\n            serieIdx = target.dataset['series'];\n        }\n\n        const serie = serieIdx ? this.yagr.uplot.series[Number(serieIdx)] : null;\n\n        if (serieIdx && serie) {\n            this.state.focusedSeries = serieIdx;\n            this.yagr.setFocus(serie.id, true);\n        } else if (this.state.focusedSeries) {\n            this.state.focusedSeries = null;\n            this.yagr.setFocus(null, true);\n        }\n    };\n\n    render = (props: {left: number; top: number; idx: number}) => {\n        const u = this.yagr.uplot;\n        let {left, top} = props;\n        const {idx} = props;\n        const {opts, state} = this;\n\n        if (opts.show && typeof opts.show === 'function' && opts.show(this.yagr) === false) {\n            this.hide();\n            return;\n        }\n\n        if ((left < 0 || top < 0) && !state.pinned && this.isNotInDrag) {\n            this.hide();\n        }\n\n        top = inBetween(top, 0, u.bbox.top + u.bbox.height);\n        left = inBetween(left, 0, u.bbox.left + u.bbox.width);\n\n        const {data} = u;\n\n        if (data === null || isNil(idx) || top === undefined) {\n            return;\n        }\n\n        const x = data[0][idx];\n\n        const sum: Record<string, number> = {};\n        const sections: Record<string, TooltipSection> = {};\n\n        const rowsBySections: Record<string, number[]> = {};\n\n        let i = u.series.length - 1;\n        while (i >= 1) {\n            const serie = u.series[i];\n\n            if (!serie.show) {\n                i -= 1;\n                continue;\n            }\n\n            const scale = serie.scale || DEFAULT_Y_SCALE;\n\n            rowsBySections[scale] = rowsBySections[scale] || [];\n            rowsBySections[scale].push(i);\n            i -= 1;\n        }\n\n        const rowEntries = Object.entries(rowsBySections);\n\n        rowEntries.forEach(([scale, serieIndicies]) => {\n            sections[scale] = sections[scale] || {\n                rows: [],\n            };\n            const section = sections[scale];\n            const cursorValue = Number(u.posToVal(top, scale).toFixed(2));\n\n            const valueRender = getOptionValue<ValueFormatter>(opts.value, scale);\n\n            for (const seriesIdx of serieIndicies) {\n                const seriesData = u.data[seriesIdx] as DataSeries;\n                const serie = u.series[seriesIdx];\n\n                let value = findValue(this.yagr.config.cursor, seriesData, serie, idx, this.interpolation);\n                let dValue = value;\n\n                if (typeof value === 'string') {\n                    dValue = value;\n                    value = null;\n                }\n\n                if (getOptionValue(opts.sum, scale)) {\n                    sum[scale] = sum[scale] || 0;\n                    sum[scale] += value || 0;\n                }\n\n                const realY = seriesData[idx];\n                const yValue = serie.$c && serie.$c[idx] === this.stripValue ? value : realY;\n\n                if ((value === null && opts.hideNoData) || serie.showInTooltip === false) {\n                    continue;\n                }\n\n                const seriesPrecision = serie.precision ?? getOptionValue(opts.precision, scale);\n\n                const displayValue = serie.formatter\n                    ? serie.formatter(dValue, serie)\n                    : valueRender(dValue, seriesPrecision);\n\n                const rowData: TooltipRow = {\n                    id: serie.id,\n                    name: serie.name,\n                    dataValue: serie.$c[idx],\n                    originalValue: value,\n                    value: displayValue,\n                    y: yValue,\n                    displayY: realY,\n                    color: serie.color,\n                    seriesIdx,\n                    rowIdx: section.rows.length ? section.rows[section.rows.length - 1].rowIdx + 1 : 0,\n                };\n\n                if (serie.normalizedData) {\n                    rowData.transformed = serie.normalizedData[idx];\n                }\n\n                if (serie._transformed) {\n                    rowData.transformed = seriesData[idx];\n                }\n\n                if (opts.omitBy && opts.omitBy(rowData)) {\n                    continue;\n                }\n\n                section.rows.push(rowData);\n            }\n\n            if (getOptionValue(opts.highlight, scale) && section.rows.length) {\n                const tracking = getOptionValue<TrackingOptions>(opts.tracking, scale);\n                let activeIndex: number | null = 0;\n                if (tracking === 'area') {\n                    activeIndex = findInRange(\n                        section,\n                        cursorValue,\n                        getOptionValue<boolean | undefined>(opts.stickToRanges, scale),\n                    );\n                } else if (tracking === 'sticky') {\n                    activeIndex = findSticky(section, cursorValue);\n                } else if (typeof tracking === 'function') {\n                    activeIndex = tracking(section, cursorValue, {\n                        x: u.posToVal(left, 'x'),\n                        y: u.posToVal(top, scale),\n                        idx,\n                        scale,\n                        series: this.yagr.series,\n                        serieIndicies,\n                        interpolation: this.interpolation,\n                    });\n                }\n\n                if (activeIndex !== null) {\n                    section.rows[activeIndex].active = true;\n                }\n            }\n\n            const sort = getOptionValue(opts.sort, scale);\n            if (sort) {\n                section.rows.sort(sort);\n            }\n        });\n\n        const hasOneRow = Object.values(sections).some(({rows}) => rows.length > 0);\n\n        if (hasOneRow || opts.showEmpty) {\n            this.onMouseEnter();\n        } else {\n            this.hide();\n            return;\n        }\n\n        const bbox = this.over.getBoundingClientRect();\n\n        this.bLeft = bbox.left;\n        this.bTop = bbox.top;\n        this.bWidth = bbox.width;\n\n        const anchor = {\n            left: left + this.bLeft,\n            top: this.bTop + top - (opts.yOffset || 0),\n        };\n\n        this.renderTooltipCloses = () => {\n            const renderData = {\n                scales: Object.entries(sections).map(([scale, sec]) => {\n                    return {\n                        scale,\n                        rows: sec.rows,\n                        sum: sum[scale],\n                    };\n                }),\n                options: opts,\n                x,\n            };\n\n            const hasDataNow = Object.values(sections).some(\n                ({rows}) => rows.filter(({id}) => this.yagr.getSeriesById(id)?.show).length > 0,\n            );\n\n            if (!hasDataNow && !opts.showEmpty) {\n                this.hide();\n                return;\n            }\n\n            if (!opts.virtual) {\n                this.tOverlay.innerHTML = opts.render({\n                    ...renderData,\n                    state,\n                    yagr: this.yagr,\n                    defaultRender: DEFAULT_TOOLTIP_OPTIONS.render,\n                });\n\n                this.placement(this.tOverlay, anchor, 'right', {\n                    bound: this.bound,\n                    xOffset: opts.xOffset,\n                    yOffset: opts.yOffset,\n                });\n            }\n\n            this.emit('render', {...renderData, anchor});\n        };\n\n        if (state.pinned) {\n            return;\n        }\n\n        this.renderTooltipCloses();\n    };\n\n    initWithUplot = (u: uPlot) => {\n        this.over = u.root.querySelector('.u-over') as HTMLDivElement;\n\n        this.over.addEventListener('mousedown', this.onMouseDown);\n        this.over.addEventListener('mousemove', this.onMouseMove);\n        this.over.addEventListener('mouseenter', this.onMouseEnter);\n        this.over.addEventListener('mouseleave', this.onMouseLeave);\n\n        document.addEventListener('mouseup', this.onMouseUp);\n    };\n\n    setSize = () => {\n        const bbox = this.over.getBoundingClientRect();\n\n        this.bLeft = bbox.left;\n        this.bTop = bbox.top;\n    };\n\n    dispose = () => {\n        /** Free overlay listeners */\n        this.over.removeEventListener('mousedown', this.onMouseDown);\n        this.over.removeEventListener('mousemove', this.onMouseMove);\n        this.over.removeEventListener('mouseenter', this.onMouseEnter);\n        this.over.removeEventListener('mouseleave', this.onMouseLeave);\n\n        document.removeEventListener('mouseup', this.onMouseUp);\n        document.removeEventListener('mousemove', this.checkFocus);\n        document.removeEventListener('mousedown', this.detectClickOutside);\n\n        /** Removing tooltip on destroy */\n        this.tOverlay.remove();\n        this.state.mounted = false;\n        this.emit('destroy');\n    };\n\n    updateOptions = (newOptions: Partial<TooltipOptions>) => {\n        Object.assign(this.opts, newOptions);\n        this.tOverlay.className = `yagr-tooltip ${this.opts.className || ''}`;\n    };\n\n    on = (event: TooltipAction, handler: TooltipHandler) => {\n        this.handlers[event].push(handler);\n    };\n\n    off = (event: TooltipAction, handler: TooltipHandler) => {\n        this.handlers[event] = this.handlers[event].filter((h) => h !== handler);\n    };\n\n    private detectClickOutside = (event: MouseEvent) => {\n        const target = event.target;\n\n        if (target instanceof Element) {\n            const isClickInsideTooltip = target && this.tOverlay.contains(target);\n            const isClickOnUplotOver = target && this.over.contains(target);\n\n            if (!isClickInsideTooltip && !isClickOnUplotOver) {\n                this.pin(false);\n                this.hide();\n            }\n        }\n    };\n\n    private onMouseDown = (evt: MouseEvent) => {\n        this.state.range = [this.getCursorPosition(), null];\n\n        if (this.state.pinned) {\n            this.pin(false);\n            this.hide();\n            this.render({\n                left: evt.clientX - this.bLeft,\n                top: evt.clientY - this.bTop,\n                idx: this.yagr.uplot.posToIdx(evt.clientX - this.bLeft),\n            });\n            this.skipNextMouseUp = true;\n        }\n    };\n\n    private onMouseMove = () => {\n        if (this.state.range?.length) {\n            this.state.range[1] = this.getCursorPosition();\n        }\n    };\n\n    /**\n     * Calculates where exactly cursor leaved the chart\n     * and sets range[1] to this position\n     */\n    private setCursorLeaved = (e: MouseEvent) => {\n        const rect = this.over.getBoundingClientRect();\n        const x = e.clientX;\n        const range = this.state.range!;\n        const startPoint = range[0]!;\n        const xInOver = x - rect.left;\n        const end = xInOver > startPoint.clientX;\n        const timeline = this.yagr.config.timeline;\n\n        let result;\n        if (end) {\n            range[1] = {\n                clientX: this.bWidth,\n                value: this.yagr.uplot.posToVal(this.bWidth, 'x'),\n                idx: timeline.length - 1,\n            };\n            result = range[1];\n        } else {\n            /** Swap range[1] and range[0] in case if tooltip leaved chart in begining of element */\n            range[1] = range[0];\n            range[0] = {\n                clientX: 0,\n                value: this.yagr.uplot.posToVal(0, 'x'),\n                idx: 0,\n            };\n\n            result = range[0];\n        }\n\n        this.yagr.uplot.setCursor({\n            left: result.clientX,\n            top: e.clientY - rect.top,\n        });\n    };\n\n    private onMouseUp = (e: MouseEvent) => {\n        if (this.state.range === null) {\n            return;\n        }\n\n        const [from] = this.state.range || [];\n        let cursor: SelectionRange[number];\n\n        if (e.target === this.over) {\n            cursor = this.getCursorPosition();\n        } else {\n            cursor = this.state.range[1];\n        }\n\n        if (this.opts.strategy === 'none') {\n            return;\n        }\n\n        const click = from && from.clientX === cursor?.clientX;\n        const drag = from && from.clientX !== cursor?.clientX;\n\n        const strategy = this.opts.strategy;\n\n        if (\n            (click && !this.skipNextMouseUp && strategy !== 'drag') ||\n            (drag && (strategy === 'all' || strategy === 'drag'))\n        ) {\n            this.pin(!this.state.pinned);\n            this.show();\n            this.renderTooltipCloses();\n        }\n\n        this.state.range = null;\n        this.skipNextMouseUp = false;\n    };\n\n    private onMouseEnter = () => {\n        this.show();\n    };\n\n    private onMouseLeave = (e: MouseEvent) => {\n        const isPinned = this.state.pinned;\n\n        if (this.state.range?.[0]) {\n            this.setCursorLeaved(e);\n        }\n\n        if (!isPinned && this.isNotInDrag) {\n            this.hide();\n        }\n    };\n\n    private defaultTooltipValueFormatter = (n: string | number | null, precision?: number) => {\n        const pSettings = this.yagr.config.processing || {};\n\n        if (typeof n === 'string') {\n            if (pSettings.nullValues && pSettings.nullValues.hasOwnProperty(n)) {\n                return pSettings.nullValues[n] as string;\n            }\n\n            return '-';\n        }\n\n        if (typeof n === 'number') {\n            return n.toFixed(\n                // eslint-disable-next-line no-nested-ternary\n                typeof precision === 'number'\n                    ? precision\n                    : typeof this.opts.precision === 'number'\n                    ? this.opts.precision\n                    : 2,\n            );\n        }\n\n        return '-';\n    };\n\n    private getCursorPosition = (): SelectionRange[number] => {\n        const x = this.yagr.uplot.cursor.left;\n\n        if (x === undefined) {\n            return null;\n        }\n\n        return {\n            clientX: x,\n            value: this.yagr.uplot.posToVal(x, 'x'),\n            idx: this.yagr.uplot.posToIdx(x),\n        };\n    };\n\n    get interpolation() {\n        return this.yagr.config.processing?.interpolation;\n    }\n    get stripValue() {\n        return this.interpolation ? this.interpolation.value : undefined;\n    }\n    get isNotInDrag() {\n        if (this.opts.strategy === 'none' || this.opts.strategy === 'pin') {\n            return true;\n        }\n\n        return !this.state.range?.[1];\n    }\n}\n\n/*\n * Tooltip plugin constructor.\n * Every charts has it's own tooltip plugin instance\n */\nfunction YagrTooltipPlugin(yagr: Yagr, options: Partial<TooltipOptions> = {}): ReturnType<TooltipPlugin> {\n    const tooltip = new YagrTooltip(yagr, options);\n\n    const getUplotPlugin = () => ({\n        hooks: {\n            init: (u: uPlot) => {\n                tooltip.initWithUplot(u);\n            },\n            setSize: () => {\n                tooltip.setSize();\n            },\n\n            setCursor: (u: uPlot) => {\n                tooltip.render(u.cursor as Parameters<typeof tooltip.render>[0]);\n            },\n        },\n    });\n\n    const uPlotPlugin = getUplotPlugin();\n\n    function reInit(u: uPlot) {\n        const uPlugin = getUplotPlugin();\n\n        tooltip.reset();\n\n        u.hooks.init!.push(uPlugin.hooks.init);\n        u.hooks.setSize!.push(uPlugin.hooks.setSize);\n        u.hooks.setCursor!.push(uPlugin.hooks.setCursor);\n    }\n\n    return {\n        state: tooltip.state,\n        pin: tooltip.pin,\n        show: tooltip.show,\n        hide: tooltip.hide,\n        uplot: uPlotPlugin,\n        display: tooltip.render,\n        updateOptions: tooltip.updateOptions,\n        on: tooltip.on,\n        off: tooltip.off,\n        tooltip,\n        dispose: tooltip.dispose,\n        reInit,\n        reset: tooltip.reset,\n    };\n}\n\nexport default YagrTooltipPlugin;\n", "import type Yagr from '../../index';\nimport UPlot, {Plugin, Series} from 'uplot';\n\nimport {DEFAULT_X_SCALE, DEFAULT_Y_SCALE, DEFAULT_POINT_SIZE} from '../../defaults';\nimport {DotsSeriesOptions, YagrConfig} from '../../types';\nimport { isNil } from '../..//utils/common';\n\nexport const renderCircle = (\n    u: UPlot,\n    x: number,\n    y: number,\n    r: number,\n    s: number,\n    color: string,\n    strokeColor: string,\n    yScale?: string,\n) => {\n    const {ctx} = u;\n    const cx = Math.round(u.valToPos(x, DEFAULT_X_SCALE, true));\n    const cy = Math.round(u.valToPos(y, yScale || DEFAULT_Y_SCALE, true));\n\n    ctx.beginPath();\n    ctx.arc(cx, cy, r * 2, 0, 2 * Math.PI);\n\n    ctx.fillStyle = color;\n\n    if (s) {\n        const lineWidth = ctx.lineWidth;\n        const strokeStyle = ctx.strokeStyle;\n        ctx.lineWidth = s;\n        ctx.strokeStyle = strokeColor;\n        ctx.stroke();\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = strokeStyle;\n    }\n\n    ctx.fill();\n    ctx.closePath();\n};\n\nexport function drawMarkersIfRequired(u: UPlot, i: number, i0: number, i1: number) {\n    const {color, scale, spanGaps, count, pointsSize} = u.series[i];\n\n    if (spanGaps && count > 1) {\n        return false;\n    }\n\n    let j = i0;\n    let prev;\n\n    while (j <= i1) {\n        const val = u.data[i][j];\n\n        if (val === null) {\n            prev = val;\n            j++;\n            continue;\n        }\n\n        const nextIdx = j + 1;\n        const next = u.data[i][nextIdx];\n\n        if (isNil(prev) && isNil(next)) {\n            renderCircle(\n                u,\n                u.data[0][j] as number,\n                val as number,\n                pointsSize ?? (DEFAULT_POINT_SIZE / 2),\n                0,\n                color,\n                color,\n                scale || DEFAULT_Y_SCALE,\n            );\n        }\n        prev = val;\n        j++;\n    }\n\n    return undefined;\n}\n\n/*\n * This plugin configures points markers\n */\nexport default function YagrMarkersPlugin(yagr: Yagr, config: YagrConfig): Plugin {\n    const {size = DEFAULT_POINT_SIZE, strokeWidth = 2, strokeColor = '#ffffff', show} = config.markers;\n\n    const chartSeriesOptions = config.chart?.series as DotsSeriesOptions;\n    const defaultDotsSize = chartSeriesOptions?.pointsSize || DEFAULT_POINT_SIZE;\n\n    function drawCircles(u: UPlot, i: number, i0: number, i1: number) {\n        const {scale, _focus, color, getFocusedColor, type} = u.series[i];\n\n        let j = i0;\n\n        // eslint-disable-next-line no-nested-ternary\n        const pointSize = type === 'dots' ? (show ? size : defaultDotsSize) : size;\n\n        while (j <= i1) {\n            const val = u.data[i][j];\n            if (val !== null) {\n                renderCircle(\n                    u,\n                    u.data[0][j] as number,\n                    val as number,\n                    pointSize,\n                    strokeWidth,\n                    (_focus || _focus === null ? color : getFocusedColor(yagr, i)) || color,\n                    strokeColor,\n                    scale || DEFAULT_Y_SCALE,\n                );\n            }\n            j++;\n        }\n\n        return undefined;\n    }\n\n    const markSeries = (idx: number | null, s: Series) => {\n        if (idx === 0 || idx === null) {\n            return;\n        }\n\n        if (s.type === 'dots' || config.markers.show) {\n            s.points = s.points || {};\n            s.points.show = drawCircles;\n        }\n    };\n\n    return {\n        opts: (_, opts) => {\n            if (!(config.markers.show || opts.series.some((s) => s.type === 'dots'))) {\n                return;\n            }\n            opts.series.forEach((s, i) => markSeries(i, s));\n        },\n\n        hooks: {\n            addSeries: (uplot, seriesIdx) => {\n                const series = uplot.series[seriesIdx];\n                markSeries(seriesIdx, series);\n            },\n            setSeries: (_, idx, series) => {\n                markSeries(idx, series);\n            },\n        },\n    };\n}\n", "import UPlot from 'uplot';\nimport * as defaults from '../defaults';\n\n/*\n * Configures and return apropriate path renderer\n * by given serieIndex and two points\n */\nexport function pathsRenderer(u: UPlot, seriesIdx: number, idx0: number, idx1: number) {\n    const serie = u.series[seriesIdx];\n    const {type, interpolation} = serie;\n\n    let drawer;\n\n    switch (type) {\n        case 'column': {\n            drawer =\n                UPlot.paths.bars &&\n                UPlot.paths.bars({\n                    size: [defaults.BARS_DRAW_FACTOR, defaults.BARS_DRAW_MAX],\n                    ...(u.series[seriesIdx].renderOptions || {}),\n                });\n            break;\n        }\n        case 'dots': {\n            drawer = () => null;\n            break;\n        }\n        case 'line':\n        case 'area':\n        default: {\n            switch (interpolation) {\n                case 'smooth':\n                    drawer = UPlot.paths.spline && UPlot.paths.spline();\n                    break;\n                case 'left':\n                    drawer = UPlot.paths.stepped && UPlot.paths.stepped({align: 1});\n                    break;\n                case 'right': {\n                    drawer = UPlot.paths.stepped && UPlot.paths.stepped({align: -1});\n                    break;\n                }\n                case 'linear':\n                default:\n                    drawer = UPlot.paths.linear && UPlot.paths.linear();\n                    break;\n            }\n        }\n    }\n\n    return drawer ? drawer(u, seriesIdx, idx0, idx1) : null;\n}\n", "import {Series} from 'uplot';\n\nimport * as defaults from '../defaults';\nimport type Yagr from '..';\n\nimport {\n    AreaSeriesOptions,\n    ColumnSeriesOptions,\n    DotsSeriesOptions,\n    LineSeriesOptions,\n    RawSerieData,\n    SeriesOptions,\n} from '../types';\nimport {genId} from './common';\nimport {getFocusedColor, getSerieFocusColors} from './colors';\nimport {drawMarkersIfRequired} from '../plugins/markers';\nimport {pathsRenderer} from './paths';\n\nfunction getCommonProperty<T extends SeriesOptions, K extends keyof T>(\n    series: RawSerieData | Series,\n    yagr: Yagr,\n    key: K,\n    defaultValue?: T[K],\n): T[K] | undefined {\n    if (series[key as keyof typeof series] !== undefined) {\n        return series[key as keyof typeof series] as T[K];\n    }\n\n    const seriesOptions = yagr.config.chart.series;\n    if (seriesOptions && key in seriesOptions) {\n        return seriesOptions[key as keyof SeriesOptions] as T[K];\n    }\n\n    return defaultValue;\n}\n\n// eslint-disable-next-line complexity\nexport function configureSeries(yagr: Yagr, rawSeries: RawSerieData, idx: number): Series {\n    const type = getCommonProperty(rawSeries, yagr, 'type', 'line');\n\n    const serie: Series = {\n        ...rawSeries,\n        type,\n        show: rawSeries.show ?? true,\n        name: rawSeries.name || `${yagr.utils.i18n('series')} ${idx + 1}`,\n        color: rawSeries.color ? yagr.utils.colors.parse(rawSeries.color) : yagr.utils.theme.DEFAULT_LINE_COLOR,\n        id: (rawSeries.id === undefined ? rawSeries.name : String(rawSeries.id)) || genId(),\n        $c: rawSeries.data,\n        scale: rawSeries.scale || defaults.DEFAULT_Y_SCALE,\n        count: 0,\n        sum: 0,\n        avg: 0,\n        getFocusedColor,\n    };\n\n    serie.points = serie.points || {};\n\n    const colorFn = getSerieFocusColors(yagr, 'color');\n\n    if (serie.type === 'area') {\n        serie.lineColor = yagr.utils.colors.parse(\n            getCommonProperty<AreaSeriesOptions, 'lineColor'>(\n                rawSeries,\n                yagr,\n                'lineColor',\n                defaults.SERIE_AREA_BORDER_COLOR,\n            ),\n        );\n        serie.lineWidth = getCommonProperty<AreaSeriesOptions, 'lineWidth'>(\n            rawSeries,\n            yagr,\n            'lineWidth',\n            defaults.SERIE_AREA_BORDER_WIDTH,\n        );\n\n        serie.fill = colorFn;\n        serie.stroke = getSerieFocusColors(yagr, 'lineColor');\n        serie.width = serie.lineWidth;\n        serie.points.show = drawMarkersIfRequired;\n        serie.interpolation = getCommonProperty<AreaSeriesOptions, 'interpolation'>(\n            rawSeries,\n            yagr,\n            'interpolation',\n            'linear',\n        );\n        serie.spanGaps = getCommonProperty<AreaSeriesOptions, 'spanGaps'>(rawSeries, yagr, 'spanGaps', false);\n    }\n\n    if (serie.type === 'line') {\n        serie.width = getCommonProperty<LineSeriesOptions, 'width'>(\n            rawSeries,\n            yagr,\n            'width',\n            defaults.SERIE_LINE_WIDTH,\n        );\n        serie.width = serie.width || defaults.SERIE_LINE_WIDTH;\n        serie.stroke = colorFn;\n        serie.points.show = drawMarkersIfRequired;\n        serie.interpolation = getCommonProperty<LineSeriesOptions, 'interpolation'>(\n            rawSeries,\n            yagr,\n            'interpolation',\n            'linear',\n        );\n        serie.spanGaps = getCommonProperty<LineSeriesOptions, 'spanGaps'>(rawSeries, yagr, 'spanGaps', false);\n    }\n\n    if (serie.type === 'column') {\n        serie.stroke = colorFn;\n        serie.fill = colorFn;\n        serie.points.show = false;\n        serie.width = serie.width ?? 0;\n        serie.renderOptions = getCommonProperty<ColumnSeriesOptions, 'renderOptions'>(serie, yagr, 'renderOptions');\n    }\n\n    if (serie.type === 'dots') {\n        serie.stroke = () => serie.color;\n        serie.fill = colorFn;\n        serie.width = 2;\n        serie.pointsSize = getCommonProperty<DotsSeriesOptions, 'pointsSize'>(\n            serie,\n            yagr,\n            'pointsSize',\n            defaults.DEFAULT_POINT_SIZE,\n        );\n    }\n\n    serie.paths = pathsRenderer;\n\n    return serie;\n}\n\nexport const overrideSeriesInUpdate = (dest: Series, source: Series) => {\n    dest.$c = source.$c ?? dest.$c;\n    dest.show = source.show ?? dest.show;\n    dest.data = source.data ?? dest.data;\n    dest.width = source.width ?? dest.width;\n    dest.pointsSize = source.pointsSize ?? dest.pointsSize;\n    dest.color = source.color ?? dest.color;\n    dest.lineColor = source.lineColor ?? dest.lineColor;\n    dest.lineWidth = source.lineWidth ?? dest.lineWidth;\n    dest.stroke = source.stroke ?? dest.stroke;\n    dest.getFocusedColor = source.getFocusedColor ?? dest.getFocusedColor;\n    dest.formatter = source.formatter ?? dest.formatter;\n    dest.paths = source.paths ?? dest.paths;\n};\n", "import type {Scale as uScale, DrawOrderKey as uDrawOrderKey, Axis as uAxis} from 'uplot';\n\nexport const DrawOrderKey: Record<keyof typeof uDrawOrderKey, uDrawOrderKey> = {\n    Series: 'series' as uDrawOrderKey.Series,\n    Axes: 'axes' as uDrawOrderKey.Axes,\n};\n\ninterface YScale {\n    Distr: Record<keyof typeof uScale.Distr, uScale.Distr>;\n}\n\nexport const Scale: YScale = {\n    Distr: {\n        Linear: 1 as uScale.Distr.Linear,\n        Ordinal: 2 as uScale.Distr.Ordinal,\n        Logarithmic: 3 as uScale.Distr.Logarithmic,\n        ArcSinh: 4 as uScale.Distr.ArcSinh,\n    },\n};\n\ninterface YAxis {\n    Side: Record<keyof typeof uAxis.Side, uAxis.Side>;\n    Align: Record<keyof typeof uAxis.Align, uAxis.Align>;\n}\n\nexport const Axis: YAxis = {\n    Side: {\n        Top: 0 as uAxis.Side.Top,\n        Right: 1 as uAxis.Side.Right,\n        Bottom: 2 as uAxis.Side.Bottom,\n        Left: 3 as uAxis.Side.Left,\n    },\n    Align: {\n        Right: 0 as uAxis.Align.Right,\n        Left: 1 as uAxis.Align.Left,\n    },\n};\n", "/* eslint-disable no-nested-ternary */\nimport UPlot, {Range} from 'uplot';\nimport {YagrConfig, Scale} from '../types';\nimport {\n    DEFAULT_MAX_TICKS,\n    DEFAULT_Y_AXIS_OFFSET,\n    DEFAULT_SCALE_MIN_RANGE,\n    DEFAULT_LOGARITHMIC_MIN_SCALE_VALUE,\n    DEFAULT_X_SCALE,\n} from '../defaults';\nimport type Yagr from '../index';\nimport {Scale as YScale} from './types';\n\ntype ScaleRangeType = (min: number, max: number, scfg: Scale, ycfg: YagrConfig) => {min: number; max: number};\n\nexport const getScaleRange = (scale: Scale, config: YagrConfig) => {\n    const range = scale.range;\n    if (typeof range === 'function') {\n        return (u: UPlot, dataMin: number, dataMax: number) => {\n            return range(u, dataMin, dataMax, config);\n        };\n    }\n\n    if (scale.normalize) {\n        return [0, scale.normalizeBase || 100] as Range.MinMax;\n    }\n\n    if (scale.range === 'auto') {\n        return undefined;\n    }\n\n    let rangeFn: ScaleRangeType;\n\n    switch (scale.range) {\n        case undefined:\n        case 'nice': {\n            rangeFn = niceScale;\n            break;\n        }\n        case 'offset': {\n            rangeFn = offsetScale;\n            break;\n        }\n        default:\n            throw new Error(`Unknown scale range type ${scale.range}`);\n    }\n\n    return (_: UPlot, dMin: number, dMax: number): Range.MinMax => {\n        let {min, max} = rangeFn(dMin, dMax, scale, config);\n\n        const minRange = scale.minRange || DEFAULT_SCALE_MIN_RANGE;\n\n        if (Math.abs(max - min) < minRange) {\n            if (min >= 0) {\n                max += minRange;\n            } else {\n                max += minRange / 2;\n                min -= minRange / 2;\n            }\n        }\n\n        min = typeof scale.min === 'number' ? scale.min : min;\n        max = typeof scale.max === 'number' ? scale.max : max;\n\n        /** Protect logarithmic scale from impossible min values */\n        if (scale.type === 'logarithmic') {\n            const isScaleMinDefined = typeof scale.min === 'number';\n\n            if (min <= 0) {\n                min = DEFAULT_LOGARITHMIC_MIN_SCALE_VALUE;\n            } else if (!isScaleMinDefined) {\n                min = Math.min(min, DEFAULT_LOGARITHMIC_MIN_SCALE_VALUE);\n            }\n        }\n\n        if (min >= max || max <= min) {\n            if (typeof scale.max === 'number') {\n                min = max - (niceNum(max - max * 0.1, false) || 1);\n            } else {\n                max = min + (niceNum(min + min * 0.1, false) || 1);\n            }\n        }\n\n        return [min, max];\n    };\n};\n\nexport function offsetScale(dataMin: number, dataMax: number, scaleConfig: Scale) {\n    const startFromZero = dataMin >= 0 && scaleConfig.stacking;\n    const endWithZero = dataMax <= 0 && scaleConfig.stacking;\n\n    return {\n        min: startFromZero\n            ? 0\n            : Math.round(dataMin - Math.abs(dataMin) * (scaleConfig.offset || DEFAULT_Y_AXIS_OFFSET)),\n        max: endWithZero ? 0 : Math.round(dataMax + Math.abs(dataMax) * (scaleConfig.offset || DEFAULT_Y_AXIS_OFFSET)),\n    };\n}\n\n/*\n * Implementation nice scale (see https://www.baeldung.com/cs/choosing-linear-scale-y-axis#procedure-for-identifying-scale-and-ticks)\n * with extra options inherited from Solomon stacked area visualization\n * with extra options implementing consistent incr proximity if dataMin ~= dataMax. (16.01.2020)\n * with extra options for small ranges between max and min (27.01.2020)\n */\nexport function niceScale(dataMin: number, dataMax: number, scaleConfig: Scale) {\n    const startFromZero = dataMin >= 0 && scaleConfig.stacking;\n    const endWithZero = dataMax <= 0 && scaleConfig.stacking;\n\n    /**\n     * This code handles case when scale has user max/min and niceScale's\n     * range after usage of given max-min from scale config creates not centered lines\n     */\n    const dMax = endWithZero ? 0 : typeof scaleConfig.max === 'number' ? scaleConfig.max : dataMax;\n    const dMin = startFromZero ? 0 : typeof scaleConfig.min === 'number' ? scaleConfig.min : dataMin;\n\n    if (dMin === dMax) {\n        return dMin >= 0 ? {min: dMin, max: dMin + 2} : {min: dMin - 1, max: dMin + 1};\n    }\n\n    const difference = dMax - dMin;\n    const range = niceNum(difference, false);\n    const incr = niceNum(range / (DEFAULT_MAX_TICKS - 1), true);\n    let max = Math.ceil(dMax / incr) * incr;\n    max = isNaN(max) ? 100 : max;\n    let min = (startFromZero ? Math.min(0, dMin) : Math.floor(dMin / incr) * incr) || 0;\n\n    /** Workaround for weird ranges */\n    if (min === max) {\n        min -= 1;\n        max += 1;\n    }\n\n    return {\n        min,\n        max,\n    };\n}\n\nfunction niceNum(delta: number, round: boolean) {\n    const exp = Math.floor(Math.log10(delta));\n    const frac = delta / 10 ** exp;\n\n    const niceFrac = round\n        ? frac < 1.5\n            ? 1\n            : frac < 3\n            ? 2\n            : frac < 7\n            ? 5\n            : 10\n        : frac <= 1\n        ? 1\n        : frac <= 2\n        ? 2\n        : frac <= 5\n        ? 5\n        : 10;\n\n    return niceFrac * 10 ** exp;\n}\n\nexport function configureScales(yagr: Yagr, scales: UPlot.Scales, config: YagrConfig) {\n    const scalesToMap = config.scales ? {...config.scales} : {};\n\n    if (!Object.keys(config.scales).length) {\n        scalesToMap.y = {};\n    }\n\n    Object.entries(scalesToMap).forEach(([scaleName, scaleConfig]) => {\n        scales[scaleName] = scales[scaleName] || {};\n        const scale = scales[scaleName];\n\n        if (scaleName === DEFAULT_X_SCALE) {\n            return;\n        }\n\n        const forceMin = typeof scaleConfig.min === 'number' ? scaleConfig.min : null;\n        const forceMax = typeof scaleConfig.max === 'number' ? scaleConfig.max : null;\n\n        /** At first handle case when scale has setted min and max */\n        if (forceMax !== null && forceMin !== null) {\n            if (forceMax <= forceMin) {\n                throw new Error('Invalid scale config. .max should be > .min');\n            }\n            scale.range = [forceMin, forceMax];\n        }\n\n        const isLogScale = scaleConfig.type === 'logarithmic';\n\n        if (isLogScale) {\n            scale.distr = YScale.Distr.Logarithmic;\n            scale.range = getScaleRange(scaleConfig, config);\n\n            return;\n        }\n\n        if (yagr.isEmpty) {\n            scale.range = [forceMin === null ? (isLogScale ? 1 : 0) : forceMin, forceMax === null ? 100 : forceMax];\n            return;\n        }\n\n        scale.range = getScaleRange(scaleConfig, config);\n    });\n\n    if (!scales.x) {\n        scales.x = {\n            time: true,\n        };\n    }\n\n    return scales;\n}\n", "import uPlot from 'uplot';\nimport type {Axis} from 'uplot';\nimport * as defaults from '../defaults';\nimport type Yagr from '../../';\nimport {YagrConfig, AxisOptions} from '../types';\n\nimport {asFn, getUnitSuffix, isNil, px, toFixed} from './common';\nimport {Axis as TypedAxis} from './types';\n\nconst YAGR_AXIS_TO_UPLOT_AXIS = {\n    right: TypedAxis.Side.Right,\n    top: TypedAxis.Side.Top,\n    bottom: TypedAxis.Side.Bottom,\n    left: TypedAxis.Side.Left,\n};\n\nconst AXIS_SIDE_TO_ALIGN = {\n    left: TypedAxis.Align.Right,\n    right: TypedAxis.Align.Left,\n    top: undefined,\n    bottom: undefined,\n};\n\nexport const getAxisPositioning = (side: AxisOptions['side'], align: Axis['align']) => {\n    return {\n        side: side ? YAGR_AXIS_TO_UPLOT_AXIS[side] : TypedAxis.Side.Left,\n        align: align || (side ? AXIS_SIDE_TO_ALIGN[side] : undefined),\n    };\n};\n\nexport const getDefaultNumberFormatter = (precision: 'auto' | number, nullValue = '') => {\n    return (n: number | null) => {\n        if (isNil(n)) {\n            return nullValue;\n        }\n\n        if (n === 0) {\n            return '0';\n        }\n\n        const abs = Math.abs(n);\n        const precisionNum = precision === 'auto' ? 2 : precision;\n\n        const [pow, suffix] = getUnitSuffix(abs);\n        const transformedValue = n / pow;\n\n        return (\n            (precision === 'auto'\n                ? String(transformedValue).replace(/\\.(\\d{5,})/, (match) => {\n                      return match.slice(0, 6);\n                  })\n                : toFixed(transformedValue, precisionNum)) + suffix\n        );\n    };\n};\n\n/*\n * Generates ticks labels values\n */\nconst getNumericValueFormatter = (axisConfig: AxisOptions) => {\n    const p = axisConfig.precision;\n    const numFormatter = getDefaultNumberFormatter(typeof p === 'number' ? p : p || 'auto', '');\n    return function defaultNumericValueFormatter(_: unknown, ticks: number[]) {\n        return ticks.map(numFormatter);\n    };\n};\n\nconst dayTimeFormatter = uPlot.fmtDate('{DD}.{MM}.{YYYY}');\nconst dateTimeFormatter = uPlot.fmtDate('{HH}:{mm}:{ss}');\nconst minuteFormatter = uPlot.fmtDate('{mm}:{ss}');\nconst secondFormatter = uPlot.fmtDate('{mm}:{ss}.{fff}');\nconst yearFormatter = uPlot.fmtDate('{YYYY}');\n\nfunction getTimeFormatterByRange(range: number, ticksCount: number) {\n    let formatter = dayTimeFormatter;\n    const minRange = Math.ceil(range / ticksCount);\n\n    if (minRange <= defaults.SECOND) {\n        formatter = secondFormatter;\n    } else if (minRange <= defaults.MINUTE) {\n        formatter = minuteFormatter;\n    } else if (minRange <= defaults.DAY) {\n        formatter = dateTimeFormatter;\n    } else if (minRange >= defaults.YEAR) {\n        formatter = yearFormatter;\n    }\n\n    return (x: number) => formatter(new Date(x));\n}\n\nexport const getTimeFormatter = (config: YagrConfig) => {\n    const msm = config.chart.timeMultiplier || defaults.TIME_MULTIPLIER;\n    return (_: unknown, ticks: number[]) => {\n        const range = ticks[ticks.length - 1] - ticks[0];\n        const rangeMs = range / msm;\n        const formatter = getTimeFormatterByRange(rangeMs, ticks.length);\n\n        return ticks.map((rawValue) => {\n            return formatter(rawValue / msm);\n        });\n    };\n};\n\nfunction getSplits(splitsCount: number) {\n    return (_: uPlot, __: number, scaleMin: number, scaleMax: number) => {\n        if (splitsCount <= 2) {\n            return [scaleMin, scaleMax];\n        }\n\n        const dist = Math.abs(scaleMax - scaleMin);\n        const step = dist / (splitsCount - 1);\n        let i = step;\n        const splits = [];\n        while (scaleMin + i < scaleMax) {\n            splits.push(scaleMin + i);\n            i += step;\n        }\n        return [scaleMin, ...splits, scaleMax];\n    };\n}\n\n// eslint-disable-next-line complexity\nfunction getAxis(axisConfig: AxisOptions, yagr: Yagr): Axis {\n    const theme = yagr.utils.theme;\n    const config = yagr.config;\n\n    const axis: Axis = {\n        splits: axisConfig.splitsCount ? getSplits(axisConfig.splitsCount) : axisConfig.splits,\n        show: typeof axisConfig.show === 'undefined' ? true : axisConfig.show,\n        label: axisConfig.label || undefined,\n        labelSize: axisConfig.labelSize || defaults.Y_AXIS_LABEL_SIZE,\n        labelFont: axisConfig.labelFont || defaults.AXIS_LABEL_FONT,\n        font: axisConfig.font || defaults.AXIS_VALUES_FONT,\n        stroke: axisConfig.stroke || (() => theme.AXIS_STROKE),\n        ticks: axisConfig.ticks ? {...theme.Y_AXIS_TICKS, ...axisConfig.ticks} : theme.Y_AXIS_TICKS,\n        grid: config.grid || axisConfig.grid || theme.GRID,\n    };\n\n    if (axisConfig.scale === defaults.DEFAULT_X_SCALE) {\n        return Object.assign(axis, {\n            getFormatter: getTimeFormatterByRange,\n            gap: axisConfig.gap ?? defaults.X_AXIS_TICK_GAP,\n            size: asFn(axisConfig.size) || (() => defaults.X_AXIS_SIZE),\n            values: axisConfig.values || getTimeFormatter(config),\n            ticks: axisConfig.ticks ? {...theme.X_AXIS_TICKS, ...axisConfig.ticks} : theme.X_AXIS_TICKS,\n            scale: defaults.DEFAULT_X_SCALE,\n            space: axisConfig.space || (() => defaults.X_AXIS_SPACE),\n            incrs: axisConfig.incrs || (() => defaults.X_AXIS_INCRS.map((i) => i * (config.chart.timeMultiplier || defaults.TIME_MULTIPLIER))),\n            side: 2,\n            stroke: axisConfig.stroke || (() => theme.AXIS_STROKE),\n        });\n    }\n\n    Object.assign(axis, {\n        gap: axisConfig.gap ?? defaults.Y_AXIS_TICK_GAP,\n        size: asFn(axisConfig.size) || defaults.Y_AXIS_SIZE,\n        values: axisConfig.values || getNumericValueFormatter(axisConfig),\n        scale: axisConfig.scale || defaults.DEFAULT_Y_SCALE,\n        getFormatter: () =>\n            getDefaultNumberFormatter(\n                typeof axisConfig.precision === 'number' ? axisConfig.precision : axisConfig.precision || 'auto',\n                '',\n            ),\n        ...getAxisPositioning(axisConfig.side || 'left', axisConfig.align),\n    });\n\n    if (axisConfig.space) {\n        axis.space = axisConfig.space;\n    }\n\n    return axis;\n}\n\nexport function getRedrawOptionsForAxesUpdate(axes: YagrConfig['axes']) {\n    const options: [series: boolean, axes: boolean] = [false, true];\n\n    Object.values(axes).forEach((s) => {\n        const uOpts: (keyof AxisOptions)[] = ['align', 'side', 'size', 'label', 'labelFont', 'labelGap', 'labelSize'];\n        if (uOpts.some((t) => s[t] !== undefined)) {\n            options[1] = true;\n        }\n    });\n\n    return options;\n}\n\n\nfunction pxRatioFont(font: string) {\n\tlet fontSize, fontSizeCss;\n    // eslint-disable-next-line no-return-assign\n\tfont = font.replace(/(\\d+)px/, (_, p1) => px((fontSize = Math.round((fontSizeCss = Number(p1)) * window.devicePixelRatio))));\n\treturn [font, fontSize, fontSizeCss];\n}\n\nexport function updateAxis(yagr: Yagr, uAxis: Axis, axisConfig: AxisOptions) {\n    const upd = getAxis(\n        {\n            ...axisConfig,\n            font: uAxis.font,\n        },\n        yagr,\n    );\n\n    upd.ticks = {...uAxis.ticks, ...upd.ticks};\n    upd.grid = {...uAxis.grid, ...upd.grid};\n    upd.border = {...uAxis.border, ...upd.border};\n    upd.splits = upd.splits || uAxis.splits;\n\n    /**\n     * uPlot implicitly converts theese properties and mutate axis.font and axis.labelFont\n     * but doesn't cover it with typings.\n     * @see https://github.com/leeoniya/uPlot/blob/378faf6fab9b84d86fd25a5b4425dc44d486b64d/src/uPlot.js#L275\n     */\n    if (axisConfig.font && axisConfig.font !== uAxis.font?.[0]) {\n        //@ts-ignore \n        upd.font = pxRatioFont(axisConfig.font);\n    }\n    if (axisConfig.labelFont && axisConfig.labelFont !== uAxis.labelFont?.[0]) {\n        //@ts-ignore\n        upd.labelFont = pxRatioFont(axisConfig.labelFont);\n    }\n\n    Object.assign(uAxis, upd);\n\n    yagr.plugins.plotLines?.update(axisConfig.plotLines, axisConfig.scale);\n}\n\nexport function configureAxes(yagr: Yagr, config: YagrConfig) {\n    const axes: Axis[] = [];\n\n    Object.entries(config.axes).forEach(([scale, axisConfig]) => {\n        axes.push(getAxis({...axisConfig, scale}, yagr));\n    });\n\n    const x = defaults.DEFAULT_X_SCALE;\n    const y = defaults.DEFAULT_Y_SCALE;\n\n    if (!config.axes[x]) {\n        axes.push(getAxis({scale: x}, yagr));\n    }\n\n    if (!axes.find(({scale}) => scale !== x)) {\n        axes.push(getAxis({scale: y}, yagr));\n    }\n\n    return axes;\n}\n", "import {Options, Padding} from 'uplot';\nimport * as defaults from '../defaults';\n\nexport function getPaddingByAxes(options: Options): Padding {\n    let hasLeftAxis = false;\n    let hasRightAxis = false;\n\n    if (options.axes) {\n        options.axes.forEach((axis) => {\n            if (axis.scale === defaults.DEFAULT_X_SCALE) {\n                return;\n            }\n\n            if (axis.side === undefined || axis.side === 3) {\n                hasLeftAxis = true;\n            }\n            if (axis.side === 1) {\n                hasRightAxis = true;\n            }\n        });\n    } else {\n        hasLeftAxis = true;\n    }\n\n    if (hasLeftAxis && !hasRightAxis) {\n        return defaults.PADDING_LEFT;\n    } else if (hasRightAxis && !hasLeftAxis) {\n        return defaults.PADDING_RIGHT;\n    } else {\n        return defaults.PADDING_BOTH;\n    }\n}\n", "import type Yagr from '../../';\nimport UPlot, {Plugin} from 'uplot';\nimport {DEFAULT_X_SCALE, DEFAULT_CANVAS_PIXEL_RATIO} from '../../defaults';\nimport {PLineConfig, PlotLineConfig, YagrPlugin} from '../../types';\nimport {DrawOrderKey} from '../../utils/types';\nimport {deepIsEqual} from '../../utils/common';\nimport {PBandConfig} from 'src/types';\n\nconst MAX_X_SCALE_LINE_OFFSET = 0;\nconst DRAW_MAP = {\n    [DrawOrderKey.Series]: 0,\n    [DrawOrderKey.Axes]: 1,\n    plotLines: 2,\n};\n\nfunction hasPlotLine(list: PlotLineConfig[], p: PlotLineConfig) {\n    return list.some((pl) => {\n        return deepIsEqual(pl, p);\n    });\n}\n\nconst HOOKS_MAP: Record<string, 'draw' | 'drawClear' | 'drawAxes' | 'drawSeries'> = {\n    '012': 'draw',\n    '102': 'draw',\n    '201': 'drawClear',\n    '210': 'drawClear',\n    '120': 'drawAxes',\n    '021': 'drawSeries',\n};\n\nexport type PlotLinesPlugin = YagrPlugin<{\n    update: (additionalPlotLines?: PlotLineConfig[], scale?: string) => void;\n    add: (additionalPlotLines: PlotLineConfig[], scale?: string) => void;\n    clear: (scale?: string) => void;\n    get: () => PlotLineConfig[];\n    remove: (plotLinesToRemove: PlotLineConfig[], scale?: string) => void;\n}>;\n\nexport interface PlotLineOptions {\n    render: (uPlot: uPlot, p: PlotLineConfig) => void;\n}\n\n/*\n * Plugin renders custom lines and bands on chart based on axis config.\n * Axis should be bound to scale.\n */\nexport default function plotLinesPlugin(options: PlotLineOptions): PlotLinesPlugin {\n    let plotLines: PlotLineConfig[] = [];\n\n    return function (yagr: Yagr) {\n        const drawOrder = yagr.config.chart.appearance?.drawOrder;\n\n        const drawIndicies = (drawOrder ? drawOrder.map((key) => DRAW_MAP[key]) : [0, 1, 2]).join('');\n\n        const hook = HOOKS_MAP[drawIndicies] || 'drawClear';\n\n        function renderPlotLines(u: UPlot) {\n            const {ctx} = u;\n            const {height, top, width, left} = u.bbox;\n            const timeline = u.data[0];\n\n            for (const plotLineConfig of plotLines) {\n                if (!plotLineConfig.scale) {\n                    continue;\n                }\n\n                if (options.render) {\n                    options.render(u, plotLineConfig);\n                    continue;\n                }\n\n                ctx.save();\n                ctx.fillStyle = yagr.utils.colors.parse(plotLineConfig.color);\n\n                const {scale, value} = plotLineConfig;\n\n                if (Array.isArray(value)) {\n                    /** This weird code should handles unexpected Inifinities in values */\n                    const [fromValue, toValue] = value.map((val) => {\n                        if (Math.abs(val) !== Infinity) {\n                            if (scale === DEFAULT_X_SCALE) {\n                                if (val < timeline[0]) {\n                                    return timeline[0];\n                                }\n\n                                if (val > timeline[timeline.length - 1]) {\n                                    return timeline[timeline.length - 1];\n                                }\n                            } else {\n                                const scaleCfg = u.scales[scale];\n                                if (scaleCfg.min !== undefined && val < scaleCfg.min) {\n                                    return scaleCfg.min;\n                                }\n\n                                if (scaleCfg.max !== undefined && val > scaleCfg.max) {\n                                    return scaleCfg.max;\n                                }\n                            }\n\n                            return val;\n                        }\n\n                        const pos =\n                            val > 0\n                                ? scale === DEFAULT_X_SCALE\n                                    ? u.width\n                                    : 0\n                                : scale === DEFAULT_X_SCALE\n                                ? 0\n                                : u.height;\n\n                        return u.posToVal(pos, scale);\n                    });\n\n                    const from = u.valToPos(fromValue, scale, true);\n                    const to = u.valToPos(toValue, scale, true);\n                    const accent = (plotLineConfig as PBandConfig).accent;\n\n                    if (scale === DEFAULT_X_SCALE) {\n                        ctx.fillRect(from, top, to - from, height);\n                        if (accent) {\n                            ctx.fillStyle = accent.color;\n                            ctx.fillRect(from, top - accent.space, to - from, accent.space);\n                        }\n                    } else {\n                        ctx.fillRect(left, from, width, to - from);\n                        if (accent) {\n                            ctx.fillStyle = accent.color;\n                            ctx.fillRect(width + left, from, accent.space, to - from);\n                        }\n                    }\n                } else {\n                    const from = u.valToPos(value, scale, true);\n                    const pConf = plotLineConfig as PLineConfig;\n\n                    ctx.beginPath();\n\n                    if (scale === DEFAULT_X_SCALE) {\n                        /** Workaround to ensure that plot line will not be drawn over axes */\n                        const last = u.data[0][u.data[0].length - 1] as number;\n                        const lastValue = u.valToPos(last, scale, true);\n                        if (from - lastValue > MAX_X_SCALE_LINE_OFFSET) {\n                            continue;\n                        }\n\n                        ctx.moveTo(from, top);\n\n                        ctx.lineTo(from, height + top);\n                    } else {\n                        ctx.moveTo(left, from);\n                        ctx.lineTo(width + left, from);\n                    }\n\n                    ctx.lineWidth = pConf.width || DEFAULT_CANVAS_PIXEL_RATIO;\n                    ctx.strokeStyle = pConf.color || '#000';\n                    pConf.dash && ctx.setLineDash(pConf.dash);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n                ctx.restore();\n            }\n        }\n\n        const handler =\n            hook === 'drawSeries'\n                ? (u: UPlot, sIdx: number) => {\n                      if (sIdx === u.series.length - 1) {\n                          renderPlotLines(u);\n                      }\n                  }\n                : renderPlotLines;\n\n        const plugin = {\n            get: () => plotLines,\n            clear: (scale?: string) => {\n                plotLines = scale\n                    ? plotLines.filter((p) => {\n                          return p.scale !== scale;\n                      })\n                    : [];\n            },\n            remove: (plotLinesToRemove: PlotLineConfig[]) => {\n                plotLines = plotLines.filter((p) => {\n                    return !hasPlotLine(plotLinesToRemove, p);\n                });\n            },\n            add: (additionalPlotLines: PlotLineConfig[], scale?: string) => {\n                for (const p of additionalPlotLines) {\n                    plotLines.push(scale ? {scale, ...p} : p);\n                }\n            },\n            update: (newPlotLines?: PlotLineConfig[], scale?: string) => {\n                if (!newPlotLines || newPlotLines.length === 0) {\n                    plugin.clear(scale);\n                    return;\n                }\n\n                const additions = newPlotLines!.filter((p) => {\n                    return !hasPlotLine(plotLines, p);\n                });\n\n                const removes = plotLines.filter((p) => {\n                    return !hasPlotLine(newPlotLines!, p);\n                });\n\n                additions.length && plugin.add(additions, scale);\n                removes.length && plugin.remove(removes);\n            },\n            uplot: {\n                opts: () => {\n                    const config = yagr.config;\n                    plotLines = [];\n\n                    /** Collecting plot lines from config axes for plotLines plugin */\n                    Object.entries(config.axes).forEach(([scale, axisConfig]) => {\n                        if (axisConfig.plotLines) {\n                            axisConfig.plotLines.forEach((plotLine) => {\n                                plotLines.push({...plotLine, scale});\n                            });\n                        }\n                    });\n                },\n                hooks: {\n                    // @TODO Add feature to draw plot lines over series\n                    [hook]: handler,\n                },\n            } as Plugin,\n        };\n\n        return plugin;\n    };\n}\n", "/* eslint-disable complexity */\n\nimport uPlot, {Series, Plugin, Options as UPlotOptions, DrawOrderKey as uDrawOrderKey} from 'uplot';\n\nimport type {MinimalValidConfig} from '../types';\nimport Yagr, {YagrMeta} from '..';\n\nimport tooltipPlugin from '../plugins/tooltip/tooltip';\nimport CursorPlugin from '../plugins/cursor/cursor';\nimport {\n    DEFAULT_CANVAS_PIXEL_RATIO,\n    DEFAULT_FOCUS_ALPHA,\n    DEFAULT_X_SCALE,\n    DEFAULT_X_SERIE_NAME,\n    MIN_SELECTION_WIDTH,\n    TIME_MULTIPLIER,\n} from '../defaults';\nimport {configureSeries} from '../utils/series';\nimport markersPlugin from '../plugins/markers';\nimport {configureScales} from '../utils/scales';\nimport {configureAxes} from '../utils/axes';\nimport {getPaddingByAxes} from '../utils/chart';\nimport {DrawOrderKey} from '../utils/types';\nimport plotLinesPlugin from '../plugins/plotLines/plotLines';\n\nfunction setIfNotSet(hooks: uPlot.Hooks.Arrays[keyof uPlot.Hooks.Arrays], fn: (u: uPlot) => void) {\n    for (const hook of hooks || []) {\n        if (hook === fn) {\n            return;\n        }\n    }\n    hooks?.push(fn);\n}\n\nexport class CreateUplotOptionsMixin<T extends MinimalValidConfig> {\n    initMixin(this: Yagr) {\n        this._uHooks.onDraw = () => {\n            if (this.state.stage === 'listen') {\n                return;\n            }\n            this.state.stage = 'listen';\n            this.execHooks('stage', {chart: this, stage: this.state.stage});\n            const renderTime = performance.now() - this._startTime;\n            this._meta.renderTime = renderTime;\n            this.execHooks('load', {\n                chart: this,\n                meta: this._meta as YagrMeta,\n            });\n        };\n\n        this._uHooks.ready = () => {\n            const initTime = performance.now() - this._startTime;\n            this._meta.initTime = initTime;\n            this.execHooks('inited', {\n                chart: this,\n                meta: {\n                    initTime,\n                },\n            });\n        };\n        this._uHooks.drawClear = (u: uPlot) => {\n            const {ctx} = u;\n            ctx.save();\n            ctx.fillStyle = this.utils.theme.BACKGROUND;\n            ctx.fillRect(\n                DEFAULT_CANVAS_PIXEL_RATIO,\n                DEFAULT_CANVAS_PIXEL_RATIO,\n                u.width * DEFAULT_CANVAS_PIXEL_RATIO - 2 * DEFAULT_CANVAS_PIXEL_RATIO,\n                u.height * DEFAULT_CANVAS_PIXEL_RATIO - 2 * DEFAULT_CANVAS_PIXEL_RATIO,\n            );\n            ctx.restore();\n        };\n        this._uHooks.setSelect = (u: uPlot) => {\n            const {left, width} = u.select;\n            const [_from, _to] = [u.posToVal(left, DEFAULT_X_SCALE), u.posToVal(left + width, DEFAULT_X_SCALE)];\n            const {timeMultiplier = TIME_MULTIPLIER} = this.config.chart || {};\n\n            this.execHooks('onSelect', {\n                from: Math.ceil(_from / timeMultiplier),\n                to: Math.ceil(_to / timeMultiplier),\n                chart: this,\n            });\n            u.setSelect({width: 0, height: 0, top: 0, left: 0}, false);\n        };\n    }\n\n    /**\n     * @internal\n     * @param reOpt If in reOpt cycle (e.g. batch update), then won't reinit hooks.\n     * @description Creates uPlot options from Yagr config, sets up plugins. Non idempotent.\n     * @returns uPlot options\n     */\n    protected createUplotOptions(this: Yagr<T>, reOpt = false) {\n        const {config} = this;\n        const plugins: Plugin[] = [];\n\n        let tooltipInstance = this.plugins?.tooltip;\n\n        /** Setting up TooltipPugin */\n        if (config.tooltip && config.tooltip.show !== false) {\n            if (tooltipInstance) {\n                tooltipInstance.updateOptions(config.tooltip);\n            } else {\n                tooltipInstance = tooltipPlugin(this, config.tooltip);\n            }\n            plugins.push(tooltipInstance.uplot);\n            this.plugins.tooltip = tooltipInstance;\n        }\n\n        if (reOpt) {\n            this.plugins.plotLines && plugins.push(this.plugins.plotLines.uplot);\n        } else {\n            const plotLinesPluginInstance = plotLinesPlugin(this.config.plotLines || {})(this);\n            this.plugins.plotLines = plotLinesPluginInstance;\n            plugins.push(plotLinesPluginInstance.uplot);\n        }\n\n        Object.entries(config.plugins).forEach(([name, plugin]) => {\n            const pluginInstance = plugin(this);\n            plugins.push(pluginInstance.uplot);\n            Object.assign(this.plugins, {[name]: pluginInstance});\n        });\n\n        const chart = config.chart;\n\n        const options: UPlotOptions = {\n            width: this.root.clientWidth,\n            height: this.clientHeight,\n            title: config.title?.text,\n            plugins: plugins,\n            focus: {alpha: DEFAULT_FOCUS_ALPHA},\n            series: [\n                {\n                    id: DEFAULT_X_SERIE_NAME,\n                    $c: config.timeline,\n                    scale: DEFAULT_X_SCALE,\n                    count: config.timeline.length,\n                } as Series,\n            ],\n            ms: chart.timeMultiplier || TIME_MULTIPLIER,\n            hooks: config.hooks || {},\n        };\n\n        this.state.isEmptyDataSet =\n            config.timeline.length === 0 ||\n            config.series.length === 0 ||\n            config.series.every(({data}) => data.length === 0);\n\n        /**\n         * Setting up cursor - points on cursor, drag behavior, crosshairs\n         */\n        options.cursor = options.cursor || {};\n        options.cursor.points = options.cursor.points || {};\n        options.cursor.drag = options.cursor.drag || {\n            dist: chart.select?.minWidth || MIN_SELECTION_WIDTH,\n            x: options.cursor.y ?? true,\n            y: options.cursor.y ?? false,\n            setScale: chart.select?.zoom ?? true,\n        };\n\n        if (this.utils.sync) {\n            options.cursor.sync = options.cursor.sync || {\n                key: this.utils.sync.key,\n            };\n        }\n\n        if (config.cursor) {\n            const cPlugin = CursorPlugin(this, config.cursor);\n            this.plugins.cursor = cPlugin;\n            plugins.push(cPlugin.uplot);\n        }\n\n        const seriesOptions = config.series || [];\n        const resultingSeriesOptions: Series[] = options.series;\n\n        /**\n         * Prepare series options\n         */\n        for (let i = seriesOptions.length - 1; i >= 0; i--) {\n            const serie = configureSeries(this, seriesOptions[i] || {}, i);\n            const uIdx = resultingSeriesOptions.push(serie);\n            this.state.y2uIdx[serie.id || i] = uIdx - 1;\n        }\n\n        /** Setting up markers plugin after default points renderers to be settled */\n        const markersPluginInstance = markersPlugin(this, config);\n        plugins.push(markersPluginInstance);\n\n        options.series = resultingSeriesOptions;\n\n        if (!config.scales || Object.keys(config.scales).length === 0) {\n            config.scales = {\n                x: {},\n                y: {},\n            };\n        }\n\n        /** Setting up scales */\n        options.scales = options.scales || {};\n        options.scales = configureScales(this, options.scales, config);\n\n        /** Setting up minimal axes */\n        options.axes = options.axes || [];\n        const axes = options.axes;\n\n        axes.push(...configureAxes(this, config));\n\n        /** Setting up hooks */\n        options.hooks = config.hooks || {};\n        options.hooks.draw = options.hooks.draw || [];\n        options.hooks.ready = options.hooks.ready || [];\n        options.hooks.drawClear = options.hooks.drawClear || [];\n        options.hooks.setSelect = options.hooks.setSelect || [];\n\n        setIfNotSet(options.hooks.draw, this._uHooks.onDraw);\n        setIfNotSet(options.hooks.ready, this._uHooks.ready);\n        setIfNotSet(options.hooks.drawClear, this._uHooks.drawClear);\n        setIfNotSet(options.hooks.setSelect, this._uHooks.setSelect);\n\n        options.drawOrder = chart.appearance?.drawOrder\n            ? (chart.appearance?.drawOrder.filter(\n                  (key) => key === DrawOrderKey.Series || key === DrawOrderKey.Axes,\n              ) as uDrawOrderKey[])\n            : [DrawOrderKey.Series, DrawOrderKey.Axes];\n\n        /** Disabling uPlot legend. */\n        options.legend = {show: false};\n        options.padding = config.chart.size?.padding || getPaddingByAxes(options);\n\n        /**\n         * Pre-initialization  of legend allows to calculate\n         * legend's height before actual uPlot instance\n         * will be rendered, to avoid blinking height changes\n         */\n        this.plugins.legend?.preInit(this, this.config.legend, options);\n        options.height = this.clientHeight;\n\n        this.options = options;\n\n        return options;\n    }\n}\n", "/* eslint-disable complexity */\n\nimport type {AlignedData} from 'uplot';\nimport type {DataSeries, MinimalValidConfig} from '../types';\nimport type Yagr from '..';\n\nimport {DEFAULT_Y_SCALE} from '../defaults';\nimport {getSumByIdx, preprocess} from '../utils/common';\n\nexport class TransformSeriesMixin<T extends MinimalValidConfig> {\n    /**\n     * @internal\n     * @param this Yagr instance\n     * @description Transforms series data according to config\n     * @returns uPlot series data\n     */\n    protected transformSeries(this: Yagr<T>) {\n        const processingStartTime = performance.now();\n\n        const result = [];\n        const config = this.config;\n        const timeline = config.timeline;\n        let processing = config.processing || false;\n\n        let series: DataSeries[] = this.config.series.map(({data}) => data) as DataSeries[];\n\n        if (processing && processing.interpolation) {\n            series = preprocess(series, timeline, processing);\n            processing = false;\n        }\n\n        const shouldMapNullValues = Boolean(processing && processing.nullValues);\n        const nullValues = (processing && processing.nullValues) || {};\n\n        /**\n         * Stacks are represented as:\n         * {\n         *    [scale]: {\n         *        [],  // stacking group idx 0 (default for all on scale),\n         *        [],  // stacking group idx 1\n         *    ]\n         * }\n         *\n         * All stacked points are accumulating inside of series' scale group\n         */\n        const stacks: Record<string, number[][]> = {};\n\n        for (let sIdx = 0; sIdx < series.length; sIdx++) {\n            let dataLine: (number | null)[] = [];\n            const realSerieIdx = sIdx + 1;\n            const serie = series[sIdx];\n\n            const serieConfigIndex = this.options.series.length - realSerieIdx;\n            const serieOptions = this.options.series[serieConfigIndex];\n            const scale = serieOptions.scale || DEFAULT_Y_SCALE;\n            const scaleConfig = this.config.scales[scale] || {};\n            const isStacking = scaleConfig.stacking;\n            const sGroup = serieOptions.stackGroup || 0;\n\n            let empty = true;\n\n            if (isStacking && !stacks[scale]) {\n                this.options.focus = this.options.focus || {alpha: 1.1};\n                this.options.focus.alpha = 1.1;\n                stacks[scale] = [];\n            }\n\n            if (isStacking && !stacks[scale][sGroup]) {\n                stacks[scale][sGroup] = new Array(timeline.length).fill(0);\n            }\n\n            serieOptions.count = 0;\n\n            for (let idx = 0; idx < serie.length; idx++) {\n                let value = serie[idx];\n\n                if (shouldMapNullValues && nullValues[String(value)]) {\n                    value = null;\n                }\n\n                if (serieOptions.transform) {\n                    serieOptions._transformed = true;\n                    value = serieOptions.transform(value, series, idx);\n                }\n\n                if (scaleConfig.transform) {\n                    serieOptions._transformed = true;\n                    value = scaleConfig.transform(value, series, idx);\n                }\n\n                if (value === null) {\n                    if (serieOptions.type === 'line' || serieOptions.type === 'dots') {\n                        dataLine.push(null);\n                        continue;\n                    } else {\n                        value = isStacking ? 0 : null;\n                    }\n                }\n\n                empty = false;\n\n                if (scaleConfig.normalize) {\n                    const sum = getSumByIdx(this.options.series, idx, scale);\n                    value = sum && ((value ?? 0) / sum) * (scaleConfig.normalizeBase || 100);\n\n                    serieOptions.normalizedData = serieOptions.normalizedData || [];\n                    serieOptions.normalizedData[idx] = value;\n                }\n\n                if (scaleConfig.stacking) {\n                    if (serieOptions.show === false) {\n                        value = 0;\n                    }\n\n                    value = stacks[scale][sGroup][idx] += (value ?? 0);\n                }\n\n                if (scaleConfig.type === 'logarithmic' && value === 0) {\n                    value = 1;\n                }\n\n                serieOptions.sum = (serieOptions.sum || 0) + (value || 0);\n\n                const originalValue = serieOptions.$c[idx];\n                if (typeof originalValue === 'number') {\n                    serieOptions.count += 1;\n                }\n                dataLine.push(value);\n            }\n\n            serieOptions.avg = (serieOptions.sum || 0) / serieOptions.count;\n            serieOptions.empty = empty;\n\n            if (serieOptions.postProcess) {\n                dataLine = serieOptions.postProcess(dataLine, sIdx, this);\n            }\n            result.unshift(dataLine);\n        }\n\n        result.unshift(this.config.timeline);\n\n        this.series = result as AlignedData;\n\n        this.execHooks('processed', {\n            chart: this,\n            meta: {\n                processTime: performance.now() - processingStartTime,\n            },\n        });\n\n        return this.series;\n    }\n}\n", "/* eslint-disable complexity */\n\nimport type {MinimalValidConfig, RawSerieData, Scale, SupportedLocales, YagrConfig, YagrTheme} from '../types';\nimport Yagr from '..';\n\nimport i18n from '../locale';\nimport {DEFAULT_X_SCALE, DEFAULT_Y_SCALE} from '../defaults';\nimport {overrideSeriesInUpdate, configureSeries} from '../utils/series';\nimport {getRedrawOptionsForAxesUpdate, updateAxis} from '../utils/axes';\nimport {Paths, deepIsEqual, get} from '../utils/common';\nimport {Batch} from './batch-updates';\n\ninterface UpdateOptions {\n    incremental?: boolean;\n    splice?: boolean;\n}\n\nfunction setLocaleImpl(yagr: Yagr, batch: Batch, locale: SupportedLocales | Record<string, string>) {\n    yagr.utils.i18n = i18n(locale);\n    batch.redrawLegend = true;\n}\n\nfunction setThemeImpl(yagr: Yagr, themeValue: YagrTheme, batch: Batch) {\n    yagr.utils.theme.setTheme(themeValue);\n    const availableThemes: YagrTheme[] = ['light', 'light-hc', 'dark', 'dark-hc'];\n    const classesToRemove = availableThemes.map((theme) => `yagr_theme_${theme}`);\n    yagr.root.classList.remove(...classesToRemove);\n    yagr.root.classList.add('yagr_theme_' + themeValue);\n    batch.redraw = [false, true];\n}\n\nfunction setAxesImpl(yagr: Yagr, batch: Batch, axes: YagrConfig['axes']) {\n    const {x, ...rest} = axes;\n\n    if (x) {\n        const xAxis = yagr.uplot.axes.find(({scale}) => scale === DEFAULT_X_SCALE);\n\n        if (xAxis) {\n            updateAxis(yagr, xAxis, {scale: DEFAULT_X_SCALE, ...x});\n        }\n    }\n\n    Object.entries(rest).forEach(([scaleName, scaleConfig]) => {\n        const axis = yagr.uplot.axes.find(({scale}) => scale === scaleName);\n\n        if (axis) {\n            updateAxis(yagr, axis, {scale: scaleName, ...scaleConfig});\n        }\n    });\n\n    batch.redraw = getRedrawOptionsForAxesUpdate(axes);\n}\n\nfunction setFocusImpl(yagr: Yagr, lineId: string | null, focus: boolean) {\n    const seriesIdx = lineId === null ? null : yagr.state.y2uIdx[lineId];\n    yagr.plugins.cursor?.focus(seriesIdx, focus);\n    yagr.uplot.setSeries(seriesIdx, {focus});\n}\n\nfunction setVisibleImpl(yagr: Yagr, lineId: string | null, show: boolean, updateLegend: boolean, batch: Batch) {\n    const seriesIdx = lineId === null ? null : yagr.state.y2uIdx[lineId];\n    const seriesCfg = lineId === null ? yagr.config.series : [yagr.config.series.find(({id}) => id === lineId)];\n\n    seriesCfg.forEach((serie) => {\n        if (serie) {\n            serie.show = show;\n        }\n    });\n\n    batch.fns.push(() => {\n        yagr.uplot.setSeries(seriesIdx, {\n            show,\n        });\n    });\n\n    yagr.options.series = yagr.uplot.series;\n\n    let shouldRebuildStacks = false;\n\n    if (seriesIdx) {\n        const series = yagr.uplot.series[seriesIdx];\n        series.show = show;\n        const scaleName = series.scale || DEFAULT_Y_SCALE;\n        const scale = yagr.config.scales[scaleName];\n        shouldRebuildStacks = Boolean(scale && scale.stacking);\n    } else {\n        shouldRebuildStacks = yagr.options.series.reduce((acc, serie) => {\n            const {scale} = serie;\n            serie.show = show;\n            return Boolean((scale && yagr.config.scales[scale]?.stacking) || acc);\n        }, false as boolean);\n    }\n\n    if (shouldRebuildStacks) {\n        // batch.reopt = true;\n        batch.recalc = true;\n        batch.fns.push(() => {\n            yagr.uplot.setData(yagr.series, true);\n            updateLegend && yagr.plugins.legend?.update();\n        });\n    }\n}\n\nfunction setScalesImpl(yagr: Yagr, scales: YagrConfig['scales'], batch: Batch) {\n    let stackingIsChanged = false;\n    let normalizationIsChanged = false;\n\n    Object.entries(scales).forEach(([scaleName, scaleConfig]) => {\n        const scale = yagr.config.scales[scaleName];\n\n        if (scale) {\n            const {stacking} = scale;\n            const {stacking: newStacking} = scaleConfig;\n\n            if (stacking !== newStacking) {\n                stackingIsChanged = true;\n            }\n\n            if (scaleConfig.normalize !== scale.normalize || scaleConfig.normalizeBase !== scale.normalizeBase) {\n                normalizationIsChanged = true;\n            }\n        }\n    });\n\n    const isChangingOnlyMinMax = Object.entries(scales).every(([key, scaleConfig]: [string, Scale]) => {\n        const cfg = yagr.config.scales[key];\n\n        const {min: pMin, max: pMax, ...pRest} = cfg;\n        const {min: nMin, max: nMax, ...nRest} = scaleConfig;\n        const isChangedSomething = deepIsEqual(nRest, pRest) === false;\n\n        return !isChangedSomething && (pMin !== nMin || pMax !== nMax);\n    });\n\n    const isChangingXAxis = Object.keys(scales).includes(DEFAULT_X_SCALE);\n\n    /**\n     * In case if we change only min/max on data-scales, then we can just use uplot.setScale,\n     * otherwise we need to rebuild all series and stacks in order to apply new scales;\n     */\n    if (isChangingOnlyMinMax && !isChangingXAxis) {\n        return Object.entries(scales).forEach(([scaleName, scaleConfig]) => {\n            batch.fns.push(() => {\n                yagr.uplot.setScale(scaleName, {\n                    min: scaleConfig.min!,\n                    max: scaleConfig.max!,\n                });\n            });\n        });\n    }\n\n    if (stackingIsChanged || normalizationIsChanged) {\n        batch.reinit = true;\n    }\n\n    yagr.config.scales = scales;\n    batch.reinit = true;\n}\n\nfunction isChanged(oldConfig: YagrConfig, newConfig: Partial<YagrConfig>) {\n    return function isChangedPath(\n        path: Paths<YagrConfig>,\n        predicate?: (oldValue: unknown, newValue: unknown) => boolean,\n    ) {\n        const oldValue = get(oldConfig, path);\n        const newValue = get(newConfig, path);\n\n        return predicate ? !predicate(oldValue, newValue) : oldValue !== newValue;\n    };\n}\n\nfunction areSeriesChanged(a: YagrConfig['series'], b?: YagrConfig['series']) {\n    if (a.length !== b?.length) {\n        return true;\n    }\n\n    const mapA = new Map<string, YagrConfig['series'][0]>();\n    const mapB = new Map<string, YagrConfig['series'][0]>();\n\n    a.forEach((serie) => {\n        mapA.set(serie.id!, serie);\n    });\n\n    b.forEach((serie) => {\n        mapB.set(serie.id!, serie);\n    });\n\n    if (b.some(({id}) => !mapA.has(id!)) || a.some(({id}) => !mapB.has(id!))) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction setConfigImpl(yagr: Yagr, batch: Batch, newConfig: Partial<YagrConfig>, fullUpdate = false) {\n    if (fullUpdate) {\n        yagr.config = {...yagr.config, ...newConfig};\n        batch.reinit = true;\n        return;\n    }\n\n    const isChangedKey = isChanged(yagr.config, newConfig);\n\n    if (newConfig.title && isChangedKey('title')) {\n        yagr.setTitle(newConfig.title);\n    }\n\n    if (newConfig.chart?.appearance?.theme && isChangedKey('chart.appearance.theme')) {\n        yagr.setTheme(newConfig.chart?.appearance?.theme);\n    }\n\n    if (newConfig.chart?.appearance?.locale && isChangedKey('chart.appearance.locale')) {\n        yagr.setLocale(newConfig.chart?.appearance?.locale);\n    }\n\n    if (newConfig.axes && isChangedKey('axes', deepIsEqual)) {\n        yagr.setAxes(newConfig.axes);\n    }\n\n    if (newConfig.scales && isChangedKey('scales', deepIsEqual)) {\n        yagr.setScales(newConfig.scales);\n    }\n\n    const isChangedSeries = Boolean(newConfig.series) && areSeriesChanged(yagr.config.series, newConfig.series);\n\n    if (isChangedSeries) {\n        batch.redrawLegend = true;\n    }\n\n    if (newConfig.series || newConfig.timeline) {\n        yagr.setSeries(newConfig.timeline ?? yagr.config.timeline, newConfig.series ?? yagr.config.series, {\n            incremental: false,\n        });\n    }\n\n    if (newConfig.tooltip && isChangedKey('tooltip')) {\n        yagr.plugins.tooltip?.updateOptions(newConfig.tooltip);\n    }\n\n    if (newConfig.legend && isChangedKey('legend')) {\n        batch.reinit = true;\n    }\n\n    yagr.plugins.tooltip?.reset();\n\n    batch.reopt = true;\n    yagr.config = {...yagr.config, ...newConfig};\n}\n\nfunction setSeriesImpl(\n    this: Yagr,\n    batch: Batch,\n    timelineOrSeriesOrId: Partial<RawSerieData>[] | number[] | number | string,\n    maybeSeries?: Partial<RawSerieData>[] | Partial<RawSerieData>,\n    options: UpdateOptions = {\n        incremental: true,\n        splice: false,\n    },\n) {\n    let timeline: number[] = [],\n        series: RawSerieData[] = [],\n        updateId: null | string | number = null,\n        useIncremental = false,\n        shouldRecalcData = false,\n        useFullyRedraw;\n\n    if (['number', 'string'].includes(typeof timelineOrSeriesOrId)) {\n        useIncremental = false;\n        useFullyRedraw = false;\n        series = [maybeSeries] as RawSerieData[];\n        updateId = timelineOrSeriesOrId as number | string;\n    } else if (typeof (timelineOrSeriesOrId as Array<number | RawSerieData>)[0] === 'number') {\n        timeline = timelineOrSeriesOrId as number[];\n        series = maybeSeries as RawSerieData[];\n        useIncremental = Boolean(options.incremental);\n        useFullyRedraw = !options.incremental;\n    } else {\n        series = timelineOrSeriesOrId as RawSerieData[];\n        useFullyRedraw = true;\n    }\n\n    if (this.isEmpty && series.some(({data}) => data?.length)) {\n        batch.reinit = true;\n        return;\n    }\n\n    if (useFullyRedraw === false) {\n        let shouldUpdateCursror = false;\n\n        useIncremental && this.config.timeline.push(...timeline);\n        series.forEach((serie) => {\n            let matched =\n                typeof updateId === 'number'\n                    ? this.config.series[0]\n                    : this.config.series.find(({id}) => id === serie.id || id === updateId);\n\n            let id: number | string | undefined = matched?.id;\n\n            if (typeof updateId === 'number' && this.state.y2uIdx[updateId]) {\n                matched = this.config.series[updateId];\n                id = updateId;\n            }\n\n            if (matched && id) {\n                const {data, ...rest} = serie;\n                const seriesIdx = this.state.y2uIdx[id];\n\n                /** @TODO fixme (see Annotations.1) */\n                if (matched.type === 'dots' || serie.type === 'dots' || this.config.chart.series?.type === 'dots') {\n                    batch.reinit = true;\n                }\n\n                if (useIncremental) {\n                    matched.data = data ? matched.data.concat(data) : matched.data;\n                } else if (data?.length) {\n                    matched.data = data;\n                    /**\n                     * We're reprocessing data on every series' data change,\n                     * cause we don't know is it required to process current line or not\n                     * Possible non clear pattern:\n                     *  - series may contain string values to process out with `interpolate` option\n                     *  - series may be in stack group\n                     * @TODO fixme when you got a good idea\n                     */\n                    shouldRecalcData = true;\n                }\n\n                const newSeries = configureSeries(this, Object.assign(matched, rest), seriesIdx);\n                const opts = this.options.series[seriesIdx];\n                const uOpts = this.uplot.series[seriesIdx];\n\n                if (uOpts.show !== newSeries.show) {\n                    batch.fns.push(() => {\n                        this.uplot.setSeries(seriesIdx, {show: newSeries.show});\n                    });\n                }\n\n                if (uOpts._focus === null ? true : uOpts._focus !== newSeries.focus) {\n                    batch.fns.push(() => {\n                        this.uplot.setSeries(seriesIdx, {focus: newSeries.focus});\n                    });\n                }\n\n                if (uOpts.color !== newSeries.color) {\n                    shouldUpdateCursror = true;\n                }\n\n                if (newSeries.scale && this.config.scales[newSeries.scale]?.stacking) {\n                    shouldRecalcData = true;\n                }\n\n                overrideSeriesInUpdate(opts, newSeries);\n                overrideSeriesInUpdate(uOpts, newSeries);\n            } else {\n                batch.fns.push(() => {\n                    const newSeries = configureSeries(this, serie, this.config.series.length);\n                    this.state.y2uIdx[newSeries.id] = this.uplot.series.length;\n                    this.uplot.addSeries(newSeries, this.config.series.length);\n                });\n                this.config.series.push(serie);\n            }\n        });\n\n        if (shouldUpdateCursror) {\n            batch.fns.push(() => {\n                this.plugins.cursor?.updatePoints();\n            });\n        }\n\n        if (options.splice) {\n            const sliceLength = series[0].data.length;\n            this.config.series.forEach((s) => {\n                s.data.splice(0, sliceLength);\n            });\n            this.config.timeline.splice(0, timeline.length);\n        }\n    } else {\n        this.config.timeline = timeline;\n        this.config.series = series;\n        batch.reinit = true;\n    }\n\n    if (!batch.reinit) {\n        this._batch.fns.push(() => this.plugins?.tooltip?.reset());\n\n        if (shouldRecalcData || timeline.length) {\n            batch.recalc = true;\n            batch.fns.push(() => {\n                this.uplot.setData(this.series);\n            });\n        }\n    }\n}\n\nexport class DynamicUpdatesMixin<T extends MinimalValidConfig> {\n    /**\n     * @public\n     * @param locale string | Record<string, string>\n     * @description Set's locale of chart and redraws all locale-dependent elements.\n     */\n    setLocale(this: Yagr<T>, locale: SupportedLocales | Record<string, string>) {\n        this.batch((batch) => setLocaleImpl(this, batch, locale));\n    }\n\n    /**\n     * @public\n     * @param title YagrTitleConfig\n     * @description Set's title of chart and redraws all title-dependent elements.\n     */\n    setTitle(this: Yagr<T>, title: YagrConfig['title']) {\n        this.batch((batch) => {\n            this.config.title = title;\n            this.initTitle();\n            batch.redraw = [true, true];\n        });\n    }\n\n    /**\n     * @public\n     * @param themeValue YagrTheme\n     * @description Set's theme of chart and redraws all theme-dependent elements.\n     */\n    setTheme(this: Yagr<T>, themeValue: YagrTheme) {\n        this.batch((batch) => setThemeImpl(this, themeValue, batch));\n    }\n\n    /**\n     * @public\n     * @param axes axes config\n     * @description Sets new axes config and redraws all axes.\n     */\n    setAxes(this: Yagr<T>, axes: YagrConfig['axes']) {\n        this.batch((batch) => setAxesImpl(this, batch, axes));\n    }\n\n    /**\n     * @public\n     * @param seriesId string\n     * @param series Partial<RawSerieData>\n     * @description Sets new series by series id and redraws series.\n     */\n    setSeries(this: Yagr<T>, seriesId: string, series: Partial<RawSerieData>): void;\n    /**\n     * @public\n     * @param seriesIdx number\n     * @param series Partial<RawSerieData>\n     * @description Sets new series by series index and redraws series.\n     */\n    setSeries(this: Yagr<T>, seriesIdx: number, series: Partial<RawSerieData>): void;\n    /**\n     * @public\n     * @param series Partial<RawSerieData>\n     * @description Sets new series dataset (matching to current timeline) and redraws.\n     */\n    setSeries(this: Yagr<T>, series: Partial<RawSerieData>[]): void;\n    /**\n     * @public\n     * @param timeline number[]\n     * @param series Partial<RawSerieData>\n     * @param options UpdateOptions\n     * @description Sets new series dataset with different timeline and redraws.\n     */\n    setSeries(this: Yagr<T>, timeline: number[], series: Partial<RawSerieData>[], options: UpdateOptions): void;\n    setSeries(\n        this: Yagr<T>,\n        timelineOrSeriesOrId: Partial<RawSerieData>[] | number[] | number | string,\n        maybeSeries?: Partial<RawSerieData>[] | Partial<RawSerieData>,\n        options: UpdateOptions = {\n            incremental: true,\n            splice: false,\n        },\n    ) {\n        this.batch((batch) => setSeriesImpl.call(this, batch, timelineOrSeriesOrId, maybeSeries, options));\n    }\n\n    /**\n     * @public\n     * @param lineId string | null\n     * @param focus boolean\n     * @description Sets focus on line with given id. If id is null, removes focus from all lines.\n     * @returns void\n     */\n    setFocus(this: Yagr<T>, lineId: string | null, focus: boolean) {\n        this.batch(() => setFocusImpl(this, lineId, focus));\n    }\n\n    /**\n     * @public\n     * @param lineId string | null\n     * @param show boolean\n     * @description Sets visibility of line with given id. If id is null, sets visibility of all lines.\n     */\n    setVisible(this: Yagr<T>, lineId: string | null, show: boolean, updateLegend = true) {\n        this.batch((batch) => setVisibleImpl(this, lineId, show, updateLegend, batch));\n    }\n\n    /**\n     * @public\n     * @param scales Record<string, Partial<ScaleConfi>>\n     * @description Sets new scales config and redraws.\n     */\n    setScales(this: Yagr<T>, scales: Record<string, Partial<YagrConfig['scales'][string]>>) {\n        this.batch((batch) => setScalesImpl(this, scales, batch));\n    }\n\n    /**\n     * @public\n     * @experimental\n     * @param newConfig Partial<YagrConfig>\n     * @descriptino Sets new config and redraws.\n     */\n    setConfig(this: Yagr<T>, newConfig: Partial<YagrConfig>, fullUpdate = false) {\n        this.batch((batch) => setConfigImpl(this, batch, newConfig, fullUpdate));\n    }\n}\n\n/**\n * Annotations:\n * 1. If we're operating with dots type then uPlot will be reinitialized\n *    cause it's not possible to re-render dot's markers without reinit\n *\n */\n", "import Yagr from '..';\n\ntype YagrConstructor = new (...args: any[]) => Yagr;\nexport type YMixin<T extends unknown = unknown> = new () => T;\n\nexport function applyMixins(derivedCtor: YagrConstructor, constructors: YMixin[]) {\n    const inits: (() => void)[] = [];\n\n    constructors.forEach((baseCtor) => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n            Object.defineProperty(\n                derivedCtor.prototype,\n                name,\n                Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null),\n            );\n        });\n\n        if (baseCtor.prototype.initMixin) {\n            inits.push(baseCtor.prototype.initMixin);\n        }\n    });\n\n    derivedCtor.prototype.initMixins = function () {\n        inits.forEach((init) => init.call(this));\n    };\n}\n", "import type {MinimalValidConfig} from '../types';\nimport type Yagr from '..';\nimport UPlot from 'uplot';\nimport LegendPlugin from '../plugins/legend/legend';\n\nexport interface Batch {\n    active: boolean;\n    fns: ((s: Batch) => void)[];\n    /** If true then uPlot options will be re-configured  */\n    reopt?: boolean;\n    /** If true then data will be recalculated (use for stacks/normalization/other calculations) */\n    recalc?: boolean;\n    /** False or redraw uPlot redraw arguments */\n    redraw?: false | [series: boolean, axes: boolean];\n    /** If batch will end with full re-instantiation of uPlot */\n    reinit?: boolean;\n    /** If true, legend will be fully redrawn instead of re-initialization  */\n    redrawLegend?: boolean;\n}\n\nexport class BatchMixin<T extends MinimalValidConfig> {\n    protected _batch!: Batch;\n\n    initMixin() {\n        this._batch = {\n            active: false,\n            fns: [],\n        };\n    }\n\n    /**\n     * @public\n     * @param fn batch funcion.\n     * @experimental\n     * @descriptoin Batch wrapper. Batch function accepts batch state, it can be modified to change batch execution behaviour.\n     * @example\n     * ```typescript\n     * yagr.batch((s) => {\n     *    s.reopt = true; // reinit uPlot options\n     *    s.recalc = true; // recalculate series\n     *    s.redraw = [true, true]; // redraw chart\n     *    s.reinit = true; // reinit uPlot chart\n     * });\n     * ```\n     */\n    batch(this: Yagr<T>, fn: (s: Batch) => void) {\n        if (this._batch.active) {\n            return fn(this._batch);\n        }\n\n        this._batch.active = true;\n        fn(this._batch);\n\n        if (this._batch.reinit) {\n            return this.fullUpdate();\n        }\n\n        if (this._batch.redrawLegend) {\n            this.plugins.legend?.redraw();\n        }\n\n        if (this._batch.reopt) {\n            this.createUplotOptions(true);\n        }\n\n        if (this._batch.recalc) {\n            this.inStage('processing', () => {\n                this.transformSeries();\n            }).inStage('listen');\n        }\n\n        this._batch.fns.length && this.uplot.batch(() => this._batch.fns.forEach((fn) => fn(this._batch)));\n\n        if (this._batch.redraw && this.uplot) {\n            this.redraw(...this._batch.redraw);\n        }\n\n        this._batch = {active: false, fns: []};\n    }\n\n    /**\n     *\n     * @internal\n     * @description Full update of chart. Used when config is changed totally.\n     */\n    protected fullUpdate(this: Yagr<T>) {\n        let left: number | undefined;\n        let top: number | undefined;\n\n        this.inStage('dispose', () => {\n            if (this.uplot) {\n                const cursor = this.uplot.cursor;\n                left = cursor.left;\n                top = cursor.top;\n                // uplot may be undefined if chart is not rendered yet, but got update\n                this.uplot.destroy();\n            }\n            this.plugins.legend?.destroy();\n        })\n            .inStage('config', () => {\n                this.plugins.legend = new LegendPlugin();\n                this._batch = {active: false, fns: []};\n                this.createUplotOptions(true);\n                this.options = this.config.editUplotOptions ? this.config.editUplotOptions(this.options) : this.options;\n            })\n            .inStage('processing', () => {\n                this.transformSeries();\n            })\n            .inStage('uplot', () => {\n                this.uplot = new UPlot(this.options, this.series, this.initRender);\n                if (left && top && left > 0 && top > 0) {\n                    this.uplot.setCursor({left, top});\n                }\n\n                // by default uPlot subsribes self to cursor, if we don't need it, we should unsubscribe manually\n                if (!this.state.subscribed) {\n                    this.unsubscribe();\n                }\n            })\n            .inStage('listen');\n    }\n}\n", "import UPlot, {Options as UPlotOptions, AlignedData, Series, SyncPubSub} from 'uplot';\n\nimport LegendPlugin from './plugins/legend/legend';\nimport {TooltipPlugin} from './plugins/tooltip/tooltip';\nimport cursorPlugin from './plugins/cursor/cursor';\nimport {PlotLinesPlugin} from './plugins/plotLines/plotLines';\n\nimport {YagrConfig, MinimalValidConfig, InternalYargHooks} from './types';\n\nimport {debounce, genId, px} from './utils/common';\nimport ColorParser from './utils/colors';\n\nimport ThemedDefaults, {DEFAULT_SYNC_KEY, DEFAULT_TITLE_FONT_SIZE} from './defaults';\nimport i18n from './locale';\n\nimport {CreateUplotOptionsMixin} from './mixins/create-options';\nimport {TransformSeriesMixin} from './mixins/transform-series';\nimport {DynamicUpdatesMixin} from './mixins/dynamic-updates';\n\nimport {applyMixins} from './utils/mixins';\nimport {BatchMixin} from './mixins/batch-updates';\n\nexport interface YagrEvent {\n    chart: Yagr;\n    meta: YagrMeta;\n}\n\nexport type YagrMeta = {\n    renderTime: number;\n    processTime: number;\n    initTime: number;\n};\n\ntype CachedProps = {\n    width: number;\n    height: number;\n};\n\nexport interface YagrState {\n    isEmptyDataSet: boolean;\n    isMouseOver: boolean;\n    stage: 'config' | 'processing' | 'uplot' | 'render' | 'listen' | 'dispose';\n    inBatch?: boolean;\n    y2uIdx: Record<string, number>;\n    subscribed: boolean;\n}\n\n/*\n * Main core-module of Yagr.\n * Implements data processing and autoconfigurable wrapper\n * for uPlot chart.\n * Entrypoint of every Yagr chart.\n */\nclass Yagr<TConfig extends MinimalValidConfig = MinimalValidConfig> {\n    id!: string;\n    options!: UPlotOptions;\n    uplot!: UPlot;\n    root!: HTMLElement;\n    series!: AlignedData;\n    config!: YagrConfig;\n    resizeOb?: ResizeObserver;\n    canvas!: HTMLCanvasElement;\n    plugins: {\n        tooltip?: ReturnType<TooltipPlugin>;\n        plotLines?: ReturnType<PlotLinesPlugin>;\n        cursor?: ReturnType<typeof cursorPlugin>;\n        legend?: LegendPlugin;\n    } & Partial<\n        TConfig['plugins'] extends YagrConfig['plugins']\n            ? {[key in keyof TConfig['plugins']]: ReturnType<TConfig['plugins'][key]>}\n            : {}\n    > = {};\n    state!: YagrState;\n    utils!: {\n        colors: ColorParser;\n        sync?: SyncPubSub;\n        theme: ThemedDefaults;\n        i18n: ReturnType<typeof i18n>;\n    };\n\n    get isEmpty() {\n        return this.state.isEmptyDataSet;\n    }\n\n    protected _startTime!: number;\n    protected _meta: Partial<YagrMeta> = {};\n\n    /** Create uPlot options methods */\n    protected createUplotOptions!: CreateUplotOptionsMixin<TConfig>['createUplotOptions'];\n    protected transformSeries!: TransformSeriesMixin<TConfig>['transformSeries'];\n    protected _uHooks: Record<string, (u: uPlot) => void> = {};\n\n    /** Dynamic update methods */\n    setTheme!: DynamicUpdatesMixin<TConfig>['setTheme'];\n    setLocale!: DynamicUpdatesMixin<TConfig>['setLocale'];\n    setAxes!: DynamicUpdatesMixin<TConfig>['setAxes'];\n    setSeries!: DynamicUpdatesMixin<TConfig>['setSeries'];\n    setVisible!: DynamicUpdatesMixin<TConfig>['setVisible'];\n    setFocus!: DynamicUpdatesMixin<TConfig>['setFocus'];\n    setScales!: DynamicUpdatesMixin<TConfig>['setScales'];\n    setTitle!: DynamicUpdatesMixin<TConfig>['setTitle'];\n    setConfig!: DynamicUpdatesMixin<TConfig>['setConfig'];\n\n    /** Batch update methods */\n    batch!: BatchMixin<TConfig>['batch'];\n    protected fullUpdate!: BatchMixin<TConfig>['fullUpdate'];\n    protected _batch!: BatchMixin<TConfig>['_batch'];\n\n    protected _cache!: CachedProps;\n\n    /** Mixin methods */\n    private initMixins!: () => void;\n\n    constructor(root: HTMLElement, pConfig: TConfig) {\n        this.initMixins();\n\n        this._startTime = performance.now();\n        this.state = {\n            isEmptyDataSet: false,\n            isMouseOver: false,\n            stage: 'config',\n            y2uIdx: {},\n            subscribed: false,\n        };\n\n        const config: YagrConfig = Object.assign(\n            {\n                title: {},\n                data: [],\n                axes: {},\n                series: [],\n                scales: {},\n                hooks: {},\n                settings: {},\n                chart: {},\n                cursor: {},\n                plugins: {},\n                legend: {\n                    show: false,\n                },\n                tooltip: {\n                    show: true,\n                },\n                grid: null,\n                markers: {},\n            },\n            pConfig,\n        );\n\n        this.config = config;\n\n        this.inStage('config', () => {\n            this.id = root.id || genId();\n            this.root = root;\n            this.root.classList.add('yagr');\n\n            if (!this.root.id) {\n                this.root.id = this.id;\n            }\n\n            const colorParser = new ColorParser();\n            const sync = this.config.cursor.sync;\n\n            const chart = this.config.chart;\n\n            chart.series ||= {type: 'line'};\n            chart.size ||= {adaptive: true};\n            chart.appearance ||= {locale: 'en'};\n            chart.select ||= {};\n\n            this.utils = {\n                colors: colorParser,\n                i18n: i18n(config.chart.appearance?.locale || 'en'),\n                theme: new ThemedDefaults(colorParser),\n            };\n\n            colorParser.setContext(root);\n\n            if (sync) {\n                this.utils.sync = UPlot.sync(typeof sync === 'string' ? sync : DEFAULT_SYNC_KEY);\n            }\n\n            if (!chart.size.adaptive && chart.size.width && chart.size.height) {\n                root.style.width = px(chart.size.width);\n                root.style.height = px(chart.size.height);\n            }\n\n            this.plugins.legend = new LegendPlugin();\n            this.setTheme(chart.appearance.theme || 'light');\n            this.createUplotOptions();\n            this._cache = {\n                height: this.options.height,\n                width: this.options.width,\n            };\n            if (config.editUplotOptions) {\n                this.options = config.editUplotOptions(this.options);\n            }\n        })\n            .inStage('processing', () => {\n                this.transformSeries();\n            })\n            .inStage('uplot', () => {\n                this.uplot = new UPlot(this.options, this.series, this.initRender);\n                this.canvas = root.querySelector('canvas') as HTMLCanvasElement;\n\n                this.init();\n\n                const processTime = performance.now() - this._startTime;\n                this._meta.processTime = processTime;\n            })\n            .inStage('render');\n    }\n\n    /**\n     * Redraws Yagr instance by given options.\n     */\n    redraw(series = true, axes = true) {\n        this.uplot.redraw(series, axes);\n    }\n\n    /**\n     *  Get uPlot's Series from series id\n     */\n    getSeriesById(id: string): Series {\n        return this.uplot.series[this.state.y2uIdx[id]];\n    }\n\n    dispose() {\n        this.resizeOb && this.resizeOb.unobserve(this.root);\n        this.unsubscribe();\n        this.plugins?.tooltip?.dispose();\n        this.plugins?.legend?.destroy();\n        this.uplot.destroy();\n        this._uHooks = {};\n        this.execHooks('dispose', {chart: this});\n    }\n\n    toDataUrl() {\n        return this.canvas.toDataURL('img/png');\n    }\n\n    subscribe() {\n        if (this.state.subscribed) {\n            return;\n        }\n\n        this.utils.sync?.sub(this.uplot);\n        this.state.subscribed = true;\n    }\n\n    unsubscribe() {\n        this.utils.sync?.unsub(this.uplot);\n        this.state.subscribed = false;\n    }\n\n    protected init = () => {\n        if (this.config.chart.size?.adaptive && !this.resizeOb) {\n            this.resizeOb = new ResizeObserver(debounce(this.onResize, this.config.chart.size.resizeDebounceMs || 100));\n            this.resizeOb.observe(this.root);\n        }\n\n        if (!this.config.hooks.dispose) {\n            this.config.hooks.dispose = [];\n        }\n\n        /** Unsubscribe in init required to avoid chars been synced without action from developer */\n        this.unsubscribe();\n        this.config.hooks.dispose.push(this.trackMouse());\n    };\n\n    protected execHooks = <T extends keyof InternalYargHooks>(\n        hookName: T,\n        ...args: Parameters<Required<InternalYargHooks>[T][0]>\n    ) => {\n        const hooks = this.config.hooks[hookName];\n        if (Array.isArray(hooks)) {\n            for (const hook of hooks) {\n                if (!hook) {\n                    continue;\n                }\n\n                typeof hook === 'function' && hook(...args);\n            }\n        }\n    };\n\n    protected inStage(stage: YagrState['stage'], fn?: () => void) {\n        this.state.stage === stage;\n        this.execHooks('stage', {chart: this, stage});\n        try {\n            fn && fn();\n        } catch (error) {\n            console.error(error);\n            this.onError(error as Error);\n        }\n        return this;\n    }\n\n    protected initRender = (u: uPlot, done: Function) => {\n        /**\n         * Reimplementing appending u.root to root\n         * and ensure that uPlot instance will be placed\n         * correctly relative to legend\n         */\n        const position = this.config.legend?.position;\n        if (this.root.firstChild) {\n            !position || position === 'bottom'\n                ? this.root.insertBefore(u.root, this.root.firstChild)\n                : this.root.appendChild(u.root);\n        } else {\n            !position || position === 'bottom'\n                ? this.root.appendChild(u.root)\n                : this.root.insertBefore(u.root, this.root.firstChild);\n        }\n\n        if (this.config.legend?.show) {\n            this.plugins.legend?.init(u);\n            this.reflow(false);\n        }\n\n        this.initTitle();\n\n        done();\n    };\n\n    protected initTitle() {\n        /** Setup font size for title if required */\n        if (this.config.title && this.config.title.fontSize) {\n            const size = this.config.title.fontSize;\n            const t = this.root.querySelector('.u-title') as HTMLElement;\n            t.setAttribute('style', `font-size:${size}px;line-height:${size}px;`);\n            t.innerHTML = this.config.title.text;\n        }\n    }\n\n    private onError(error: Error) {\n        this.execHooks('error', {\n            stage: this.state.stage,\n            error,\n            chart: this,\n        });\n        return error;\n    }\n\n    private trackMouse() {\n        const mouseOver = () => {\n            this.state.isMouseOver = true;\n        };\n        const mouseLeave = () => {\n            this.state.isMouseOver = false;\n        };\n        this.root.addEventListener('mouseover', mouseOver);\n        this.root.addEventListener('mouseleave', mouseLeave);\n\n        return () => {\n            this.root.removeEventListener('mouseover', mouseOver);\n            this.root.removeEventListener('mouseleave', mouseLeave);\n        };\n    }\n\n    /*\n     * Resize handler. Should cache height and width to avoid unneccesary resize handling,\n     * when actial width and height of contentRect doesn't changed\n     */\n    private onResize = (args: ResizeObserverEntry[]) => {\n        const [resize] = args;\n\n        if (this._cache.height === resize.contentRect.height && this._cache.width === resize.contentRect.width) {\n            return;\n        }\n\n        this.plugins.tooltip?.reset();\n\n        this.reflow();\n        this.execHooks('resize', {entries: args, chart: this});\n    };\n\n    get clientHeight() {\n        const MARGIN = 8;\n        const offset = this.config.title.text ? (this.config.title.fontSize || DEFAULT_TITLE_FONT_SIZE) + MARGIN : 0;\n        return this.root.clientHeight - offset - (this.plugins.legend?.state.totalSpace || 0);\n    }\n\n    reflow(redraw = true) {\n        const width = this.root.clientWidth;\n        const height = this.clientHeight;\n\n        this._cache.width = width;\n        this.options.width = width;\n        this._cache.height = height;\n        this.options.height = height;\n        redraw &&\n            this.uplot.setSize({\n                width: this.options.width,\n                height: this.options.height,\n            });\n        redraw && this.uplot.redraw();\n    }\n}\n\napplyMixins(Yagr, [CreateUplotOptionsMixin, TransformSeriesMixin, DynamicUpdatesMixin, BatchMixin]);\n\nexport default Yagr;\n", "export * from './YagrCore/types';\nexport * from './YagrCore/plugins/tooltip/types';\n\nexport {CursorOptions} from './YagrCore/plugins/cursor/cursor';\nexport {LegendOptions} from './YagrCore/plugins/legend/legend';\n\nimport * as DEF from './YagrCore/defaults';\nexport const defaults = DEF;\n\nimport Yagr from './YagrCore/index';\n\nif (typeof window !== 'undefined') {\n    Object.assign(window, {\n        Yagr,\n    });\n}\n\nexport default Yagr;\n"],
  "mappings": "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",
  "names": ["max", "min", "key", "points", "_", "nextPage", "prevPage", "html", "min", "max", "_", "tzDate", "fmtDate", "s", "dataIdx", "gaps", "rect", "w", "points", "u", "seriesIdx", "size", "font", "off", "key", "self", "i", "opts", "sidesWithAxes", "join", "facet", "data", "xScaleKey", "idxs", "strokePath", "strokeStyle", "fillPath", "fillStyle", "shiftAmt", "ticks", "border", "grid", "can", "seriesIdxMatcher", "rect", "html", "nonNullIdx", "rect", "getFocusedColor", "_", "_", "min", "max", "round", "abs", "pow", "numFormatter", "_", "ticks", "pxRatioFont", "font", "id", "fn", "resize"]
}
